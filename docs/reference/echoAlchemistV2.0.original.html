<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>å›è²ç…‰é‡‘å¸« (Echo Alchemist) - Ver 8.2 (Special Enemies)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Noto+Serif+TC:wght@400;700&display=swap');

        body {
            background-color: #020617;
            color: #e2e8f0;
            font-family: 'Noto Serif TC', serif;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        #game-container {
            position: relative;
            width: 100%;
            
            /* --- ä¿®æ”¹å¼€å§‹ --- */
            /* å…¼å®¹æ—§æµè§ˆå™¨ */
            height: 100vh; 
            /* æ ¸å¿ƒä¿®å¤ï¼šä½¿ç”¨åŠ¨æ€è§†å£é«˜åº¦ï¼Œè‡ªåŠ¨å‡å»åœ°å€æ é«˜åº¦ */
            height: 100dvh; 
            /* --- ä¿®æ”¹ç»“æŸ --- */

            background: #0f172a; 
            background: radial-gradient(circle at center, #1e293b 0%, #020617 100%);
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        @keyframes shake-hard {
            0% { transform: translate(0, 0); }
            25% { transform: translate(-5px, 5px); }
            50% { transform: translate(5px, -5px); }
            75% { transform: translate(-5px, -5px); }
            100% { transform: translate(0, 0); }
        }
        .shake-hard { animation: shake-hard 0.2s; }
        /* --- [æ–°å¢] æŠ€èƒ½ç‚¹å®çŸ³æ ·å¼ --- */
        .sp-slot {
            width: 20px;
            height: 20px;
            background: rgba(15, 23, 42, 0.6); /* æ·±è‰²åº•æ§½ */
            border: 2px solid #475569;         /* è¾¹æ¡† */
            transform: rotate(45deg);          /* æ—‹è½¬æˆè±å½¢ */
            position: relative;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
            transition: all 0.3s;
        }

        /* å®çŸ³æœ¬ä½“ */
        .sp-gem {
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #34d399 0%, #059669 100%); /* ç¿¡ç¿ ç»¿å®çŸ³ */
            box-shadow: 0 0 8px #10b981;
            opacity: 0;
            transform: scale(0);
            transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1); /* å¼¹æ€§å¼¹å‡ºåŠ¨ç”» */
        }

        /* æ¿€æ´»çŠ¶æ€ */
        .sp-gem.active {
            opacity: 1;
            transform: scale(0.8); /* ç¨å¾®ç•™ä¸€ç‚¹è¾¹æ¡† */
        }

        /* è·å¾—å®çŸ³æ—¶çš„é—ªå…‰ç‰¹æ•ˆ */
        @keyframes gemFlash {
            0% { filter: brightness(2); transform: scale(1.2) rotate(45deg); }
            100% { filter: brightness(1); transform: scale(1) rotate(45deg); }
        }
        .sp-slot.flash {
            animation: gemFlash 0.3s ease-out;
            border-color: #34d399;
        }

        /* Animated Phase Title */
        #phase-title-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 100;
            text-align: center;
            width: 100%;
            transition: all 0.8s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        #phase-title-container.minimized {
            top: max(20px, env(safe-area-inset-top));
            left: 20px;
            transform: translate(0, 0) scale(0.4);
            transform-origin: top left;
            opacity: 0.6;
        }
        /* --- [æ–°å¢] è‹±é›„å……èƒ½æ¡æ ·å¼ --- */
        /* --- [ä¿®æ”¹] è‹±é›„å……èƒ½æ¡æ ·å¼ --- */
#hero-gauge-container {
    /* 1. ä½ç½®æå‡ï¼šè¿œç¦»åº•éƒ¨é¢æ¿ (åŸ100px -> 145px) */
    bottom: 145px; 
    
    /* 2. ç¡®ä¿å±‚çº§ */
    z-index: 80;
    
    /* 3. åŸºç¡€é˜´å½± (ä¼šè¢« JS åŠ¨æ€è¦†ç›–ï¼Œä½†ä½œä¸ºå…œåº•) */
    filter: drop-shadow(0 10px 20px rgba(0,0,0,0.5));
    
    /* 4. è¿™é‡Œçš„ transition è´Ÿè´£å¤„ç† CSS ç±»çš„å˜åŒ–ï¼ˆå¦‚å—å‡»éœ‡åŠ¨ï¼‰ï¼Œ
       è€Œä½ç½®çš„ç§»åŠ¨å°†ç”± JS æ¯å¸§é©±åŠ¨ä»¥ä¿è¯è·Ÿæ‰‹ */
    transition: filter 0.2s, opacity 0.2s;
    
    /* ç¡®ä¿å®ƒä¸ä¼šæ‹¦æˆªé¼ æ ‡äº‹ä»¶ï¼Œè®©ä½ å¯ä»¥ç‚¹åˆ°åé¢çš„çƒ */
    pointer-events: none;
}


        /* å—å‡»æ—¶çš„å¼¹æ€§éœ‡åŠ¨ */
        .gauge-shake {
            animation: gaugeBump 0.2s cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
        }

        @keyframes gaugeBump {
            0% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.1); filter: brightness(1.3); }
            100% { transform: translateX(-50%) scale(1); }
        }

        /* --- 1. ä¿®å¤ï¼šåŒå‘æµæ·Œçš„èƒ½é‡è„‰å†² (Dual Flow Border) --- */
        #gauge-pulse-layer {
            position: absolute;
            inset: -2px; /* åŒ…ä½è¾¹ç¼˜ */
            border-radius: 9999px;
            pointer-events: none;
            z-index: 50; /* æµ®åœ¨æœ€ä¸Šå±‚ */
            
            /* æ ¸å¿ƒï¼šæŒ–ç©ºä¸­é—´ï¼Œåªç•™ 3px è¾¹æ¡†ç”¨äºæ˜¾ç¤ºå…‰æµ */
            -webkit-mask: 
                linear-gradient(#fff 0 0) content-box, 
                linear-gradient(#fff 0 0);
            -webkit-mask-composite: xor;
            mask-composite: exclude;
            padding: 3px; /* å…‰æµç²—ç»† */
            
            opacity: 0; /* é»˜è®¤éšè— */
            mix-blend-mode: screen; /* æ»¤è‰²æ¨¡å¼ï¼Œè®©å…‰æ›´äº® */
        }

        /* æ¿€æ´»çŠ¶æ€ */
        #gauge-pulse-layer.pulse-active {
            opacity: 1;
            transition: opacity 0s;
        }
        #gauge-pulse-layer:not(.pulse-active) {
            transition: opacity 0.5s ease-out;
        }

        /* --- å·¦ä¾§æµå…‰ (é€†æ—¶é’ˆ) --- */
        #gauge-pulse-layer::before {
            content: '';
            position: absolute;
            inset: -50%; /* æ‰©å¤§èŒƒå›´ä»¥è¦†ç›–æ—‹è½¬ */
            
            /* æ¸å˜ï¼šç™½è‰²å¤´ -> é¢œè‰² -> é€æ˜å°¾å·´ */
            /* æ”¾åœ¨ 0deg (12ç‚¹é’Ÿæ–¹å‘) */
            background: conic-gradient(
                from 0deg, 
                #ffffff 0%, 
                var(--pulse-color, #fbbf24) 10%, 
                transparent 35%
            );
            
            opacity: 0; 
            transform: rotate(0deg); 
        }

        /* --- å³ä¾§æµå…‰ (é¡ºæ—¶é’ˆ) --- */
        #gauge-pulse-layer::after {
            content: '';
            position: absolute;
            inset: -50%;
            
            /* æ¸å˜ï¼šé•œåƒé€»è¾‘ï¼Œå°¾å·´åœ¨å‰ï¼Œç™½è‰²å¤´åœ¨å (æ¥è¿‘ 360deg) */
            background: conic-gradient(
                from 0deg, 
                transparent 65%, 
                var(--pulse-color, #fbbf24) 90%, 
                #ffffff 100%
            );
            
            opacity: 0;
            transform: rotate(0deg);
        }

        /* æ¿€æ´»æ—¶çš„åŠ¨ç”» */
        #gauge-pulse-layer.pulse-active::before {
            opacity: 1;
            /* å·¦è¾¹ï¼šé€†æ—¶é’ˆæ—‹è½¬ 0 -> -180åº¦ (åˆ°è¾¾åº•éƒ¨) */
            animation: flowLeft 0.6s cubic-bezier(0.1, 0.5, 0.1, 1) forwards;
        }

        #gauge-pulse-layer.pulse-active::after {
            opacity: 1;
            /* å³è¾¹ï¼šé¡ºæ—¶é’ˆæ—‹è½¬ 0 -> 180åº¦ (åˆ°è¾¾åº•éƒ¨) */
            animation: flowRight 0.6s cubic-bezier(0.1, 0.5, 0.1, 1) forwards;
        }

        @keyframes flowLeft {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(-180deg); }
        }

        @keyframes flowRight {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(180deg); }
        }

        /* --- 2. ä¿®å¤ï¼šè¿›åº¦æ¡ä¸å…‰æ³½é®ç½© (è§£å†³é«˜å…‰è·‘åé—®é¢˜) --- */
        /* è¿›åº¦æ¡å¤–å£³ */
        /* --- CSS ä¿®æ”¹å¼€å§‹ --- */

/* è¿›åº¦æ¡å¤–å£³ */
#gauge-shell {
    position: relative;
    overflow: hidden; 
    transform: translateZ(0);
    background: rgba(15, 23, 42, 0.95);
    border-radius: 9999px;
    
    /* [æ ¸å¿ƒä¿®å¤]ï¼šä½¿ç”¨çº¿æ€§é®ç½© */
    /* ä¹‹å‰çš„å¾„å‘é®ç½©(radial)åœ¨é•¿æ¡å®¹å™¨ä¸Šä¼šå¯¼è‡´ä¸¤ç«¯è¢«"åˆ‡æ‰"ï¼Œ*/
    /* æ”¹ä¸ºçº¿æ€§é®ç½©(linear)å¯ä»¥å®Œç¾è¦†ç›–æ•´ä¸ªé•¿åº¦ï¼ŒåŒæ—¶ä¿®å¤åœ†è§’æº¢å‡ºé—®é¢˜ã€‚ */
    -webkit-mask-image: -webkit-linear-gradient(#fff, #fff);
    mask-image: linear-gradient(#fff, #fff);
}

/* [æ–°å¢]ï¼šå…¨å±€ç»ç’ƒæ‰«å…‰ (ç§»åˆ° Shell ä¸Š) */
#gauge-shell::after {
    content: '';
    position: absolute;
    top: 0; left: 0; bottom: 0; right: 0;
    
    /* ä¿®æ”¹ï¼šå®½åº¦è®¾ä¸º 100% å³å¯ï¼Œé…åˆ transform */
    width: 100%; 
    
    /* è°ƒæ•´æ¸å˜ï¼šå¢å¼ºä¸­é—´çš„äº®åº¦ï¼Œä¸¤ä¾§é€æ˜ */
    background: linear-gradient(
        110deg, 
        transparent 35%, 
        rgba(255, 255, 255, 0.1) 40%, 
        rgba(255, 255, 255, 0.8) 50%, 
        rgba(255, 255, 255, 0.1) 60%, 
        transparent 65%
    );
    
    /* åŠ¨ç”»è®¾ç½® */
    animation: glassShine 3s infinite ease-in-out;
    
    z-index: 10; 
    pointer-events: none;
    mix-blend-mode: overlay; 
}

/* ä¼˜åŒ–åçš„åŠ¨ç”»å…³é”®å¸§ */
@keyframes glassShine {
    0% { 
        /* ä»å®Œå…¨å·¦ä¾§å¤–å¼€å§‹ (-100% è‡ªèº«å®½åº¦) */
        transform: translateX(-100%); 
    }
    60% { 
        /* æ‰«åˆ°å®Œå…¨å³ä¾§å¤– (+100% è‡ªèº«å®½åº¦) */
        /* å¢åŠ åˆ° 60% çš„æ—¶é—´å æ¯”ï¼Œè®©æ‰«å…‰ç¨å¾®æ…¢ä¸€ç‚¹ç‚¹ï¼Œæ›´ä¼˜é›… */
        transform: translateX(100%); 
    }
    100% { 
        /* ä¿æŒåœ¨å³ä¾§å¤–ï¼Œç­‰å¾…ä¸‹ä¸€æ¬¡å¾ªç¯ (ç•™ç™½æ—¶é—´) */
        transform: translateX(100%); 
    } 
}

/* --- CSS ä¿®æ”¹ç»“æŸ --- */


        /* è¿›åº¦æ¡æœ¬ä½“ */
        #hit-bar {
            position: relative;
            height: 100%;
            width: 0%;
            /* è¿›åº¦æ¡ä¸å†è´Ÿè´£é«˜å…‰ï¼Œåªè´Ÿè´£é¢œè‰² */
            background: linear-gradient(90deg, #0891b2, #22d3ee); 
            transition: width 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
            z-index: 1; /* æ”¾åœ¨åº•å±‚ */
        }
        
        /* æ»¡èƒ½é‡æ—¶çš„å˜è‰² */
        #hit-bar.bar-full {
            background: linear-gradient(90deg, #d97706, #fbbf24, #fff);
            box-shadow: 0 0 15px #fbbf24;
        }

        /* å†…éƒ¨é«˜å…‰ (Shimmy) - ä¿®å¤ä½ç½®é”å®š */
        #hit-bar::after {
            content: none;
        }
        /* [æ–°å¢]ï¼šå…¨å±€ç»ç’ƒæ‰«å…‰ (ç§»åˆ° Shell ä¸Š) */
        /* è¿™æ ·é«˜å…‰å°±ä¼šæ‰«è¿‡æ•´ä¸ªç®¡å­ï¼Œä¸¤å¤´éƒ½æ˜¯åœ†çš„ */
        


        @keyframes barShine {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(200%); } /* æ‰«å¾—æ›´è¿œä¸€ç‚¹ä»¥ç¡®ä¿å®Œå…¨ç¦»å¼€ */
        }
        /* è¿›åº¦æ¡å¡«å……çš„é«˜å…‰æµå…‰ */
        #hit-bar::after {
            content: '';
            position: absolute;
            top: 0; left: 0; bottom: 0; width: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
            transform: translateX(-100%);
            animation: shimmy 2s infinite;
        }
        @keyframes shimmy {
            100% { transform: translateX(200%); }
        }
        .phase-text {
            font-family: 'Cinzel', serif;
            font-size: 3.5rem;
            font-weight: bold;
            color: #facc15;
            text-shadow: 0 0 30px rgba(250, 204, 21, 0.6);
            background: linear-gradient(to bottom, #fef08a, #ca8a04);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            letter-spacing: 2px;
        }
        .phase-sub {
            font-size: 1rem;
            color: #94a3b8;
            margin-top: 0.5rem;
            opacity: 1;
            transition: opacity 0.5s;
        }
        .minimized .phase-sub { opacity: 0; }

        /* UI Overlays */
        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; 
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding-top: max(70px, env(safe-area-inset-top)); 
            padding-bottom: env(safe-area-inset-bottom);
            transition: opacity 0.3s;
        }

        /* Top Bar */
        .top-bar {
            position: absolute;
            top: max(10px, env(safe-area-inset-top));
            right: 10px; 
            display: flex;
            gap: 8px;
            z-index: 90;
            pointer-events: auto;
        }

        .stat-pill {
            background: rgba(15, 23, 42, 0.8);
            border: 1px solid #475569;
            padding: 0.3rem 0.8rem;
            border-radius: 999px;
            font-family: 'Cinzel', serif;
            color: #e2e8f0;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 4px;
            backdrop-filter: blur(4px);
        }
        .stat-highlight { color: #facc15; font-weight: bold; }

        .btn-icon {
            width: 32px; height: 32px;
            display: flex; align-items: center; justify-content: center;
            background: rgba(30, 41, 59, 0.9);
            border: 1px solid #475569;
            border-radius: 50%;
            color: #94a3b8;
            cursor: pointer;
        }

        /* Bottom Panel */
          .bottom-panel {
            /* åŸæ¥æ˜¯ 90px */
            height: 115px; 
            
            /* ä¿æŒå…¶ä»–æ ·å¼ä¸å˜ */
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: rgba(15, 23, 42, 0.98);
            border-top: 1px solid #475569;
            padding: 0 12px;
            padding-bottom: max(0px, env(safe-area-inset-bottom));
            pointer-events: auto;
            display: flex;
            align-items: center;
            box-shadow: 0 -4px 20px rgba(0,0,0,0.5);
            z-index: 50;
        }
        /* Hit Bar */
        .hit-container {
            display: flex; align-items: center; gap: 8px;
            font-size: 0.75rem; color: #94a3b8;
        }
        .hit-bar-bg {
            flex: 1; height: 8px; background: #334155; border-radius: 4px; overflow: hidden;
        }
        .hit-bar-fill {
            height: 100%; background: linear-gradient(90deg, #f59e0b, #fbbf24);
            width: 0%; transition: width 0.2s;
            box-shadow: 0 0 10px rgba(251, 191, 36, 0.5);
        }

        /* Queue & Recipe */
        .queue-container {
            display: flex; align-items: center; gap: 4px;
            border-right: 1px solid #334155; padding-right: 10px;
            margin-right: 4px;
        }
        .queue-dot {
            width: 20px; height: 20px; border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.2);
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        /* Recipe Cards */
        .recipe-scroll {
            display: flex; 
            gap: 8px; 
            overflow-x: auto;
            scrollbar-width: none;
            
            /* æ ¸å¿ƒä¿®æ”¹ï¼šå¼ºåˆ¶ä¸æ¢è¡Œï¼Œä¸”é«˜åº¦å¡«æ»¡å®¹å™¨ */
            flex-wrap: nowrap; 
            height: 100%;
            align-items: center; /* å¡ç‰‡å‚ç›´å±…ä¸­ */
            width: 100%;
            padding-right: 20px; /* é˜²æ­¢æœ€åä¸€ä¸ªè´´è¾¹ */
        }
        /* --- æ–°å¢ï¼šé…æ–¹é”å®š/å®Œæˆæ—¶çš„ç‰¹æ•ˆåŠ¨ç”» --- */
        @keyframes recipeLockFlash {
            0% { 
                transform: scale(1); 
                background: rgba(50, 60, 90, 0.9); 
                box-shadow: 0 0 0px transparent;
            }
            50% { 
                transform: scale(1.15) translateY(-5px); 
                background: #fff; 
                border-color: #fff;
                box-shadow: 0 0 20px #fff; 
                z-index: 10;
            }
            100% { 
                transform: scale(1); 
                background: rgba(50, 60, 90, 0.9); 
                box-shadow: 0 0 0px transparent;
            }
        }
        .recipe-card {
            background: rgba(30, 41, 59, 0.6); /* ç¨å¾®å¢åŠ é€æ˜åº¦è®©å®ƒçœ‹èµ·æ¥è½»ç›ˆç‚¹ */
            border: 1px solid #475569;
            border-radius: 6px;
            
            /* [ä¼˜åŒ–]ï¼šå‡å°‘å†…è¾¹è· (åŸ 6px 10px) */
            padding: 4px 8px; 
            
            width: max-content;
            min-width: 80px; /* ç¨å¾®è°ƒå°æœ€å°å®½åº¦ */
            height: auto;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        .mats-grid {
            display: grid;
            grid-template-rows: repeat(4, min-content); /* ä¿æŒ4è¡Œ */
            grid-auto-flow: column; /* è¶…è¿‡4è¡Œè‡ªåŠ¨æ¢åˆ— */
            
            /* [ä¼˜åŒ–]ï¼šå¤§å¹…å‡å°‘è¡Œé—´è· (åŸ 2px)ï¼Œåˆ—é—´è·ä¿æŒ 12px */
            gap: 0px 12px; 
            
            /* [ä¼˜åŒ–]ï¼šå‡å°‘é¡¶éƒ¨é—´è· (åŸ 4px) */
            margin-top: 2px;
        }

        /* --- 4. è°ƒæ•´è¡Œæ–‡å­—æ ·å¼ --- */
        .mat-row {
            display: flex;
            align-items: center;
            white-space: nowrap;
            
            /* [ä¼˜åŒ–]ï¼šå¼ºåˆ¶è¡Œé«˜ç´§å‡‘ï¼Œé˜²æ­¢æ–‡å­—è‡ªå¸¦çš„ä¸Šä¸‹ç•™ç™½æ’‘é«˜ */
            line-height: 1.3; 
            
            /* [ä¼˜åŒ–]ï¼šå­—ä½“ç¨å¾®è°ƒå°ä¸€ç‚¹ç‚¹ (åŸé»˜è®¤å¯èƒ½æ˜¯ 0.7rem) */
            font-size: 0.65rem; 
        }
        .recipe-card.locked-anim {
            animation: recipeLockFlash 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        .recipe-card.active {
            background: rgba(50, 60, 90, 0.9);
            border-color: #fbbf24;
            transform: scale(1.05);
            box-shadow: 0 0 10px rgba(251, 191, 36, 0.1);
        }

        /* Selection Grid */
        .marble-grid {
            display: grid; 
            grid-template-columns: repeat(3, 1fr); 
            gap: 10px;
            padding: 10px 20px; /* å‡å°ä¸Šä¸‹ padding */
            pointer-events: auto;
            width: 100%;
            max-width: 400px; /* é™åˆ¶æœ€å¤§å®½åº¦ï¼Œé˜²æ­¢åœ¨å¹³æ¿/PCä¸Šå¡ç‰‡å¤ªå¤§ */
            margin: 0 auto;   /* å±…ä¸­ */
        }
        .select-card {
            background: rgba(30, 41, 59, 0.8);
            border: 2px solid #475569;
            border-radius: 12px;
            /* ä¿®æ”¹: ä¸å¼ºåˆ¶å®½é«˜æ¯”ï¼Œæ”¹ç”¨å›ºå®šé«˜åº¦èŒƒå›´ï¼Œæ›´çœç©ºé—´ */
            /* aspect-ratio: 3/4; */ 
            height: 110px; /* å›ºå®šé«˜åº¦ï¼Œé˜²æ­¢è¢«æŒ¤å‹æˆ–æ’‘å¾—å¤ªé«˜ */
            
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            cursor: pointer; transition: all 0.2s;
            position: relative;
        }
        .select-card.selected {
            border-color: #fbbf24; background: rgba(50, 60, 90, 0.9);
            box-shadow: 0 0 15px rgba(251, 191, 36, 0.3);
            transform: translateY(-4px);
        }
        .select-icon {
            width: 40px; height: 40px; /* ç¨å¾®è°ƒå°å›¾æ ‡ */
            border-radius: 50%; margin-bottom: 6px;
            box-shadow: inset -2px -2px 6px rgba(0,0,0,0.5), 2px 2px 6px rgba(255,255,255,0.3);
            flex-shrink: 0;
        }

        /* Buttons */
        .btn-main {
            background: linear-gradient(135deg, #4f46e5 0%, #3730a3 100%);
            color: white; font-family: 'Cinzel', serif;
            padding: 12px; border-radius: 8px; width: 80%;
            text-align: center; margin: 0 auto;
            box-shadow: 0 4px 10px rgba(79, 70, 229, 0.4);
            pointer-events: auto;
            transition: opacity 0.2s;
        }
        .btn-main:disabled { opacity: 0.5; filter: grayscale(1); }

        /* Toast */
        #toast {
            position: absolute; top: 20%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8); color: #fff; padding: 8px 16px; border-radius: 20px;
            pointer-events: none; opacity: 0; transition: opacity 0.3s; z-index: 200;
            border: 1px solid #475569;
        }
        .toast-visible { opacity: 1 !important; }
        
        /*
        .recipe-hud-floating {
            position: absolute;
            bottom: max(20px, env(safe-area-inset-bottom)); 
            right: 16px;
            width: 160px; 
            display: flex;
            flex-direction: column-reverse;
            gap: 6px;
            pointer-events: auto; 
            z-index: 20;
        }
        .recipe-card.current {
            background: rgba(50, 60, 90, 0.9);
            border-color: #fbbf24;
            box-shadow: 0 0 8px rgba(251, 191, 36, 0.2);
            transform: scale(1.05);
        }
        .recipe-card.queue { opacity: 0.5; transform: scale(0.95); }
        */
        /* æˆ˜æ–—é˜¶æ®µ HUD æµ®åŠ¨å®¹å™¨ */
        /* æˆ˜æ–—é˜¶æ®µ HUD æµ®åŠ¨å®¹å™¨ */
        .recipe-hud-floating {
            position: absolute;
            
            /* 1. å‚ç›´å®šä½ï¼šåº•éƒ¨ä¸ç‚®å°åŸºåº§(bottom:80px)è§†è§‰å¹³é½ */
            bottom: 80px; 
            
            /* 2. æ°´å¹³å®šä½ï¼šå±å¹•ä¸­å¿ƒ */
            left: 50%;
            /* å‘å·¦åç§»ï¼šå°†å®¹å™¨ç§»åŠ¨åˆ°ç‚®å°å·¦ä¾§ (æ•°å€¼å¯å¾®è°ƒï¼Œ-220px æ¯”è¾ƒåˆé€‚) */
            transform: translateX(-220px); 
            
            width: 140px;
            display: flex;
            
            /* 3. æ ¸å¿ƒï¼šåå‘æ’åˆ—ï¼Œè®©ç¬¬ä¸€ä¸ªå…ƒç´ (å½“å‰å¼¹è¯)æ²‰åœ¨æœ€ä¸‹é¢ */
            flex-direction: column-reverse; 
            
            gap: 6px; 
            pointer-events: none;
            z-index: 40;
            
            /* 4. é å³å¯¹é½ (é å‘ç‚®å°ä¸€ä¾§) */
            align-items: flex-end; 
        }

        /* ç•¶å‰å½ˆè—¥å¡ç‰‡ */
        .recipe-card.current {
            background: rgba(30, 41, 59, 0.95);
            border: 1px solid #fbbf24;
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            opacity: 1;
        }

        /* éšŠåˆ—ä¸­çš„å½ˆè—¥å¡ç‰‡ */
        .recipe-card.queue {
            background: rgba(15, 23, 42, 0.6);
            border: 1px solid #475569;
            transform: scale(0.95);
            opacity: 0.6;
        }
        .mat-row { display: flex; align-items: center; margin-top: 2px; }
        
        /* Ammo Queue Dots */
        .ammo-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin: 0 2px;
            border: 1px solid #fff;
            opacity: 0.3;
            background: rgba(255,255,255,0.1);
        }
        .ammo-indicator.active { opacity: 1; box-shadow: 0 0 5px #fff; background: #fff; }
        /* --- é—ç‰©ç•Œé¢å®¹å™¨ --- */
        #phase-relic {
            /* å¼ºåˆ¶å¼€å¯é¼ æ ‡äº‹ä»¶ï¼Œè¦†ç›– .ui-overlay çš„ pointer-events: none */
            pointer-events: auto !important; 
            
            /* ç¡®ä¿å±‚çº§æœ€é«˜ï¼Œä¸è¢«å…¶ä»– UI é®æŒ¡ */
            z-index: 999 !important; 
            
            /* ä¹‹å‰çš„æ ·å¼ä¿æŒä¸å˜... */
            overflow-y: auto; 
            padding-top: max(20px, env(safe-area-inset-top));
            padding-bottom: max(20px, env(safe-area-inset-bottom));
            background: rgba(2, 6, 23, 0.95); /* ç¡®ä¿èƒŒæ™¯æœ‰é¢œè‰²ï¼Œé˜»æŒ¡è¯¯è§¦ä¸‹æ–¹ */
        }
        .ammo-stage {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            width: 100%;
            position: relative;
            padding: 10px 0;
        }

        .ammo-slot-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .ammo-label {
            font-size: 0.65rem;
            color: #94a3b8;
            margin-bottom: 4px;
            font-family: 'Cinzel', serif;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .ammo-icon {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            border: 2px solid #475569;
            background: rgba(15, 23, 42, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            transition: all 0.3s;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }

         /* ç®€å•çš„ Tab åˆ‡æ¢æ ·å¼ */
        .tab-btn.active {
            color: #fbbf24; /* amber-400 */
            border-bottom-color: #fbbf24;
        }
        .tab-btn:not(.active) {
            border-bottom-color: transparent;
        }
        .safe-area-pb {
            padding-bottom: env(safe-area-inset-bottom);
        }

        /* å½“å‰å‘å°„æ§½ä½ - é«˜äº® */
        #current-slot .ammo-icon {
            width: 64px;
            height: 64px;
            border-color: #fbbf24;
            background: radial-gradient(circle, rgba(50, 60, 90, 0.9) 0%, rgba(15, 23, 42, 0.9) 100%);
            box-shadow: 0 0 15px rgba(251, 191, 36, 0.2);
        }

        /* ä¸‹ä¸€å‘æ§½ä½ - ç¨å¾®æš—æ·¡ */
        #next-slot .ammo-icon {
            opacity: 0.7;
            transform: scale(0.9);
        }

        /* å‘å°„åŠ¨ç”»ï¼šå½“å‰å­å¼¹é£å‡º */
        .shoot-anim {
            animation: shootUp 0.4s forwards cubic-bezier(0.4, 0, 0.2, 1);
        }

        @keyframes shootUp {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            50% { transform: translateY(-30px) scale(1.2); opacity: 0.5; }
            100% { transform: translateY(-60px) scale(0.5); opacity: 0; }
        }

        /* è¿›ä½åŠ¨ç”»ï¼šä¸‹ä¸€å‘æ»‘åŠ¨å˜å¤§ */
        .slide-in-anim {
            animation: slideIn 0.4s forwards;
        }

        @keyframes slideIn {
            0% { transform: translateX(40px) scale(0.8); opacity: 0; }
            100% { transform: translateX(0) scale(1); opacity: 1; }
        }

        /* ä¹‹å‰æ—§çš„ queue æ ·å¼å¯ä»¥ä¿ç•™ä½œä¸ºå¤‡ç”¨ï¼Œæˆ–è€…éšè— */
        #ammo-queue { display: none; }
        #relic-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: stretch; /* è®©å¡ç‰‡é«˜åº¦ä¸€è‡´ */
            gap: 12px; /* å‡å°é—´è· */
            width: 100%;
            max-width: 900px;
            margin-bottom: 20px;
        }
        .recipe-multicast-badge {
            position: absolute;
            bottom: -5px;
            right: -5px;
            width: 24px;
            height: 24px;
            background-color: #f97316; /* Orange-500 */
            border: 2px solid #fff;
            border-radius: 50%;
            color: white;
            font-family: 'Cinzel', serif;
            font-weight: bold;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
            z-index: 10;
            
            /* é»˜èªéš±è— (ç¸®å°åˆ°0) */
            transform: scale(0); 
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        .recipe-multicast-badge.visible {
            transform: scale(1);
        }
        /* --- [æ–°å¢] é€£å°„å€ç‡ç‰¹æ•ˆ --- */
        .flying-badge {
            position: fixed; /* ä½¿ç”¨ fixed ä»¥ä¾¿è·¨å®¹å™¨å®šä½ */
            z-index: 9999;
            pointer-events: none;
            font-family: 'Cinzel', serif;
            font-weight: bold;
            color: #ffedd5; /* Orange-100 */
            background: rgba(249, 115, 22, 0.9); /* Orange-500 */
            border: 2px solid #fff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 15px #f97316;
            transition: all 0.6s cubic-bezier(0.16, 1, 0.3, 1); /* å¹³æ»‘é£›è¡Œæ›²ç·š */
        }
        /* æ¿€æ´»ç‹€æ…‹ï¼šé¡¯ç¤ºå‡ºä¾† */
        .multicast-visible {
            opacity: 1 !important;
            transform: scale(1) !important;
        }
        /* åˆ°é”ç›®æ¨™æ™‚çš„æ¶ˆå¤±ç‹€æ…‹ */
        .flying-badge.arrived {
            transform: scale(0.5);
            opacity: 0;
        }
        /* ç²å¾—åŠ æˆæ™‚çš„å¼·åŠ›å½ˆè·³ */
        @keyframes multicastPopAnim {
            0% { transform: scale(1); }
            40% { transform: scale(1.8) rotate(10deg); filter: brightness(1.5); }
            80% { transform: scale(0.9); }
            100% { transform: scale(1) rotate(0); }
        }
        .multicast-pop {
            animation: multicastPopAnim 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        /* æ•¸å€¼è®ŠåŒ–æ™‚çš„é¡è‰²é–ƒå…‰ */
        .multicast-flash {
            color: #fff !important;
            text-shadow: 0 0 10px #fff, 0 0 20px #fbbf24 !important;
        }
        /* --- å¡ç‰‡æ ·å¼ä¼˜åŒ– (æ›´ç´§å‡‘) --- */
        .relic-card {
            pointer-events: auto;
            cursor: pointer;
            background: linear-gradient(180deg, rgba(30, 41, 59, 0.95) 0%, rgba(15, 23, 42, 0.98) 100%);
            border: 1px solid #475569;
            border-radius: 12px;
            padding: 12px; /* å‡å°å†…è¾¹è· (åŸ20px) */
            
            /* ä½¿ç”¨ç›¸å¯¹å®½åº¦ï¼Œé€‚é…ç§»åŠ¨ç«¯ */
            width: 30%; 
            min-width: 130px; 
            max-width: 200px;
            
            min-height: 160px; /* å‡å°æœ€å°é«˜åº¦ (åŸ240px) */
            
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .relic-card:hover {
            transform: translateY(-4px) scale(1.02);
            z-index: 10;
        }

        .relic-icon {
            font-size: 2.2rem; /* ç¼©å°å›¾æ ‡ (åŸ3rem) */
            margin-bottom: 0.5rem;
            filter: drop-shadow(0 0 8px rgba(255,255,255,0.3));
        }

        .relic-name {
            font-family: 'Cinzel', serif;
            font-weight: bold;
            color: #e2e8f0;
            margin-bottom: 0.25rem;
            font-size: 0.95rem; /* ç¼©å°å­—ä½“ */
            line-height: 1.2;
        }

        .relic-desc {
            font-size: 0.75rem; /* ç¼©å°æè¿°å­—ä½“ */
            color: #94a3b8;
            line-height: 1.3;
            
            /* é˜²æ­¢æè¿°æ–‡å­—å¤ªé•¿å¯¼è‡´æº¢å‡ºï¼Œè¶…è¿‡4è¡Œæ˜¾ç¤ºçœç•¥å· */
            display: -webkit-box;
            -webkit-line-clamp: 4;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        /* ç¨€æœ‰åº¦å…‰æ•ˆ */
        .relic-card.rare { border-color: #3b82f6; } /* è“è‰² */
        .relic-card.rare:hover { box-shadow: 0 10px 30px -10px rgba(59, 130, 246, 0.3); }

        .relic-card.legendary { border-color: #facc15; } /* é‡‘è‰² */
        .relic-card.legendary:hover { box-shadow: 0 10px 30px -10px rgba(250, 204, 21, 0.5); }

        .relic-card.cursed { border-color: #ef4444; } /* çº¢è‰² */
        .relic-card.cursed:hover { box-shadow: 0 10px 30px -10px rgba(239, 68, 68, 0.4); }
         /* --- é’ˆå¯¹ç§»åŠ¨ç«¯æ¨ªå±/çŸ®å±å¹•çš„ç»ˆæé€‚é… --- */
        @media (max-height: 600px) {
                .select-card {
                    height: 90px; /* çŸ®å±æ¨¡å¼ä¸‹å¡ç‰‡å˜çŸ® */
                }
                .select-icon {
                    width: 32px; height: 32px; margin-bottom: 2px;
                }
                #phase-selection p {
                    margin-bottom: 4px; /* å‹ç¼©æ–‡å­—é—´è· */
                }
            }
            .relic-icon { font-size: 1.8rem; margin-bottom: 2px; }
            .relic-name { font-size: 0.85rem; }
            .relic-desc { -webkit-line-clamp: 3; } /* æ¨ªå±åªæ˜¾ç¤º3è¡Œ */
            
            /* è°ƒæ•´æ”¾å¼ƒæŒ‰é’®çš„ä½ç½® */
           #phase-relic button {
            pointer-events: auto;
            cursor: pointer;
            position: relative; /* æå‡å±‚çº§ä¸Šä¸‹æ–‡ */
            z-index: 1000;
        }
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <!-- Phase Title Animation -->
    <div id="phase-title-container">
        <div id="phase-title" class="phase-text">å›è²ç…‰é‡‘å¸«</div>
        <div id="phase-sub" class="phase-sub">é»æ“Šé–‹å§‹</div>
    </div>

    <!-- Top Bar -->
    <div class="top-bar">
        <div class="stat-pill">R <span id="round-num" class="stat-highlight">1</span></div>
        <div class="stat-pill">Score <span id="score-num" class="stat-highlight">0</span></div>
        <button id="speed-btn" class="btn-icon">â©</button>
        <button id="mute-btn" class="btn-icon">ğŸ”Š</button>
    </div>

    <div id="sp-panel" class="absolute top-16 left-4 flex flex-wrap gap-3 pointer-events-none z-50 transition-opacity duration-300">
    </div>

    <div id="toast"></div>


    <!-- Phase 0: Selection -->
    <div id="phase-selection" class="ui-overlay active-phase" style="display: flex;">
    
        <div class="flex-1 w-full min-h-0 overflow-y-auto flex flex-col items-center py-4">
            <div id="marble-selection-grid" class="marble-grid"></div>
            <div class="h-4 shrink-0"></div> 
        </div>

        <div class="w-full flex flex-col items-center pointer-events-auto shrink-0 z-10 bg-slate-900/80 backdrop-blur-sm border-t border-slate-700/50 pt-4 pb-6" 
             style="padding-bottom: max(24px, env(safe-area-inset-bottom));">
            
            <p class="text-sm text-slate-400 mb-3">å·²é¸æ“‡: <span id="selected-count" class="text-white font-bold">0</span> / 3</p>
            <button id="confirm-selection-btn" class="btn-main" disabled>é–‹å§‹ç…‰é‡‘</button>
        </div>

    </div>

    <!-- Phase 1: Gathering -->
    <div id="phase-gathering" class="ui-overlay" style="display: none;">
        <div class="absolute top-24 w-full text-center pointer-events-none">
            <p class="text-xs text-cyan-100/40">é»æ“Šä¸Šæ–¹å€åŸŸé‡‹æ”¾</p>
        </div>

        <div id="hero-gauge-container" class="absolute left-1/2 -translate-x-1/2 flex flex-col items-center justify-center pointer-events-none transition-all duration-300">
            <div class="text-[10px] text-cyan-200 tracking-widest mb-1 opacity-80 font-bold" style="text-shadow: 0 0 10px #06b6d4;">
                COMBO CHARGE
            </div>
            <div id="multicast-ui" class="absolute left-[110%] bottom-0 flex flex-col items-center justify-center transition-all duration-300 opacity-0 scale-50">
                <div class="text-[9px] text-orange-300 font-bold tracking-wider mb-1 whitespace-nowrap">SHOTS</div>
                <div class="relative flex items-center justify-center w-12 h-12">
                    <div class="absolute inset-0 bg-orange-500/20 rounded-full blur-md animate-pulse"></div>
                    <div class="absolute inset-0 border-2 border-orange-400 rounded-full opacity-80"></div>
                    <span id="multicast-num" class="relative text-2xl font-[Cinzel] font-bold text-orange-100 drop-shadow-[0_0_5px_#f97316]">x1</span>
                </div>
            </div>
            <div id="gauge-shell" class="relative w-48 h-5 bg-slate-900/90 rounded-full border border-slate-600/50 backdrop-blur-md shadow-lg">
                
                <div id="gauge-pulse-layer"></div>

                <div id="hit-bar"></div>
                
                <div class="absolute inset-0 flex items-center justify-center z-10">
                    <span id="hit-text" class="text-[10px] font-bold text-white drop-shadow-md tracking-wider">0/5</span>
                </div>
            </div>
        </div>
        
        <div class="bottom-panel">
        <div class="flex items-center w-full h-full">
            <div class="queue-container" id="gathering-queue"></div>
            
            <div class="flex-1 min-w-0 h-full">
                <div id="gathering-hud-mount" class="recipe-scroll"></div>
            </div>
        </div>
    </div>
    </div>

    <!-- Phase 3: Combat -->
    <div id="phase-combat" class="ui-overlay" style="display: none;">
        <div id="skill-bar" class="absolute bottom-24 right-4 flex flex-col gap-3 pointer-events-auto z-50">
        </div>
        <div id="recipe-hud-container" class="absolute z-40 pointer-events-none"></div>
        <div class="text-center mt-4 pointer-events-none">
            <!-- Multiplier Display -->
            <div id="multiplier-display" class="mt-2 text-2xl font-bold text-yellow-400 opacity-0 transition-opacity drop-shadow-md">
                COMBO <span id="multiplier-val">x1.0</span>
            </div>
        </div>

        <div class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 pointer-events-none text-center w-full z-20 px-4" id="combat-message"></div>

        
 
    </div>

    <div id="phase-relic" class="ui-overlay hidden-phase" style="display: none; z-index: 200; background: rgba(2, 6, 23, 0.95);">
        <div class="flex flex-col items-center justify-center w-full h-full p-4">
            
            <div class="text-center mb-8">
                <h2 class="text-4xl font-bold text-amber-400 font-[Cinzel] mb-2 drop-shadow-lg">å¤ä»£éºç‰©</h2>
                <p class="text-slate-400 text-sm">å‘½é‹çš„é¥‹è´ˆï¼Œé¸æ“‡ä¸€ç¨®åŠ›é‡</p>
            </div>

            <div id="relic-container" class="flex flex-wrap justify-center gap-4 w-full max-w-4xl">
                </div>

            <button onclick="game.skipRelic()" class="mt-12 text-slate-500 hover:text-slate-300 text-sm underline cursor-pointer transition-colors">
                æ”¾æ£„ä¸¦ç²å¾— 500 åˆ†
            </button>
        </div>
    </div>
    <div id="info-drawer" class="absolute bottom-0 left-0 w-full bg-slate-900/95 backdrop-blur-md border-t border-slate-600 text-slate-200 transform transition-transform duration-300 translate-y-full z-50 flex flex-col h-64 safe-area-pb">
    
        <button onclick="game.ui.closeDrawer()" class="absolute top-2 right-2 text-slate-400 hover:text-white p-2">âœ•</button>

        <div class="flex border-b border-slate-700 bg-slate-900/50">
            <button class="flex-1 py-3 text-sm font-bold text-amber-400 border-b-2 border-amber-400 tab-btn transition-colors" onclick="game.ui.switchTab('status')">æ•µäººç‹€æ…‹</button>
            <button class="flex-1 py-3 text-sm font-bold text-slate-400 hover:text-slate-200 tab-btn transition-colors" onclick="game.ui.switchTab('affix')">ç‰¹æ®Šè©æ¢</button>
            <button class="flex-1 py-3 text-sm font-bold text-slate-400 hover:text-slate-200 tab-btn transition-colors" onclick="game.ui.switchTab('recipe')">é…æ–¹åœ–é‘‘</button>
        </div>

        <div class="flex-1 overflow-y-auto p-4 relative">
            
            <div id="tab-status" class="tab-content h-full space-y-3">
                <div class="flex items-center justify-between">
                    <span class="text-lg font-bold" id="info-enemy-type">æ™®é€šé­”åƒ</span>
                    <span class="text-xs bg-slate-700 px-2 py-1 rounded" id="info-hp">HP: 100/100</span>
                </div>
                
                <div class="w-full bg-slate-700 h-2 rounded-full overflow-hidden relative mt-1">
                    <div id="info-temp-bar" class="h-full bg-orange-500 absolute transition-all" style="width: 0%; left: 50%;"></div>
                    <div class="absolute top-0 bottom-0 w-0.5 bg-white/50 left-1/2"></div> </div>
                <p id="info-temp-text" class="text-xs text-center text-slate-400 mt-1">æº«åº¦: 0Â°C</p>

                <div id="info-status-list" class="space-y-2 text-xs text-slate-300 mt-2">
                    </div>
            </div>

            <div id="tab-affix" class="tab-content hidden h-full space-y-2 overflow-y-auto">
                <div id="info-affix-list" class="space-y-2">
                    <p class="text-slate-500 text-center italic mt-4">è©²æ•µäººç„¡ç‰¹æ®Šè©æ¢</p>
                </div>
            </div>

            <div id="tab-recipe" class="tab-content hidden h-full overflow-y-auto text-xs space-y-3">
                <div class="grid grid-cols-2 gap-2">
                    <div class="bg-slate-800 p-2 rounded border border-slate-700">
                        <div class="text-green-400 font-bold mb-1">â¤´ï¸ å½ˆæ€§ (Bounce)</div>
                        <div class="text-slate-400">åœ¨æ•µäººä¹‹é–“å½ˆå°„ï¼Œå¢åŠ å‘½ä¸­æ¬¡æ•¸ã€‚</div>
                    </div>
                    <div class="bg-slate-800 p-2 rounded border border-slate-700">
                        <div class="text-red-400 font-bold mb-1">â†—ï¸ ç©¿é€ (Pierce)</div>
                        <div class="text-slate-400">ç©¿é€æ•µäººï¼Œå°å¾Œæ’é€ æˆå‚·å®³ã€‚</div>
                    </div>
                    <div class="bg-slate-800 p-2 rounded border border-slate-700">
                        <div class="text-yellow-400 font-bold mb-1">ğŸ”± æ•£å°„ (Scatter)</div>
                        <div class="text-slate-400">åˆ†è£‚å‡ºé¡å¤–å­å½ˆï¼Œæ“´å¤§æ‰“æ“Šé¢ã€‚</div>
                    </div>
                    <div class="bg-slate-800 p-2 rounded border border-slate-700">
                        <div class="text-cyan-400 font-bold mb-1">â„ï¸ å†°éœœ (Cryo)</div>
                        <div class="text-slate-400">é™ä½æº«åº¦ã€‚æ¥µå¯’å¯å‡çµæ•µäºº(ç„¡æ³•è¡Œå‹•)ã€‚</div>
                    </div>
                    <div class="bg-slate-800 p-2 rounded border border-slate-700">
                        <div class="text-orange-400 font-bold mb-1">ğŸ”¥ ç«ç„° (Pyro)</div>
                        <div class="text-slate-400">å‡é«˜æº«åº¦ã€‚éç†±é€ æˆæŒçºŒå‚·å®³èˆ‡ç‡ƒç‡’æ“´æ•£ã€‚</div>
                    </div>
                    <div class="bg-slate-800 p-2 rounded border border-slate-700">
                        <div class="text-purple-400 font-bold mb-1">âš¡ é–ƒé›» (Lightning)</div>
                        <div class="text-slate-400">å°æœ€è¿‘æ•µäººé€ æˆé€£é–å‚·å®³ã€‚</div>
                    </div>
                     <div class="bg-slate-800 p-2 rounded border border-slate-700">
                        <div class="text-sky-400 font-bold mb-1">ğŸ”¦ å…‰çƒ (Laser)</div>
                        <div class="text-slate-400">ç¬æ™‚å°„ç·šï¼Œæ ¹æ“šåå°„é¢é€²è¡ŒæŠ˜å°„ã€‚</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

</div>

<script>
// --- CONFIG ---
/**
 * æ¸¸æˆé…ç½®å¯¹è±¡
 */
const CONFIG = {
    /** é¢œè‰²é…ç½® (ä¿æŒä¸å˜) */
    colors: {
        laser: '#0ea5e9', // å¤©è“è‰²
        bg: '#0f172a',
        peg: '#475569',
        pegActive: '#cbd5e1',
        pegPink: '#f472b6',
        matBase: '#3b82f6',
        matBounce: '#22c55e',
        matPierce: '#ef4444',
        matScatter: '#facc15',
        matDamage: '#a855f7',
        matCryo: '#06b6d4',
        matPyro: '#f97316',
        matLightning: '#c084fc',
        marbleWhite: '#f8fafc',
        matMatryoshka: '#d946ef',
        marbleRedStripe: '#fca5a5',
        marbleRainbow: 'linear-gradient(135deg, #fca5a5, #facc15, #4ade80, #60a5fa)',
        enemy: '#eeeeee',
        enemyHit: '#d8b4fe',
        enemyFrozen: '#06b6d4',
        enemyOverheat: '#f97316',
        enemyShield: '#3b82f6',
        slotRecall: '#a855f7',
        slotMulticast: '#f97316',
        slotSplit: '#3b82f6',
        // [æ–°å¢]
        slotGiant: '#ef4444', // ç´…è‰² (è®Šå¤§)
        slotSkill: '#10b981', // ç¶ è‰² (æŠ€èƒ½é»)
    },
    /** ç‰©ç†ä¸å°ºå¯¸é…ç½® */
    physics: { 
        gravity: 0.30,      // é‡åŠ›åŠ é€Ÿåº¦
        friction: 0.99,     // ç©ºæ°”é˜»åŠ›
        elasticity: 0.82,    // å¢™å£/é’‰å­åå¼¹ç³»æ•°
        marbleRadius: 7.7,   // ã€æ”¶é›†é˜¶æ®µã€‘å¼¹ç åŠå¾„ (åŸä¸º12)
        bulletRadius: 11,   // ã€æˆ˜æ–—é˜¶æ®µã€‘å¼¹ä¸¸åŠå¾„ (åŸä¸º11)
        bulletCopyRadius: 8, // ã€æˆ˜æ–—é˜¶æ®µã€‘å¤åˆ¶/æ•£å°„å¼¹ä¸¸åŠå¾„
        pinkpegElasticityMuti:2.2
    },
    /** æ¸¸æˆå¹³è¡¡æ€§ï¼šæ•Œäººä¸æ•°å€¼ */
    balance: {
        // æ•Œäººè¡€é‡ = baseHp + (å½“å‰å›åˆæ•° * hpPerRound)
        enemyBaseHp: 2,        
        enemyHpPerRound: 7,
        
        // ç‰¹æ®Šæ•Œäººè¡€é‡å€ç‡
        eliteHpMult: 12,     // ç²¾è‹±æ€ªæ˜¯æ™®é€šæ€ªçš„å¤šå°‘å€
        bossHpMult: 42,     // Bossæ˜¯æ™®é€šæ€ªçš„å¤šå°‘å€
        
        // æ•Œäººç”Ÿæˆæ¦‚ç‡
        spawnProb: 0.6,     // æ™®é€šæ ¼å­ç”Ÿæˆæ•Œäººçš„æ¦‚ç‡
        eliteChance: 0.15,   // (å›åˆ>2æ—¶) å°è¯•ç”Ÿæˆç²¾è‹±çš„æ¦‚ç‡
        bossChance: 0.05,    // (å›åˆ>5ä¸”è§¦å‘ç²¾è‹±æ—¶) å‡çº§ä¸ºBossçš„æ¦‚ç‡
        advanceWaveMuti:2, // 
        // è¯ç¼€æ¦‚ç‡
        affixBaseChance: 0.05, // åŸºç¡€è¯ç¼€æ¦‚ç‡
        affixRoundGrowth: 0.05, // æ¯å›åˆå¢åŠ çš„è¯ç¼€æ¦‚ç‡
        
        // ä¼¤å®³ç³»æ•°
        cloneSpawnRate: 0.2, // "åˆ†èº«"è¯ç¼€è§¦å‘æ¦‚ç‡
        shieldDmgReduct: 0.5, // "æŠ¤ç›¾"è¯ç¼€å—åˆ°çš„ä¼¤å®³å€ç‡ (0.8 = å‡ä¼¤20%)
        unusedAmmoScoreMult: 1.5,   // å‰©ä½™æ¯é¢—å­å¼¹è®©åˆ†æ•°ä¹˜å¤šå°‘ (å½“å‰æ˜¯ *2)
        nextRoundDifficultyMult: 12, // è§¦å‘æ­¤æœºåˆ¶åï¼Œä¸‹ä¸€è½®æ•Œäººè¡€é‡ä¹˜å¤šå°‘
        cryoAmount:1,
        pyroAmount:1,
        lightningTempIncrease:3,
        relicRarityWright:{
            'common': 60,    // æ™®é€š: æƒé‡ 60 (çº¦ 60%)
            'rare': 30,      // ç¨€æœ‰: æƒé‡ 30 (çº¦ 30%)
            'legendary': 10, // ä¼ è¯´: æƒé‡ 10 (çº¦ 10%)
            'cursed': 5     // è¯…å’’: æƒé‡ 10
        },
        affixes: {
            shieldReduction: 0.5,   // æŠ¤ç›¾å‡ä¼¤ 50%
            hasteActions: 2,        // æé€Ÿè¡ŒåŠ¨æ¬¡æ•°
            regenPercent: 0.1,      // å†ç”Ÿå›è¡€ç™¾åˆ†æ¯”
            cloneChanceHit: 0.2,    // å—å‡»åˆ†èº«æ¦‚ç‡
            cloneChanceTurn: 0.2,   // å›åˆå¼€å§‹åˆ†èº«æ¦‚ç‡
            berserkChanceMult: 0.5, // ç‹‚æš´æ¦‚ç‡ç³»æ•° (Temp * 0.5)
            healerPercent: 0.1,     // æ²»ç–—ç™¾åˆ†æ¯”
            healerRange: 1.5,       // æ²»ç–—èŒƒå›´ (è‡ªèº«å®½åº¦çš„å€æ•°)
            devourChance: 0.5,      // åå™¬è§¦å‘æ¦‚ç‡
            devourRange: 1.2,       // åå™¬èŒƒå›´
            jumpRows: 2             // è·³è·ƒè·ç¦» (è¡Œæ•°)
        }
    },
    /** æ¸¸æˆç©æ³•é…ç½® */
    gameplay: {    
        enemyShowTimeFrames:72,
        relicChoiceNum:4,
        enemyCols:6,
        cols: 10,           // ç½‘æ ¼åˆ—æ•° 
        rows: 6,           // é’‰å­è¡Œæ•°
        startRows: 4,       // åˆå§‹ç”Ÿæˆçš„æ•Œäººè¡Œæ•°
        spawnMin: 3,        // æ¯æ³¢æœ€å°‘ç”Ÿæˆçš„æ•Œäººæ•°é‡
        selectionCount: 6,  // é€‰å¡é˜¶æ®µæä¾›å¤šå°‘å¼ å¡
        selectionReq: 3,     // éœ€è¦é€‰æ‹©å¤šå°‘å¼ å¡
        hitCooldowns:42,
        relicChance:0.1,
        initTriggerThreshold:12,
        nextTriggerThresholdIncrease:5,
        spSlotsStartRow:3,
        spSlotsEndRow:8,
        fireSpreadDamagePercent:0.25,
        fireSpreadTempIncrease:50,
        fireSpreadRadius:100,
        //  å›ºå®šå›åˆé—ç‰©äº‹ä»¶ (æ¯å¤šå°‘å›åˆè§¦å‘ä¸€æ¬¡)
        relicRoundInterval: 3,
        assimilationChance: {
            bounce: 0.25, pierce: 0.1, scatter: 0.05, damage: 0.2,
            cryo: 0.2, pyro: 0.2
        }
    },
    //  åˆå§‹æ¦‚ç‡é…ç½® (ç¾åœ¨é€™äº›æ˜¯åŸºç¤æ¬Šé‡ï¼Œè§£é–å¾Œæœƒå¢åŠ )
    probabilities: { 
        white: 150,       // åŸºç¤
        bounce: 25,       // åˆå§‹è§£é–
        laser: 0,
        // ç‰©ç†ç³» (åˆå§‹é–å®šï¼Œé€šééºç‰©è§£é–)
        pierce: 1, 
        scatter: 1, 
        damage: 2,
        
        // å…ƒç´ ç³» (åˆå§‹é–å®šï¼Œé€šééºç‰©ç¨ç«‹è§£é–)
        cryo: 0, 
        pyro: 0, 
        
        // ç‰¹æ®Šç³» (åˆå§‹é–å®š)
        redStripe: 1, 
        rainbow: 0, 
        matryoshka: 0
    },
    /** è§†è§‰è¡¨ç°é…ç½® (æ–°å¢) */
    visuals: {
        baseRadius: 7,          // åŸºç¡€åŠå¾„ (åŸæ¥æ˜¯11ï¼Œæ”¹å°ä¸€ç‚¹æ›´ç²¾è‡´)
        
        // --- å°ºå¯¸åŠ¨æ€å½±å“ ---
        damageGrowth: 0.4,      // æ¯ 1 ç‚¹ä¼¤å®³å¢åŠ å¤šå°‘åŠå¾„åƒç´ 
        maxSizeBonus: 5,        // ä¼¤å®³å¯¼è‡´çš„åŠå¾„å¢åŠ ä¸Šé™ (é˜²æ­¢å­å¼¹æ— é™å˜å¤§)
        
        // --- ç±»å‹ç¼©æ”¾å€ç‡ ---
        copyScale: 0.6,         // å¤åˆ¶/æ•£å°„å­å¼¹çš„ç¼©æ”¾æ¯”ä¾‹ (0.6 = 60%å¤§å°)
        explosiveScale: 1.15,   // çˆ†ç‚¸å­å¼¹çš„æ”¾å¤§å€ç‡
        arrowScale: 0.9,        // ç©¿é€(ç®­å¤´)å½¢çŠ¶çš„è§†è§‰ä¿®æ­£ (ç®­å¤´æ˜¾å¤§ï¼Œç¨å¾®ç¼©ä¸€ç‚¹)
        
        // --- ç‰¹æ•ˆå¼ºåº¦ ---
        glowBase: 10,           // åŸºç¡€å…‰æ™•æ¨¡ç³Šåº¦
        glowPerDamage: 1.5,     // æ¯ç‚¹ä¼¤å®³å¢åŠ çš„å…‰æ™•
        maxGlow: 30             // æœ€å¤§å…‰æ™•é™åˆ¶
    }
};
const RELIC_DB = [
    { 
        id: 'dimension_shard', 
        name: 'ç¶­åº¦ç¢ç‰‡', 
        icon: 'ğŸŒŒ', 
        desc: 'æ”¶é›†éšæ®µï¼šé‡˜æ¿é«˜åº¦å»¶ä¼¸ï¼Œé¡å¤–å¢åŠ  2 è¡Œé‡˜å­ã€‚', 
        rarity: 'rare', 
        effect: 'row_count_up' ,maxStacks: 1
    },
    { id: 'unlock_giant', name: 'å·¨äººè—¥åŠ‘', icon: 'ğŸ’ª', desc: 'æ”¶é›†éšæ®µï¼šè§£é– [è®Šå¤§æ§½]ï¼Œå½ˆç å·¨å¤§åŒ–ä¸¦å¢åŠ ç¢°æ’é«”ç©ã€‚', rarity: 'common', effect: 'unlock_slot', slotType: 'giant' ,maxStacks: 1},
    { id: 'optical_lens', name: 'èšç„¦é€é¡', icon: 'ğŸ”­', desc: 'è§£é– [å…‰çƒ]ï¼šç™¼å°„ç¬é–“ç©¿é€çš„æŠ˜å°„å…‰æŸã€‚', rarity: 'legendary', unlocks: 'laser', boost: 10 ,maxStacks: 1},
    //  1. ç²‰è‰²é’‰å­é—ç‰©
    { id: 'pink_slime', name: 'ç²‰ç´…å‡è† ', icon: 'ğŸ’—', desc: 'æ”¶é›†éšæ®µï¼šå‡ºç¾ 3 å€‹é«˜å½ˆæ€§ç²‰è‰²é‡˜å­ (å¯ç–ŠåŠ )ã€‚', rarity: 'common', effect: 'pink_peg_up' ,maxStacks: 1},

    //  2. æˆ˜æ–—åº•éƒ¨åå¼¹å¢™
    { id: 'energy_shield', name: 'åŠ›å ´è­·ç›¾', icon: 'ğŸ›¡ï¸', desc: 'æˆ°é¬¥éšæ®µï¼šåº•éƒ¨é‚Šç•Œå¯æ¶ˆè€—å½ˆæ€§/ç©¿é€æ¬¡æ•¸ä¾†åå½ˆå­å½ˆã€‚', rarity: 'rare', effect: 'combat_wall' ,maxStacks: 1},

    //  3. ç‰¹æ®Šæ§½è§£é” (ä¸‰ç§æ§½ä½)
    { id: 'unlock_recall', name: 'æ™‚å…‰æ²™æ¼', icon: 'â³', desc: 'æ”¶é›†éšæ®µï¼šè§£é– [å›æº¯æ§½] çš„å‡ºç¾ (è‹¥ç„¡æ§½ä½å‰‡+1)ã€‚', rarity: 'rare', effect: 'unlock_slot', slotType: 'recall' ,maxStacks: 1},
    { id: 'unlock_multicast', name: 'é›™å­é­”é¡', icon: 'â™Š', desc: 'æ”¶é›†éšæ®µï¼šè§£é– [é€£å°„æ§½] çš„å‡ºç¾ (è‹¥ç„¡æ§½ä½å‰‡+1)ã€‚', rarity: 'rare', effect: 'unlock_slot', slotType: 'multicast' ,maxStacks: 1},
    { id: 'unlock_split', name: 'è£‚è®Šæ ¸å¿ƒ', icon: 'â˜¢ï¸', desc: 'æ”¶é›†éšæ®µï¼šè§£é– [åˆ†è£‚æ§½] çš„å‡ºç¾ (è‹¥ç„¡æ§½ä½å‰‡+1)ã€‚', rarity: 'rare', effect: 'unlock_slot', slotType: 'split' ,maxStacks: 1},

    //  4. å¢åŠ ç‰¹æ®Šæ§½æ•°é‡
    { id: 'slot_expander', name: 'ç©ºé–“é‘¿å­', icon: 'ğŸ”¨', desc: 'æ”¶é›†éšæ®µï¼šç‰¹æ®Šæ§½å‡ºç¾æ•¸é‡ +1ã€‚', rarity: 'common', effect: 'slot_count_up' ,maxStacks: 1},
    //  ç¨ç«‹å…ƒç´ éºç‰©
    { id: 'cryo_stone', name: 'æ°¸æ†å‡åœŸ', icon: 'â„ï¸', desc: 'è§£é– [å†°éœœ] å±¬æ€§ (å½ˆç èˆ‡é‡˜å­)ã€‚', rarity: 'rare', unlocks: 'cryo', boost: 15 ,maxStacks: 1},
    { id: 'pyro_stone', name: 'ä¸æ»…ç«ç¨®', icon: 'ğŸ”¥', desc: 'è§£é– [ç«ç„°] å±¬æ€§ (å½ˆç èˆ‡é‡˜å­)ã€‚', rarity: 'rare', unlocks: 'pyro', boost: 15 ,maxStacks: 1},
    // { id: 'lightning_stone', name: 'é›·éœ†ä¹‹æ€’', icon: 'âš¡', desc: 'è§£é– [é–ƒé›»] å±¬æ€§ (å½ˆç èˆ‡é‡˜å­)ã€‚', rarity: 'rare', unlocks: 'lightning', boost: 15 },
    
    //  ç‰©ç†å¥—è£éºç‰© (ä¸€æ¬¡è§£é–ä¸‰ç¨®ï¼Œæˆ–è€…ä½ å¯ä»¥æ‹†é–‹)
    { id: 'tactical_kit', name: 'ç©¿é€è£œçµ¦', icon: 'â†—', desc: 'è§£é– [ç©¿é€] å±¬æ€§ã€‚', rarity: 'common', unlocks: ['pierce'], boost: 5 ,maxStacks: 1},
    { id: 'tactical_kit', name: 'æ•£å°„è£œçµ¦', icon: 'ğŸ”±', desc: 'è§£é– [æ•£å°„] å±¬æ€§ã€‚', rarity: 'common', unlocks: ['scatter'], boost: 5 ,maxStacks: 1},
    { id: 'tactical_kit', name: 'å¢å¹…è£œçµ¦', icon: 'âš”ï¸', desc: 'è§£é– [å¢å¹…] å±¬æ€§ã€‚', rarity: 'common', unlocks: ['damage'], boost: 5 ,maxStacks: 1},

    { id: 'explosive_ammo', name: 'é«˜çˆ†ç«è—¥', icon: 'ğŸ§¨', desc: 'è§£é– [çˆ†ç ´å½ˆç ] å‡ºç¾ï¼Œä¸”ç²å¾—ä¸€é¡†ã€‚', rarity: 'rare', unlocks: 'redStripe', boost: 10 ,maxStacks: 1},
    { id: 'prism_shard', name: 'ä¸ƒå½©ç¨œé¡', icon: 'ğŸŒˆ', desc: 'è§£é– [å½©è™¹å½ˆç ] å‡ºç¾ï¼Œä¸”ç²å¾—ä¸€é¡†ã€‚', rarity: 'legendary', unlocks: 'rainbow', boost: 5 ,maxStacks: 1},
    { id: 'russian_doll', name: 'ä¿„ç¾…æ–¯å¥—å¨ƒ', icon: 'ğŸª†', desc: 'è§£é– [å¥—å¨ƒå½ˆç ]ï¼Œå­å½ˆæ¶ˆå¤±æ™‚æœƒç™¼å°„ä¸‹ä¸€é¡†å­å½ˆã€‚', rarity: 'legendary', unlocks: 'matryoshka', boost: 5 ,maxStacks: 1}
];
const SKILL_DB = [
    { 
        id: 'repulsion', 
        methodId: 'repulsion', // é€»è¾‘ID
        name: 'é‡åŠ›åè½‰', 
        icon: 'ğŸŒ¬ï¸', 
        cost: 2, 
        color: '#60a5fa',
        desc: 'å°‡æ‰€æœ‰æ•µäººå¼·åˆ¶å‘ä¸Šæ¨å› 2 è¡Œã€‚',
        params: {
            pushRows: 2,
            visualShake: -20,
            particleColor: '#60a5fa',
            shockwaveColor: '#60a5fa'
        }
    },
    { 
        id: 'storm', 
        methodId: 'chain_lightning_all', // é€»è¾‘IDï¼šå…¨å±é—ªç”µé“¾
        name: 'ä»¥å¤ªé¢¨æš´', 
        icon: 'âš¡', 
        cost: 3, 
        color: '#c084fc',
        desc: 'å¬å–šé›·æ“Šå‘½ä¸­æ‰€æœ‰æ•µäººï¼Œä¸¦è§¸ç™¼é€£é–é–ƒé›»ã€‚',
        params: {
            baseDmg: 10,
            roundMult: 5,
            // é—ªç”µç›¸å…³å‚æ•°
            boltColor: '#c084fc', // é—ªç”µé¢œè‰²
            flashColor: 'rgba(192, 132, 252, 0.2)'
        }
    },
    { 
        id: 'enhance_normal', // æŠ€èƒ½IDï¼šæ™®é€šå¼ºåŒ–
        methodId: 'enhance_ammo', // é€»è¾‘IDï¼šå¼ºåŒ–é€»è¾‘
        name: 'è³¢è€…å……èƒ½', 
        icon: 'ğŸ’', 
        cost: 2, 
        color: '#facc15',
        desc: 'ä¸‹ä¸€ç™¼å­å½ˆå¼·åŒ–ï¼šæ•£å°„ã€é€£å°„èˆ‡å…¨å±¬æ€§æå‡ã€‚',
        params: {
            buffs: {
                damage: 5,
                bounce: 3,
                pierce: 2,
                multicast: 1,
                scatter: 4 
            },
            forceExplosive: true,
            forceLaser: false, // [æ–°å¢] æ˜¯å¦å¼€å¯å…‰å±æ€§
            explosionColor: '#facc15',
            floatText: "ENHANCED!"
        }
    },
    { 
        id: 'enhance_laser', 
        methodId: 'enhance_ammo', 
        name: 'å…‰ä¹‹å……èƒ½', 
        icon: 'ğŸ”¦', 
        cost: 1, 
        color: '#0ea5e9', 
        desc: 'ä¸‹ä¸€ç™¼å­å½ˆè½‰åŒ–ç‚ºé«˜èƒ½æ¿€å…‰ã€‚',
        params: {
            buffs: { 
                damage: 5,
                pierce: 8,
                multicast: 2,
                laser: 5
             }, // åŠ æ¿€å…‰å±‚æ•°
            forceLaser: true, // [æ–°å¢] å¼ºåˆ¶å¼€å¯æ¿€å…‰
            forceExplosive: false,
            explosionColor: '#0ea5e9',
            floatText: "LASER READY!"
        }
    }
];


// --- å£°éŸ³ç®¡ç†å™¨ ---
class SoundManager {
    /**
     * å£°éŸ³ç®¡ç†å™¨ç±»ï¼Œä½¿ç”¨ Web Audio API æ’­æ”¾éŸ³æ•ˆ
     */
    constructor() {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.muted = false;

        // 1. åˆ›å»ºä¸»éŸ³é‡èŠ‚ç‚¹
        this.masterGain = this.ctx.createGain();
        this.masterGain.gain.value = 0.3; 

        // 2.  åˆ›å»ºåŠ¨æ€å‹ç¼©å™¨ (é˜²æ­¢çˆ†éŸ³çš„æ ¸å¿ƒ)
        this.compressor = this.ctx.createDynamicsCompressor();
        // å‹ç¼©å™¨å‚æ•°è°ƒä¼˜ (é€‚åˆå¿«èŠ‚å¥æ¸¸æˆ)
        this.compressor.threshold.setValueAtTime(-24, this.ctx.currentTime); // è¶…è¿‡-24dBå¼€å§‹å‹ç¼©
        this.compressor.knee.setValueAtTime(30, this.ctx.currentTime);       // å¹³æ»‘è¿‡æ¸¡
        this.compressor.ratio.setValueAtTime(12, this.ctx.currentTime);      // å‹ç¼©æ¯”ç‡ (é«˜ä¸€ç‚¹é˜²æ­¢æå“)
        this.compressor.attack.setValueAtTime(0.003, this.ctx.currentTime);  // å¿«é€Ÿå“åº”
        this.compressor.release.setValueAtTime(0.25, this.ctx.currentTime);  // å¿«é€Ÿé‡Šæ”¾

        // 3.  è¿æ¥é“¾è·¯ï¼š èŠ‚ç‚¹ -> Master -> Compressor -> æ‰¬å£°å™¨
        this.masterGain.connect(this.compressor);
        this.compressor.connect(this.ctx.destination);

        this.noiseBuffer = this.createNoiseBuffer();
        
        //  ç”¨äºé˜²æŠ–åŠ¨çš„è®°å½•è¡¨ (æ–¹æ³•äºŒç”¨åˆ°)
        this.lastPlayTime = {}; 
    }
    createNoiseBuffer() {
        const bufferSize = this.ctx.sampleRate * 2; // 2ç§’ç·©è¡
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
        }
        return buffer;
    }
    createRollingSound() {
        if (this.muted) return null;

        const source = this.ctx.createBufferSource();
        source.buffer = this.noiseBuffer;
        source.loop = true;

        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.Q.value = 1.0; 

        const gainNode = this.ctx.createGain();
        gainNode.gain.value = 0; 

        source.connect(filter);
        filter.connect(gainNode);
        gainNode.connect(this.masterGain);

        source.start();

        return {
            node: source,
            gainNode: gainNode,
            filter: filter,
            ctx: this.ctx,
            
            // æ ¸å¿ƒï¼šæ ¹æ®é€Ÿåº¦æ›´æ–°å£°éŸ³
            update: function(speed) {
                // é™åˆ¶æœ€å¤§é€Ÿåº¦å½±å“
                const clampSpeed = Math.min(Math.max(speed, 0), 25);
                const normalizedSpeed = clampSpeed / 25; 

                const now = this.ctx.currentTime;

                // --- ï¼šå¤§å¹…æå‡æ»šåŠ¨éŸ³é‡ ---
                // åŸæ¥æ˜¯ 0.4ï¼Œç°åœ¨æå‡åˆ° 2.5ï¼Œä¿è¯èƒ½å¬å¾—æ¸…
                // ä½¿ç”¨å¹³æ–¹æ›²çº¿ (normalizedSpeed^2) è®©é«˜é€Ÿæ—¶å£°éŸ³å¢åŠ å¾—æ›´æ˜æ˜¾ï¼Œä½é€Ÿä¿æŒå®‰é™
                const targetVol = Math.pow(normalizedSpeed, 1.5) * 2.5; 
                this.gainNode.gain.setTargetAtTime(targetVol, now, 0.1);

                // é¢‘ç‡éšé€Ÿåº¦å˜åŒ–ï¼Œé«˜é€Ÿæ—¶æ›´è„†
                const targetFreq = 100 + (normalizedSpeed * 800);
                this.filter.frequency.setTargetAtTime(targetFreq, now, 0.1);
            },

            stop: function() {
                const now = this.ctx.currentTime;
                this.gainNode.gain.setTargetAtTime(0, now, 0.2);
                setTimeout(() => {
                    try { source.stop(); source.disconnect(); } catch(e){}
                }, 300);
            }
        };
    }
    /**
     * åˆ‡æ¢é™éŸ³çŠ¶æ€
     * @returns {boolean} å½“å‰é™éŸ³çŠ¶æ€
     */
    toggleMute() {
        this.muted = !this.muted;
        this.masterGain.gain.value = this.muted ? 0 : 0.3;
        
        //  å¦‚æœé™éŸ³äº†ï¼Œå¼ºåˆ¶æš‚åœæ‰€æœ‰ AudioContext (å› ä¸ºæ»šåŠ¨å£°æ˜¯ç‹¬ç«‹èŠ‚ç‚¹çš„)
        if (this.muted) {
            if (this.ctx.state === 'running') this.ctx.suspend();
        } else {
            if (this.ctx.state === 'suspended') this.ctx.resume();
        }
        return this.muted;
    }

    /**
     * æ¢å¤ AudioContext (è§£å†³æµè§ˆå™¨è‡ªåŠ¨æ’­æ”¾é™åˆ¶)
     */
    resume() { if (this.ctx.state === 'suspended') this.ctx.resume(); }
    /**
     * æ’­æ”¾é€šç”¨æ¸¸æˆç‰¹æ•ˆéŸ³
     * @param {string} type - 'burn_tick', 'freeze', 'regen', 'split', 'ignite'
     */
 playEffect(type) {
        if (this.muted) return;
        const now = this.ctx.currentTime;

        if (type === 'burn_tick') {
            // ğŸ”¥ ç‡ƒçƒ§ç»“ç®—ï¼šé‡åšä¸º "çƒˆç«å‡è…¾" (Fwoosh + Crackle)
            // ä¹‹å‰çš„ç‰ˆæœ¬å¤ªåƒæ¼æ°”äº†ï¼Œè¿™ä¸ªç‰ˆæœ¬å¼ºè°ƒç«ç„°çš„"åå™¬æ„Ÿ"
            
            // --- Layer 1: ç«ç„°çš„ä¸»ä½“ (The Body/Whoosh) ---
            // ä½¿ç”¨ä½é€šæ»¤æ³¢åçš„å™ªéŸ³ï¼Œæ¨¡æ‹Ÿçƒ­ç©ºæ°”è†¨èƒ€
            const noise = this.ctx.createBufferSource();
            noise.buffer = this.noiseBuffer;
            
            const filter = this.ctx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.Q.value = 1; // å¢åŠ ä¸€ç‚¹å…±æŒ¯ï¼Œè®©ç«å£°æ›´æœ‰åŠ›
            
            // å…³é”®ï¼šé¢‘ç‡åŠ¨æ€æ‰«æ
            // ä»ä¸­é¢‘(1500Hz) å¿«é€Ÿæ»‘è½åˆ° ä½é¢‘(100Hz)
            // æ¨¡æ‹Ÿç«è‹—ç¬é—´çªœèµ·åˆå¹³æ¯çš„è¿‡ç¨‹ ("Fwump")
            filter.frequency.setValueAtTime(1500, now);
            filter.frequency.exponentialRampToValueAtTime(100, now + 0.2);
            
            const gain = this.ctx.createGain();
            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(0.5, now + 0.02); // å¿«é€Ÿèµ·éŸ³
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.25); // ç¨å¾®é•¿ä¸€ç‚¹çš„å°¾éŸµ

            noise.connect(filter);
            filter.connect(gain);
            gain.connect(this.masterGain);
            noise.start(now);
            noise.stop(now + 0.3);

            // --- Layer 2: çˆ†è£‚æ‚éŸ³ (The Crackle) ---
            // æçŸ­çš„é«˜é€šå™ªéŸ³ï¼Œæ¨¡æ‹Ÿæœ¨ææˆ–ç‡ƒæ–™çš„çˆ†è£‚å£°
            const crackle = this.ctx.createBufferSource();
            crackle.buffer = this.noiseBuffer;
            
            const cFilter = this.ctx.createBiquadFilter();
            cFilter.type = 'highpass';
            cFilter.frequency.setValueAtTime(3000, now); // åªç•™é«˜é¢‘ç»†èŠ‚
            
            const cGain = this.ctx.createGain();
            // éšæœºåŒ–éŸ³é‡ï¼Œè®©æ¯æ¬¡ç‡ƒçƒ§å¬èµ·æ¥ä¸ä¸€æ ·
            cGain.gain.setValueAtTime(0.1 + Math.random() * 0.1, now); 
            cGain.gain.exponentialRampToValueAtTime(0.01, now + 0.1); // æçŸ­ï¼Œåƒç«èŠ±

            crackle.connect(cFilter);
            cFilter.connect(cGain);
            cGain.connect(this.masterGain);
            crackle.start(now);
            crackle.stop(now + 0.15);
        } else if (type === 'ignite') {
             // ğŸ”¥ ç‚¹ç‡ƒç¬é—´ï¼šæ›´çŒ›çƒˆçš„æ°”ä½“çˆ†ç‡ƒå£° (Ignition)
             const noise = this.ctx.createBufferSource();
             noise.buffer = this.noiseBuffer;
             
             // ä½¿ç”¨å¸¦é€šæ»¤æ³¢å™¨ (Bandpass) æ¨¡æ‹Ÿä»ä¸­å¿ƒå‘å¤–çˆ†å‘çš„å£°éŸ³
             const filter = this.ctx.createBiquadFilter();
             filter.type = 'bandpass';
             filter.Q.value = 0.5; // å®½é¢‘å¸¦
             
             // é¢‘ç‡å‘ä¸Šæ‰«ï¼Œæ¨¡æ‹Ÿç«åŠ¿å˜å¤§ ("Vwooom")
             filter.frequency.setValueAtTime(200, now);
             filter.frequency.exponentialRampToValueAtTime(1200, now + 0.3);
             
             const gain = this.ctx.createGain();
             gain.gain.setValueAtTime(0.4, now);
             gain.gain.linearRampToValueAtTime(0, now + 0.4);
 
             noise.connect(filter);
             filter.connect(gain);
             gain.connect(this.masterGain);
             noise.start(now);
             noise.stop(now + 0.5);
        }
        else if (type === 'freeze') {
            // â„ï¸ å†»ç»“ï¼šæ™¶ä½“æé€Ÿç”Ÿé•¿ (Arpeggio / Granular)
            // æ’­æ”¾ä¸€ä¸²å¿«é€Ÿã€éšæœºçš„é«˜é¢‘çŸ­éŸ³
            const count = 5; // é¢—ç²’æ•°é‡
            for (let i = 0; i < count; i++) {
                const t = now + i * 0.03; // é—´éš”æçŸ­ (30ms)
                
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                osc.type = 'sine';
                // é¢‘ç‡åœ¨ 2000Hz ~ 4500Hz ä¹‹é—´éšæœºï¼Œä¸”éšæ—¶é—´è¶Šæ¥è¶Šé«˜ (ç»“å†°é€šå¸¸æ˜¯å‘ä¸Šè”“å»¶)
                const freq = 2000 + (Math.random() * 1000) + (i * 500);
                osc.frequency.setValueAtTime(freq, t);
                
                gain.gain.setValueAtTime(0, t);
                gain.gain.linearRampToValueAtTime(0.15, t + 0.01);
                gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
                
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.start(t);
                osc.stop(t + 0.15);
            }
            
            // åº•å±‚çš„é£å£°/å¯’æ°” (White Noise Sweep)
            const noise = this.ctx.createBufferSource();
            noise.buffer = this.noiseBuffer;
            const filter = this.ctx.createBiquadFilter();
            filter.type = 'highpass';
            filter.frequency.setValueAtTime(1000, now);
            filter.frequency.linearRampToValueAtTime(4000, now + 0.3); // æ»¤æ³¢å™¨å‘ä¸Šæ‰«
            
            const nGain = this.ctx.createGain();
            nGain.gain.setValueAtTime(0.2, now);
            nGain.gain.linearRampToValueAtTime(0, now + 0.3);
            
            noise.connect(filter);
            filter.connect(nGain);
            nGain.connect(this.masterGain);
            noise.start(now);
            noise.stop(now + 0.3);
        }
        else if (type === 'regen') {
            // ğŸ’š æ¢å¤ï¼šæŸ”å’Œçš„åŒéŸ³ä¸Šå‡ (Magical Chime)
            [400, 600].forEach((freq, i) => {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sine';
                
                // é¢‘ç‡ç¼“æ…¢ä¸Šå‡
                osc.frequency.setValueAtTime(freq, now);
                osc.frequency.linearRampToValueAtTime(freq + 200, now + 0.5);

                // ç¼“æ…¢æ·¡å…¥æ·¡å‡º
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(0.1, now + 0.1);
                gain.gain.linearRampToValueAtTime(0, now + 0.6);

                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.start(now);
                osc.stop(now + 0.7);
            });
        }
        else if (type === 'split') {
            // ğŸ¦  åˆ†è£‚ï¼šç±»ä¼¼æ°´æ³¡ç ´è£‚çš„å£°éŸ³ (Squishy Pop)
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            
            // ä½¿ç”¨é”¯é½¿æ³¢ç»è¿‡ä½é€šæ»¤æ³¢ï¼Œæ¨¡æ‹Ÿç²˜ç¨ æ„Ÿ
            osc.type = 'sawtooth';
            // é¢‘ç‡å¿«é€Ÿå‘ä¸Šæ»‘åŠ¨ä¸€ä¸‹
            osc.frequency.setValueAtTime(200, now);
            osc.frequency.linearRampToValueAtTime(400, now + 0.1);

            const filter = this.ctx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(300, now);
            filter.Q.value = 5; // å¢åŠ å…±æŒ¯ï¼Œåˆ¶é€ â€œå•µâ€çš„æ„Ÿè§‰

            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(0.3, now + 0.02);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);

            osc.connect(filter);
            filter.connect(gain);
            gain.connect(this.masterGain);
            osc.start(now);
            osc.stop(now + 0.25);
        }
        else if (type === 'ignite') {
             // ğŸ”¥ ç‚¹ç‡ƒ/ç‡ƒçƒ§ä¸­ï¼šä½é¢‘è½°é¸£
            const noise = this.ctx.createBufferSource();
            noise.buffer = this.noiseBuffer;
            const filter = this.ctx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(400, now);
            const gain = this.ctx.createGain();
            
            gain.gain.setValueAtTime(0.2, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.3);

            noise.connect(filter);
            filter.connect(gain);
            gain.connect(this.masterGain);
            noise.start(now);
            noise.stop(now + 0.4);
        }
    }
    /**
     * æ’­æ”¾ä¸€ä¸ªéŸ³è°ƒ
     * @param {number} freq - **é‡è¦å‚æ•°** é¢‘ç‡ (Hz)
     * @param {string} type - **é‡è¦å‚æ•°** æ³¢å½¢ç±»å‹ ('sine', 'square', 'sawtooth', 'triangle')
     * @param {number} duration - **é‡è¦å‚æ•°** æŒç»­æ—¶é—´ (ç§’)
     * @param {number} [vol=1] - åˆå§‹éŸ³é‡
     */
    playMagic() {
        if (this.muted) return;
        const now = this.ctx.currentTime;
        // æ’­æ”¾ä¸€ä¸²å¿«é€Ÿçš„é–ƒçˆéŸ³
        [400, 600, 800].forEach((freq, i) => {
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(freq, now + i * 0.05);
            gain.gain.setValueAtTime(0.1, now + i * 0.05);
            gain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.05 + 0.1);
            osc.connect(gain);
            gain.connect(this.masterGain);
            osc.start(now + i * 0.05);
            osc.stop(now + i * 0.05 + 0.1);
        });
    }
    playTone(freq, type, duration, vol = 1) {
        if (this.muted) return;
        
        const now = this.ctx.currentTime;
        //  å¾®å°çš„éšæœºå»¶è¿Ÿ (0 ~ 0.03ç§’)ï¼Œé”™å¼€æ³¢å³°
        const randomDelay = Math.random() * 0.03; 
        //  å¾®å°çš„é¢‘ç‡æŠ–åŠ¨ (+- 10Hz)ï¼Œé˜²æ­¢å®Œå…¨å…±æŒ¯
        const randomDetune = (Math.random() - 0.5) * 20; 

        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        osc.type = type;
        // ä½¿ç”¨ detune æ¥å¾®è°ƒï¼Œæ¯”ç›´æ¥æ”¹ freq æ›´è‡ªç„¶
        osc.frequency.setValueAtTime(freq, now);
        osc.detune.setValueAtTime(randomDetune, now); 

        //  é™åˆ¶å•ä¸ªéŸ³æ•ˆçš„æœ€å¤§éŸ³é‡ï¼Œé˜²æ­¢ä¼ å…¥è¿‡å¤§çš„ vol
        const safeVol = Math.min(vol, 0.5); 

        gain.gain.setValueAtTime(0, now); // å…ˆè®¾ä¸º0
        // å¿«é€Ÿæ·¡å…¥ (æ¶ˆé™¤ç‚¹å‡»å£°)
        gain.gain.linearRampToValueAtTime(safeVol, now + randomDelay + 0.01);
        // æŒ‡æ•°æ·¡å‡º
        gain.gain.exponentialRampToValueAtTime(0.01, now + randomDelay + duration);

        osc.connect(gain);
        gain.connect(this.masterGain);
        
        osc.start(now + randomDelay);
        osc.stop(now + randomDelay + duration);
    }
    
 
    /**
     * æ’­æ”¾å¼¹ç æ’å‡»é’‰å­çš„éŸ³æ•ˆ (ç‰©ç†çœŸå®ç‰ˆï¼šçŸ­ä¿ƒã€åšå®ã€æœ‰æ‰“å‡»æ„Ÿ)
     * @param {string} type - é’‰å­ç±»å‹
     * @param {number} speed - æ’å‡»é€Ÿåº¦
     */
    playHit(type, speed = 5) {
        if (this.muted) return;

        const now = this.ctx.currentTime;
        
        // å†·å´æ£€æŸ¥
        if (this.lastPlayTime[type] && (now - this.lastPlayTime[type] < 0.05)) {
            return; 
        }
        this.lastPlayTime[type] = now;

        // --- 1. åŠ¨æ€å‚æ•° ---
        // é€Ÿåº¦å½±å“éŸ³é‡å’ŒéŸ³è°ƒå¾®è°ƒ
        const velocity = Math.min(Math.max(speed / 15, 0.1), 1.0);
        // éŸ³è°ƒå¾®å°éšæœºåŒ– (+/- 8%) æ¨¡æ‹Ÿä¸åŒæ¥è§¦ç‚¹
        const detune = 1.0 + (Math.random() - 0.5) * 0.16; 

        // --- 2. åŸºé¢‘è°ƒæ•´ (æ•´ä½“é™ä½ï¼Œå»é™¤"é£é“ƒæ„Ÿ") ---
        const baseFreqs = { 
            'normal': 800,    // é™åˆ°ä¸­é¢‘ï¼Œæ¨¡æ‹Ÿå®å¿ƒé’¢ç 
            'bounce': 1000,   
            'pierce': 600,    // æ›´æ²‰
            'scatter': 1200,  
            'damage': 500,    
            'cryo': 2200,     // å†°è¿˜æ˜¯ä¿ç•™ä¸€ç‚¹è„†
            'pyro': 300,      // åƒçˆ†ç‚¸é—·å“
            'lightning': 900,
            'pink': 1100      
        };
        const baseFreq = (baseFreqs[type] || 800) * detune;

        // --- 3. å£°éŸ³åˆæˆï¼šå†²å‡»å£° (Impact) + ä½™éŸ³ (Resonance) ---

        // æŒ¯è¡å™¨ A: å†²å‡»ä¸»ä½“ (Impact)
        // ä½¿ç”¨æ­£å¼¦æ³¢ï¼Œå£°éŸ³æœ€æ‰å®ï¼Œä¸åˆºè€³
        const oscA = this.ctx.createOscillator();
        const gainA = this.ctx.createGain();
        oscA.type = 'sine';
        
        // æŒ¯è¡å™¨ B: æ¥è§¦ç¬æ€ (Click)
        // ä½¿ç”¨æ–¹æ³¢æ¨¡æ‹Ÿåˆšæ€§æ¥è§¦çš„ç¬é—´ï¼ŒæçŸ­
        const oscB = this.ctx.createOscillator();
        const gainB = this.ctx.createGain();
        oscB.type = 'square'; 

        // --- 4. é¢‘ç‡åŒ…ç»œ (æ¨¡æ‹Ÿç‰©ç†æ’å‡»çš„éŸ³é«˜ä¸‹æ½œ) ---
        // æçŸ­çš„æ—¶é—´å†…é¢‘ç‡å¿«é€Ÿä¸‹é™ï¼Œäº§ç”Ÿ"ç¬ƒ"çš„æ„Ÿè§‰
        oscA.frequency.setValueAtTime(baseFreq + 200, now);
        oscA.frequency.exponentialRampToValueAtTime(baseFreq, now + 0.05);

        // ç¬æ€éŸ³é«˜æ›´é«˜ï¼Œè¡°å‡æ›´å¿«
        oscB.frequency.setValueAtTime(baseFreq * 3, now); 
        oscB.frequency.exponentialRampToValueAtTime(baseFreq, now + 0.01);

        // --- 5. éŸ³é‡åŒ…ç»œ (æçŸ­ï¼Œæ— å»¶éŸ³) ---
        
        // ä¸»ä½“éŸ³ï¼šå¿«é€Ÿèµ·éŸ³ï¼Œå¿«é€Ÿæ¶ˆé€ (0.08ç§’å†…ç»“æŸ)
        gainA.gain.setValueAtTime(0, now);
        gainA.gain.linearRampToValueAtTime(0.8 * velocity, now + 0.002); 
        gainA.gain.exponentialRampToValueAtTime(0.001, now + 0.08 + (velocity * 0.05)); 

        // æ¥è§¦éŸ³ï¼šç¬é—´æ¶ˆå¤± (0.01ç§’)ï¼Œåªç•™ä¸ª"å—’"çš„å¤´
        gainB.gain.setValueAtTime(0, now);
        gainB.gain.linearRampToValueAtTime(0.15 * velocity, now + 0.001);
        gainB.gain.exponentialRampToValueAtTime(0.001, now + 0.015);

        // --- 6. æ»¤æ³¢å™¨ (æŠŠå£°éŸ³å˜"é—·"ä¸€ç‚¹ï¼Œå»æ•°ç å‘³) ---
        // é’¢ç æ’å‡»ä¸éœ€è¦å¤ªé«˜çš„é«˜é¢‘
        const filter = this.ctx.createBiquadFilter();
        if (type === 'cryo') {
            // [é’ˆå¯¹å†°çš„ä¼˜åŒ–]ï¼šä½¿ç”¨é«˜é€šæ»¤æ³¢å™¨
            // å†°å—æ’å‡»ä¸ä»…æ²¡æœ‰ä½é¢‘ï¼Œè¿˜éœ€è¦çªå‡ºé«˜é¢‘çš„"è„†"
            filter.type = 'highpass';
            filter.frequency.setValueAtTime(1500, now); // åˆ‡æ‰ 1500Hz ä»¥ä¸‹çš„æ‰€æœ‰å£°éŸ³
            
            // å†°çš„æ’å‡»å£°åŒ…ç»œè¦æ›´çŸ­ã€æ›´è„†
            gainA.gain.cancelScheduledValues(now);
            gainA.gain.setValueAtTime(0, now);
            gainA.gain.linearRampToValueAtTime(0.6 * velocity, now + 0.002);
            gainA.gain.exponentialRampToValueAtTime(0.001, now + 0.1); // è¡°å‡æå¿«
        } else {
            // å…¶ä»–ç±»å‹çš„åŸæœ‰é€»è¾‘ (Lowpass æ¨¡æ‹Ÿå®å¿ƒç‰©ä½“)
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(2000 + (velocity * 3000), now);
        }     
        // è¿æ¥è·¯å¾„
        oscA.connect(filter);
        oscB.connect(filter);
        filter.connect(gainA); // Aä¸ºä¸»é€šé“æ§åˆ¶
        // Bçš„éŸ³é‡å•ç‹¬æ§åˆ¶åä¹Ÿæ±‡å…¥ A çš„é€šé“æˆ–è€…ç›´æ¥è¾“å‡ºï¼Œè¿™é‡Œç®€å•èµ·è§å„è‡ªè¿æ¥ Gain
        // ä¿®æ­£è¿æ¥é€»è¾‘ï¼š
        oscA.disconnect(); oscB.disconnect();
        
        oscA.connect(gainA);
        gainA.connect(filter);
        
        oscB.connect(gainB);
        gainB.connect(filter);

        filter.connect(this.masterGain);

        // æ’­æ”¾
        oscA.start(now);
        oscA.stop(now + 0.15);
        oscB.start(now);
        oscB.stop(now + 0.15);
    }

    /**
     * æ’­æ”¾å‘å°„å¼¹ç çš„éŸ³æ•ˆ (æœ€ç»ˆç‰ˆï¼šå¹²ç»ƒã€æ¸…è„†ã€ä½è°ƒçˆ½æ„Ÿ)
     * å¬æ„Ÿï¼šç±»ä¼¼æ¶ˆéŸ³æ‰‹æªæˆ–é«˜çº§æœºæ¢°å¼€å…³çš„ "Thwip" å£°
     */
    playShoot() {
        if (this.muted) return;
        const now = this.ctx.currentTime;
        
        // å¾®è°ƒï¼šæ¯æ¬¡å‘å°„æœ‰æå°çš„éŸ³è°ƒå˜åŒ– (+/- 5%)ï¼Œé˜²æ­¢å¬è§‰ç–²åŠ³
        const randomDetune = 1.0 + (Math.random() - 0.5) * 0.1;

        // --- Layer 1: æœºæ¢°æ’é’ˆ (The Click) ---
        // ä½¿ç”¨é«˜é€šå™ªéŸ³ï¼Œåˆ¶é€ æçŸ­çš„â€œå’”å“’â€å£°
        // è¿™æ˜¯â€œå¹²è„†â€çš„å…³é”®ï¼Œè´Ÿè´£é«˜é¢‘çš„æ¸…æ™°åº¦
        const noise = this.ctx.createBufferSource();
        noise.buffer = this.noiseBuffer;
        
        const noiseFilter = this.ctx.createBiquadFilter();
        noiseFilter.type = 'highpass';
        noiseFilter.frequency.setValueAtTime(2000, now); // åªç•™2000Hzä»¥ä¸Šçš„é«˜é¢‘
        
        const noiseGain = this.ctx.createGain();
        noiseGain.gain.setValueAtTime(0.2, now); // éŸ³é‡é€‚ä¸­ï¼Œä¸åˆºè€³
        noiseGain.gain.exponentialRampToValueAtTime(0.01, now + 0.03); // æçŸ­ï¼30mså†…æ¶ˆå¤±

        noise.connect(noiseFilter);
        noiseFilter.connect(noiseGain);
        noiseGain.connect(this.masterGain);
        noise.start(now);
        noise.stop(now + 0.05);

        // --- Layer 2: æ°”åŠ¨æ¨è¿› (The Thump) ---
        // ä½¿ç”¨æ­£å¼¦æ³¢ï¼Œé¢‘ç‡æä½ä¸”å¿«é€Ÿä¸‹æ½œ
        // åˆ¶é€ â€œå™—â€çš„ä¸€å£°ï¼Œæä¾›åŠ›åº¦ä½†æ²¡æœ‰æ˜æ˜¾çš„â€œPewâ€è°ƒå­
        const osc = this.ctx.createOscillator();
        const oscGain = this.ctx.createGain();
        osc.type = 'sine'; // æ­£å¼¦æ³¢æœ€å¹²å‡€ï¼Œä¸æŠ¢æˆ
        
        // é¢‘ç‡ä»ä¸­ä½é¢‘(180Hz) ç¬é—´è·Œè½åˆ° è¶…ä½é¢‘(50Hz)
        // è¿™ä¸ªèŒƒå›´å¾ˆä½ï¼Œäººè€³å¬èµ·æ¥æ›´åƒæ˜¯éœ‡åŠ¨è€Œä¸æ˜¯å£°éŸ³
        osc.frequency.setValueAtTime(180 * randomDetune, now);
        osc.frequency.exponentialRampToValueAtTime(40, now + 0.08); // 80mså†…è·Œè½åˆ°åº•

        oscGain.gain.setValueAtTime(0, now);
        oscGain.gain.linearRampToValueAtTime(0.5, now + 0.005); // ç¬é—´èµ·éŸ³ (Punchy)
        oscGain.gain.exponentialRampToValueAtTime(0.01, now + 0.08); // å¿«é€Ÿæ”¶å°¾ (Tight)

        osc.connect(oscGain);
        oscGain.connect(this.masterGain);
        osc.start(now);
        osc.stop(now + 0.1);
    }
    /**
     * æ’­æ”¾çˆ†ç‚¸éŸ³æ•ˆ
     */
    playExplosion() { if (!this.muted) this.playTone(100, 'sawtooth', 0.4, 0.5); }

    /**
     * æ’­æ”¾é—ªç”µéŸ³æ•ˆ
     */
    playLightning() {
        if (this.muted) return;
        const t = this.ctx.currentTime;
        
        // 1. å‰µå»ºå™ªè²æº
        const noise = this.ctx.createBufferSource();
        noise.buffer = this.noiseBuffer;
        
        // 2. å‰µå»ºæ¿¾æ³¢å™¨ (Highpass æ¨¡æ“¬æ’•è£‚è²)
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'highpass';
        
        // --- ä¿®æ”¹ç‚¹ A: é™ä½èµ·å§‹é¢‘ç‡ ---
        // åŸæ¥æ˜¯ 1000ï¼Œæ”¹å°ä¸€é»ï¼ˆä¾‹å¦‚ 600-800ï¼‰å¯ä»¥è®©å£°éŸ³æ²¡é‚£ä¹ˆå°–é”åˆºè€³
        filter.frequency.setValueAtTime(800, t); 
        filter.frequency.exponentialRampToValueAtTime(100, t + 0.2); 

        // 3. éŸ³é‡åŒ…çµ¡ (ADSR)
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0, t);
        
        // --- ä¿®æ”¹ç‚¹ B: é™ä½å³°å€¼éŸ³é‡ ---
        // åŸæ¥æ˜¯ 0.8 (æ¥µå¤§è²)ï¼Œå»ºè­°æ”¹æˆ 0.2 æˆ– 0.25
        gain.gain.linearRampToValueAtTime(0.25, t + 0.05); 
        
        gain.gain.exponentialRampToValueAtTime(0.01, t + 0.4); 

        noise.connect(filter);
        filter.connect(gain);
        gain.connect(this.masterGain);
        
        noise.start(t);
        noise.stop(t + 0.5);
    }

    /**
     * æ’­æ”¾æ•Œäººè¢«å‡»ä¸­éŸ³æ•ˆ
     */
    /**
     * æ’­æ”¾æ•Œäººè¢«å‡»ä¸­éŸ³æ•ˆ (ä¼˜åŒ–ç‰ˆï¼šä½æ²‰å†²å‡» + ç ´ç¢è´¨æ„Ÿ)
     */
    /**
     * æ’­æ”¾æ•Œäººè¢«å‡»ä¸­éŸ³æ•ˆ (æ”¯æŒå…ƒç´ æè´¨åŒºåˆ†)
     * @param {string} type - ä¼¤å®³ç±»å‹ ('normal', 'cryo', 'pyro', 'lightning', 'pierce')
     */
    /**
     * æ’­æ”¾æ•Œäººè¢«å‡»ä¸­éŸ³æ•ˆ (v3.0: âš¡ç”µæµFMåˆæˆ & â„ï¸å†°æ™¶ç¢è£‚å¢å¼º)
     * @param {string} type - ä¼¤å®³ç±»å‹
     */
    playEnemyHit(type = 'normal') {
        if (this.muted) return;
        const now = this.ctx.currentTime;
        const detune = 0.9 + Math.random() * 0.2; 

        // === Layer A: åŸºç¡€ç‰©ç†æ‰“å‡» (æ‰€æœ‰ç±»å‹éƒ½æœ‰çš„"è‚‰æ„Ÿ") ===
        const oscLow = this.ctx.createOscillator();
        const gainLow = this.ctx.createGain();
        oscLow.type = 'sine';
        oscLow.frequency.setValueAtTime(150 * detune, now);
        oscLow.frequency.exponentialRampToValueAtTime(40, now + 0.12); // å¿«é€Ÿä¸‹æ½œ

        gainLow.gain.setValueAtTime(0, now);
        gainLow.gain.linearRampToValueAtTime(0.4, now + 0.005);
        gainLow.gain.exponentialRampToValueAtTime(0.01, now + 0.12);

        oscLow.connect(gainLow);
        gainLow.connect(this.masterGain);
        oscLow.start(now);
        oscLow.stop(now + 0.15);

        // === Layer B: å…ƒç´ ç‰¹å¾ (é‡å†™éƒ¨åˆ†) ===

        if (type === 'lightning') {
            // âš¡ é—ªç”µ: Layer 1 (FMæ’•è£‚) + Layer 2 (é«˜é¢‘æ»‹æ»‹)
            
            // --- Layer 1: FM åˆæˆ (ä¿ç•™ä¹‹å‰çš„æ’•è£‚ä¸»éŸ³) ---
            // è´Ÿè´£åˆ¶é€  "Pew/Zwap" çš„åŠ¨æ€æ„Ÿ
            const carrier = this.ctx.createOscillator();
            const modulator = this.ctx.createOscillator();
            const modGain = this.ctx.createGain();
            const mainGain = this.ctx.createGain();

            carrier.type = 'sawtooth';
            carrier.frequency.setValueAtTime(600 * detune, now);
            carrier.frequency.linearRampToValueAtTime(200, now + 0.15);

            modulator.type = 'square';
            modulator.frequency.setValueAtTime(120, now); // éœ‡åŠ¨é¢‘ç‡
            modGain.gain.setValueAtTime(800, now);        // éœ‡åŠ¨æ·±åº¦
            
            // ç¨å¾®é™ä½ Layer 1 éŸ³é‡ï¼Œä¸º Layer 2 ç•™ç©ºé—´
            mainGain.gain.setValueAtTime(0.15, now);
            mainGain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);

            modulator.connect(modGain);
            modGain.connect(carrier.frequency);
            carrier.connect(mainGain);
            mainGain.connect(this.masterGain);

            carrier.start(now); modulator.start(now);
            carrier.stop(now + 0.2); modulator.stop(now + 0.2);

            // --- Layer 2: é«˜é¢‘å™ªéŸ³ (The Sizzle/Zzzzt) ---
            // è´Ÿè´£åˆ¶é€  "æ»‹æ»‹" çš„ç”µæµæ¥è§¦å£°
            const noise = this.ctx.createBufferSource();
            noise.buffer = this.noiseBuffer;
            
            const noiseFilter = this.ctx.createBiquadFilter();
            // ä½¿ç”¨å¸¦é€šæ»¤æ³¢å™¨ (Bandpass) æå–é«˜é¢‘ç”µæµå£°
            noiseFilter.type = 'bandpass';
            noiseFilter.Q.value = 1.5; // ç¨å¾®çª„ä¸€ç‚¹ï¼Œè®©å£°éŸ³æ›´å°–é”
            // é¢‘ç‡éšæœºåŒ– (3000Hz ~ 6000Hz)ï¼Œæ¨¡æ‹Ÿæ¯æ¬¡ç”µå¼§çš„ä¸ç¨³å®š
            noiseFilter.frequency.setValueAtTime(3000 + Math.random() * 3000, now);
            
            // è¿˜å¯ä»¥è®©æ»¤æ³¢å™¨é¢‘ç‡å¿«é€Ÿæ»‘åŠ¨ï¼Œå¢åŠ "ç©¿é€æ„Ÿ"
            noiseFilter.frequency.exponentialRampToValueAtTime(1000, now + 0.1);

            const noiseGain = this.ctx.createGain();
            noiseGain.gain.setValueAtTime(0.35, now); // å™ªéŸ³å±‚è¦å¤Ÿäº®
            // è¡°å‡æå¿«ï¼Œæ¨¡æ‹Ÿç«èŠ±ç¬é—´ç†„ç­
            noiseGain.gain.exponentialRampToValueAtTime(0.01, now + 0.08); 

            noise.connect(noiseFilter);
            noiseFilter.connect(noiseGain);
            noiseGain.connect(this.masterGain);
            
            noise.start(now);
            noise.stop(now + 0.15);
        }
        else if (type === 'cryo') {
            // â„ï¸ å†°å†»æ‰“å‡» V4ï¼šå¤šé‡å¾®ç²’ç¢è£‚ (Granular Shatter)
            // é’¢ç®¡æ˜¯ä¸€ä¸ªé•¿éŸ³ï¼Œå†°æ˜¯æ— æ•°ä¸ªçŸ­ä¿ƒçš„å´©è£‚éŸ³ç»„åˆ
            
            // 1. ç”Ÿæˆ 3-4 ä¸ªæçŸ­çš„éšæœºé«˜é¢‘ "Pop" éŸ³ (æ¨¡æ‹Ÿè£‚çº¹æ‰©æ•£)
            const crackCount = 3 + Math.floor(Math.random() * 2);
            
            for (let i = 0; i < crackCount; i++) {
                // ç¨å¾®é”™å¼€æ—¶é—´ï¼Œåˆ¶é€ â€œå’”åš“â€çš„é¢—ç²’æ„Ÿï¼Œè€Œä¸æ˜¯â€œå®â€çš„ä¸€å£°
                const t = now + (i * 0.015); 
                
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                // ä½¿ç”¨ä¸‰è§’æ³¢ (Triangle) æ¯”æ­£å¼¦æ³¢æ›´å°–é”ï¼Œæœ‰ç‚¹ç»ç’ƒæ„Ÿ
                osc.type = 'triangle';
                
                // é¢‘ç‡æé«˜ï¼š2500Hz ~ 5000Hz (é’¢ç®¡é€šå¸¸åœ¨ 800-1500Hz)
                // æ¯ä¸€ä¸ªé¢—ç²’çš„é¢‘ç‡éƒ½ä¸åŒ
                const freq = 2500 + Math.random() * 2500;
                osc.frequency.setValueAtTime(freq, t);
                
                // éŸ³é‡åŒ…ç»œï¼šæçŸ­ï¼15æ¯«ç§’å†…æ¶ˆå¤±
                gain.gain.setValueAtTime(0, t);
                gain.gain.linearRampToValueAtTime(0.15, t + 0.002); // ç¬é—´èµ·éŸ³
                gain.gain.exponentialRampToValueAtTime(0.001, t + 0.03); // ç¬é—´åœæ­¢ (å»é™¤ä½™éŸ³æ˜¯å…³é”®)
                
                // é«˜é€šæ»¤æ³¢ï¼šåˆ‡æ‰æ‰€æœ‰ä½é¢‘ï¼Œé˜²æ­¢å‡ºç°â€œé—·â€çš„å£°éŸ³
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.setValueAtTime(2000, t);

                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);
                
                osc.start(t);
                osc.stop(t + 0.05);
            }

            // 2. å†°å±‘å™ªéŸ³ (Noise Burst) - å¢åŠ â€œæ²™æ²™â€çš„è´¨æ„Ÿ
            const noise = this.ctx.createBufferSource();
            noise.buffer = this.noiseBuffer;
            
            const noiseFilter = this.ctx.createBiquadFilter();
            noiseFilter.type = 'highpass';
            noiseFilter.frequency.setValueAtTime(5000, now); // åªç•™æé«˜é¢‘çš„å‘²å‘²å£°
            
            const noiseGain = this.ctx.createGain();
            noiseGain.gain.setValueAtTime(0.3, now);
            noiseGain.gain.exponentialRampToValueAtTime(0.01, now + 0.05); // 50ms ç»“æŸ

            noise.connect(noiseFilter);
            noiseFilter.connect(noiseGain);
            noiseGain.connect(this.masterGain);
            
            noise.start(now);
            noise.stop(now + 0.06);
            
            return; // ç»“æŸ cryo çš„å¤„ç†
        } else if (type === 'pyro') {
            // ğŸ”¥ ç«ç„°: ä½é¢‘é”¯é½¿ + ä½é€šæ»¤æ³¢ (ä¿æŒä¹‹å‰çš„é—·å“æ„Ÿ)
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            const filter = this.ctx.createBiquadFilter();
            
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(100 * detune, now);
            osc.frequency.linearRampToValueAtTime(30, now + 0.15);
            
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(800, now);
            filter.frequency.exponentialRampToValueAtTime(50, now + 0.15);
            
            gain.gain.setValueAtTime(0.3, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
            
            osc.connect(filter); filter.connect(gain); gain.connect(this.masterGain);
            osc.start(now); osc.stop(now + 0.2);
        }
        else if (type === 'pierce') {
             // ğŸ—¡ï¸ ç©¿é€: æ–¹æ³¢ + é«˜æˆªæ­¢é¢‘ç‡
             const osc = this.ctx.createOscillator();
             const gain = this.ctx.createGain();
             const filter = this.ctx.createBiquadFilter();
             
             osc.type = 'square';
             osc.frequency.setValueAtTime(800 * detune, now);
             osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
             
             filter.type = 'lowpass'; // ç¨å¾®ä¿®é¥°ä¸€ä¸‹æ–¹æ³¢çš„åˆºè€³
             filter.frequency.setValueAtTime(4000, now);

             gain.gain.setValueAtTime(0.15, now);
             gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
             
             osc.connect(filter); filter.connect(gain); gain.connect(this.masterGain);
             osc.start(now); osc.stop(now + 0.2);
        }
    }

    /**
     * æ’­æ”¾å……èƒ½/å‡çº§éŸ³æ•ˆ (éŸ³è°ƒéšç­‰çº§çˆ¬å‡)
     * @param {number} level - å½“å‰å……èƒ½ç­‰çº§ (1 ~ 7+)
     */
    playPowerup(level = 1) {
        if (this.muted) return;
        
        // 1. é™åˆ¶ç­‰çº§èŒƒå›´ (1-7)ï¼Œè¶…è¿‡7çº§ä¿æŒæœ€é«˜éŸ³ï¼Œé¿å…å¤ªåˆºè€³
        const safeLevel = Math.min(Math.max(level, 1), 7);
        
        // 2. äº”å£°éŸ³é˜¶åŠéŸ³å¢é‡è¡¨ (C, D, E, G, A, C, D...)
        // å¯¹åº”çš„åŠéŸ³æ•°: 0, 2, 4, 7, 9, 12, 14
        const intervals = [0, 2, 4, 7, 9, 12, 14];
        const semitoneShift = intervals[safeLevel - 1];
        
        // 3. è®¡ç®—åŸºé¢‘ (åŸºç¡€éŸ³ C5 = 523.25Hz)
        // å…¬å¼: f = f0 * 2^(n/12)
        const baseFreq = 523.25 * Math.pow(2, semitoneShift / 12);
        
        const now = this.ctx.currentTime;

        // --- å£°éŸ³åˆæˆï¼šæ¸…äº®çš„æ°´æ™¶éŸ³ ---
        
        // æŒ¯è¡å™¨ 1: ä¸»éŸ³ (Triangle - æ¸©æš–æ˜äº®)
        const osc1 = this.ctx.createOscillator();
        const gain1 = this.ctx.createGain();
        osc1.type = 'triangle';
        osc1.frequency.setValueAtTime(baseFreq, now);

        // æŒ¯è¡å™¨ 2: æ³›éŸ³ (Sine - é«˜å…«åº¦ï¼Œå¢åŠ é€šé€æ„Ÿ)
        const osc2 = this.ctx.createOscillator();
        const gain2 = this.ctx.createGain();
        osc2.type = 'sine';
        osc2.frequency.setValueAtTime(baseFreq * 2, now); // é«˜å…«åº¦
        // å¾®è°ƒä¸€ç‚¹ç‚¹éŸ³åˆ†ï¼Œåˆ¶é€ â€œé—ªçƒæ„Ÿâ€
        osc2.detune.setValueAtTime(10, now); 

        // --- åŒ…ç»œ (ADSR) ---
        // å¿«é€Ÿèµ·éŸ³ï¼Œä¸­ç­‰è¡°å‡
        
        // ä¸»éŸ³åŒ…ç»œ
        gain1.gain.setValueAtTime(0, now);
        gain1.gain.linearRampToValueAtTime(0.2, now + 0.02);
        gain1.gain.exponentialRampToValueAtTime(0.001, now + 0.5);

        // æ³›éŸ³åŒ…ç»œ (æ¶ˆå¤±å¾—ç¨å¾®å¿«ä¸€ç‚¹)
        gain2.gain.setValueAtTime(0, now);
        gain2.gain.linearRampToValueAtTime(0.1, now + 0.02);
        gain2.gain.exponentialRampToValueAtTime(0.001, now + 0.4);

        // è¿æ¥
        osc1.connect(gain1);
        gain1.connect(this.masterGain);
        osc2.connect(gain2);
        gain2.connect(this.masterGain);

        // æ’­æ”¾
        osc1.start(now);
        osc1.stop(now + 0.55);
        osc2.start(now);
        osc2.stop(now + 0.55);
    }

    /**
     * æ’­æ”¾æ”¶é›†éŸ³æ•ˆ
     */
    playCollect() { this.playTone(700, 'sine', 0.1, 0.4); }
}
const audio = new SoundManager();

// --- å·¥å…·ç±» ---
class Vec2 {
    /**
     * äºŒç»´å‘é‡ç±» (ç”¨äºä½ç½®å’Œé€Ÿåº¦)
     * @param {number} x - **é‡è¦å‚æ•°** x åæ ‡
     * @param {number} y - **é‡è¦å‚æ•°** y åæ ‡
     */
    constructor(x, y) { this.x = x; this.y = y; }
    /** å‘é‡åŠ æ³• */
    add(v) { return new Vec2(this.x + v.x, this.y + v.y); }
    /** å‘é‡å‡æ³• */
    sub(v) { return new Vec2(this.x - v.x, this.y - v.y); }
    /** å‘é‡ä¹˜æ ‡é‡ */
    mult(s) { return new Vec2(this.x * s, this.y * s); }
    /** å‘é‡é•¿åº¦ */
    mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
    /** å½’ä¸€åŒ–å‘é‡ */
    norm() { const m = this.mag(); return m === 0 ? new Vec2(0,0) : new Vec2(this.x/m, this.y/m); }
    /**
     * è®¡ç®—åˆ°å¦ä¸€ä¸ªå‘é‡çš„è·ç¦»
     * @param {Vec2} v - **é‡è¦å‚æ•°** å¦ä¸€ä¸ªå‘é‡
     */
    dist(v) { return Math.sqrt(Math.pow(this.x - v.x, 2) + Math.pow(this.y - v.y, 2)); }
    /**
     * è®¡ç®—ç‚¹ç§¯
     * @param {Vec2} v - **é‡è¦å‚æ•°** å¦ä¸€ä¸ªå‘é‡
     */
    dot(v) { return this.x * v.x + this.y * v.y; }
    /**
     * æ—‹è½¬å‘é‡
     * @param {number} angle - **é‡è¦å‚æ•°** æ—‹è½¬è§’åº¦ (å¼§åº¦)
     */
    rotate(angle) {
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        return new Vec2(this.x * cos - this.y * sin, this.x * sin + this.y * cos);
    }
}

/**
 * æ˜¾ç¤ºçŸ­æš‚çš„æç¤ºä¿¡æ¯
 * @param {string} msg - **é‡è¦å‚æ•°** æç¤ºä¿¡æ¯å†…å®¹
 */
function showToast(msg) {
    const el = document.getElementById('toast');
    el.innerText = msg;
    el.classList.add('toast-visible');
    setTimeout(() => el.classList.remove('toast-visible'), 1500);
}

// --- æ¸¸æˆå®ä½“ ---
class MarbleDefinition {
    constructor(type, subtype) {
        this.type = type;
        this.subtype = subtype;
        this.collected = []; 
        this.compiled = false; 
        this.recipe = null; 
        this.session = null; 
    }

    getName() {
        if (this.type === 'white') return 'ç´”æ·¨å½ˆç ';
        if (this.type === 'redStripe') return 'çˆ†ç ´å½ˆç ';
        if (this.type === 'laser') return 'å…‰çƒ';
        if (this.type === 'rainbow') return 'ä¸ƒå½©ç¨œé¡';
        if (this.type === 'matryoshka') return 'å¥—å¨ƒå½ˆç '; // 
        if (this.type === 'colored') {
            const map = { 'bounce': 'å½ˆæ€§', 'pierce': 'ç©¿é€', 'scatter': 'æ•£å°„', 'damage': 'å¢å¹…', 'cryo': 'å†°éœœ', 'pyro': 'ç«ç„°', 'lightning': 'é–ƒé›»' };
            return `${map[this.subtype]}å½ˆç `;
        }
        return 'æœªçŸ¥å½ˆç ';
    }

    getColor() {
        if (this.type === 'white') return CONFIG.colors.marbleWhite;
        if (this.type === 'redStripe') return CONFIG.colors.marbleRedStripe;
        if (this.type === 'rainbow') return CONFIG.colors.marbleRainbow;
        if (this.type === 'matryoshka') return CONFIG.colors.matMatryoshka; // 
        if (this.type === 'laser') return CONFIG.colors.laser;
        if (this.type === 'colored') {
            const map = { 'bounce': CONFIG.colors.matBounce, 'pierce': CONFIG.colors.matPierce, 'scatter': CONFIG.colors.matScatter, 'damage': CONFIG.colors.matDamage, 'cryo': CONFIG.colors.matCryo, 'pyro': CONFIG.colors.matPyro, 'lightning': CONFIG.colors.matLightning };
            return map[this.subtype] || CONFIG.colors.marbleWhite;
        }
        return CONFIG.colors.marbleWhite;
    }
}

class SpecialSlot {
    /**
     * ç‰¹æ®Šæ§½ä½ç±» (åº•éƒ¨æ”¶é›†æ§½)
     * @param {number} x - **é‡è¦å‚æ•°** ä¸­å¿ƒ x åæ ‡
     * @param {number} y - **é‡è¦å‚æ•°** ä¸­å¿ƒ y åæ ‡
     * @param {number} width - **é‡è¦å‚æ•°** æ§½ä½å®½åº¦
     * @param {string} type - **é‡è¦å‚æ•°** æ§½ä½ç±»å‹ ('recall': å›æº¯, 'multicast': å¤šé‡å‘å°„, 'split': åˆ†è£‚)
     */
    constructor(x, y, width, type) {
        this.x = x; this.y = y; this.width = width; this.height = 12; this.type = type; this.animTimer = 0;this.hit = false;
    }
    /**
     * ç»˜åˆ¶æ§½ä½
     * @param {CanvasRenderingContext2D} ctx - ç»˜å›¾ä¸Šä¸‹æ–‡
     */
    draw(ctx) {
        if (this.hit) return;
        this.animTimer += 0.05;
        ctx.save();
        let color = '#fff'; let text = '';
        if (this.type === 'recall') { color = CONFIG.colors.slotRecall; text = "â†º"; }
        else if (this.type === 'multicast') { color = CONFIG.colors.slotMulticast; text = "+2"; }
        else if (this.type === 'split') { color = CONFIG.colors.slotSplit; text = "â‘‚"; }
        else if (this.type === 'relic') { color = '#facc15'; text = 'ğŸ†'; }

        // [æ–°å¢] è®Šå¤§æ§½ èˆ‡ æŠ€èƒ½é»æ§½
        else if (this.type === 'giant') { color = CONFIG.colors.slotGiant; text = "â¬†ï¸"; } // è®Šå¤§åœ–æ¨™
        else if (this.type === 'skill_point') { color = CONFIG.colors.slotSkill; text = "â˜…"; } // æ˜Ÿæ˜Ÿä»£è¡¨æŠ€èƒ½é»

        const glow = Math.sin(this.animTimer) * 5 + 10;
        ctx.shadowBlur = glow; ctx.shadowColor = color; ctx.fillStyle = color; ctx.globalAlpha = 0.3;
        ctx.fillRect(this.x - this.width/2, this.y - this.height/2, this.width, this.height);
        ctx.globalAlpha = 1.0; ctx.shadowBlur = 0; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.font = 'bold 16px sans-serif'; ctx.fillStyle = '#fff'; ctx.fillText(text, this.x, this.y);
        ctx.restore();
    }
}

class Peg {
    constructor(x, y, type = 'normal') {
        this.pos = new Vec2(x, y); 
        this.radius = 6; 
        this.type = type; 
        this.lit = false; 
        this.litTimer = 0; 
        this.cooldown = 0;
        
        //  ç¼©æ”¾åŠ¨ç”»å±æ€§
        this.scale = 1.0; 
        this.lightIntensity = 0; // å…‰ç…§å¼ºåº¦ (0~1)
        this.lightAngle = 0;     // å…‰æºæ–¹å‘ (å¼§åº¦)
    }
    // åœ¨ Peg ç±»ä¸­æ–°å¢æ­¤æ–¹æ³•
    /**
     * @method drawShadow
     * @description ç»˜åˆ¶é«˜çº§åŠ¨æ€é˜´å½± (è·ç¦»è¡°å‡ + å½¢çŠ¶é€è§†)
     */
    // --- åœ¨ Peg ç±»ä¸­æ›¿æ¢æ­¤æ–¹æ³• ---
    // --- åœ¨ Peg ç±»ä¸­æ›¿æ¢æ­¤æ–¹æ³• ---
    drawShadow(ctx, lightPos, lightRadius) {
        const dx = this.pos.x - lightPos.x;
        const dy = this.pos.y - lightPos.y;
        const distSq = dx * dx + dy * dy;

        // 1. åŸºç¡€å‰”é™¤ï¼šè¶…å‡ºå…‰ç…§èŒƒå›´ä¸ç”»
        if (distSq > lightRadius * lightRadius) return;

        const dist = Math.sqrt(distSq);

        // --- [æ ¸å¿ƒä¿®æ”¹]ï¼šé€æ˜åº¦éšè·ç¦»è¡°å‡ ---
        
        let alpha = 0;
        const isGlobalLight = lightRadius > 2000; // åˆ¤æ–­æ˜¯å¦ä¸ºå…¨å±€ç¯å¢ƒå…‰

        if (isGlobalLight) {
            // A. å…¨å±€å…‰ (å€¾æ–œäº§ç”Ÿçš„)ï¼š
            // ä¿æŒæ·¡æ·¡çš„å½±å­ï¼Œéšè·ç¦»è½»å¾®è¡°å‡ï¼Œæ¨¡æ‹Ÿå¤§æ°”é€è§†
            alpha = Math.max(0.05, 0.25 - (dist / 1500));
        } else {
            // B. å¼¹ç å…‰ (Drop Ball)ï¼š
            // è¿™æ˜¯ä¸€ä¸ªç‚¹å…‰æºï¼Œå…‰å¼ºè¡°å‡å¾ˆå¿«ã€‚
            // è®¡ç®—å½’ä¸€åŒ–è·ç¦» t (0.0 = å…‰æºä¸­å¿ƒ, 1.0 = å…‰ç…§è¾¹ç¼˜)
            const t = dist / lightRadius;
            
            // ä½¿ç”¨éçº¿æ€§è¡°å‡ (1-t)^2ï¼Œè®©é˜´å½±åœ¨è¾¹ç¼˜æ¶ˆå¤±å¾—æ›´è‡ªç„¶æŸ”å’Œ
            // åŸºç¡€æµ“åº¦ 0.5 -> è¾¹ç¼˜ 0
            alpha = 0.42 * Math.pow(1 - t, 2);
            
            // å¦‚æœå¤ªæ·¡äº†å°±ç›´æ¥ä¸ç”»ï¼ŒèŠ‚çœæ€§èƒ½
            if (alpha < 0.01) return;
        }

        // --- [å‚æ•°]ï¼šé˜´å½±é•¿åº¦ä¸å½¢æ€ ---
        // å¼¹ç å…‰çš„å…‰æºé«˜åº¦è¾ƒä½ (lightZ å°)ï¼Œæ‰€ä»¥é˜´å½±ä¼šæ‹‰å¾—æ¯”è¾ƒé•¿ï¼Œä½†ä¸åº”å¤ªç¦»è°±
        const lightZ = isGlobalLight ? 850 : 120; // å¼¹ç å…‰ Zè½´é«˜åº¦è¾ƒä½
        const pegZ = 5;     // é’‰å­é«˜åº¦
        
        // é€è§†å…¬å¼
        let shadowLen = (dist * pegZ) / lightZ * 30; 
        
        // é•¿åº¦é™åˆ¶
        shadowLen = Math.min(shadowLen, isGlobalLight ? 25 : 60); 

        // æ‰©æ•£ç³»æ•°ï¼šç¦»å…‰æºè¶Šè¿œï¼Œé˜´å½±æœ«ç«¯è¶Šæ•£å¼€
        const spreadFactor = 1.0 + (dist / 420); 

        // --- ä»¥ä¸‹ç»˜åˆ¶é€»è¾‘ä¿æŒä¸å˜ ---
        const angle = Math.atan2(dy, dx);
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        const r = this.radius * 0.8; 
        const px = -sin * r; 
        const py = cos * r;
        const ax = this.pos.x + px;
        const ay = this.pos.y + py;
        const bx = this.pos.x - px;
        const by = this.pos.y - py;
        const tipX = this.pos.x + cos * shadowLen;
        const tipY = this.pos.y + sin * shadowLen;
        const endPx = px * spreadFactor;
        const endPy = py * spreadFactor;
        const cx = tipX - endPx; 
        const dx_end = tipX + endPx;
        const cy = tipY - endPy; 
        const dy_end = tipY + endPy;

        ctx.save();
        // å¾„å‘æ¸å˜ï¼šä»é’‰å­æ ¹éƒ¨(æ·±)åˆ°é˜´å½±æœ«ç«¯(æµ…)
        const grad = ctx.createRadialGradient(
            this.pos.x, this.pos.y, r,
            this.pos.x, this.pos.y, shadowLen + r
        );
        // é¢œè‰²ä¹Ÿéšè·ç¦» alpha å˜åŒ–
        grad.addColorStop(0, `rgba(15, 23, 42, ${alpha})`);
        grad.addColorStop(1, `rgba(15, 23, 42, 0)`);
        
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.moveTo(ax, ay);
        ctx.lineTo(dx_end, dy_end);
        ctx.quadraticCurveTo(tipX + cos * 3, tipY + sin * 3, cx, cy);
        ctx.lineTo(bx, by);
        ctx.closePath();
        ctx.globalCompositeOperation = 'multiply';
        ctx.fill();
        ctx.restore();
    }
    resetLight() {
        this.lightIntensity = 0;
    }
    //  è®¡ç®—æ¥è‡ªæŸä¸ªå…‰æºçš„å½±å“
    calculateLight(sourcePos, lightRadius) {
        const dx = sourcePos.x - this.pos.x;
        const dy = sourcePos.y - this.pos.y;
        const distSq = dx*dx + dy*dy;
        const radiusSq = lightRadius * lightRadius;

        // å¦‚æœåœ¨å…‰ç…§èŒƒå›´å†…
        if (distSq < radiusSq) {
            const dist = Math.sqrt(distSq);
            // è®¡ç®—å¼ºåº¦ï¼šè·ç¦»è¶Šè¿‘è¶Šäº® (çº¿æ€§è¡°å‡)
            const intensity = 1.0 - (dist / lightRadius);
            
            // ç®€å•çš„å…‰ç…§å åŠ é€»è¾‘ï¼šå–æœ€å¤§å€¼ï¼Œæˆ–è€…ç´¯åŠ 
            // è¿™é‡Œæˆ‘ä»¬å–æœ€å¤§å€¼ï¼Œä¿è¯å…‰ç…§æ–¹å‘æ˜ç¡®
            if (intensity > this.lightIntensity) {
                this.lightIntensity = intensity;
                this.lightAngle = Math.atan2(dy, dx); // è®¡ç®—æŒ‡å‘å…‰æºçš„è§’åº¦
            }
        }
    }
    /**
     * é’‰å­è¢«å‡»ä¸­
     * @param {number} impactSpeed - æ’å‡»é€Ÿåº¦
     */
    hit(impactSpeed = 5) { 
        this.lit = true; 
        this.litTimer = 15; 
        this.cooldown = 30; 
        
        // é€Ÿåº¦è¶Šå¿«ï¼Œè§†è§‰ç¼©æ”¾è¶Šå¤§ (æœ€å¤§ 1.8)
        this.scale = 1.6 + Math.min(impactSpeed / 20, 0.2); 
        
        // å°†é€Ÿåº¦ä¼ é€’ç»™éŸ³æ•ˆç®¡ç†å™¨
        audio.playHit(this.type, impactSpeed); 
    }
    // --- æ›¿æ¢ Peg ç±»çš„ draw æ–¹æ³• ---
    draw(ctx, baseRadius, tilt = {x:0, y:0}) {
        const currentRadius = baseRadius * this.scale;
        
        // æ€§èƒ½ä¼˜åŒ–ï¼šåªæœ‰éæ™®é€šé’‰å­æˆ–è¢«ç‚¹äº®æ—¶æ‰è®¾ç½®é˜´å½±
        // æ™®é€šæ¸²æŸ“å°½é‡é¿å… shadowBlur
        const isSpecial = this.type !== 'normal';
        const isLit = this.lit;

        ctx.beginPath(); 
        ctx.arc(this.pos.x, this.pos.y, currentRadius, 0, Math.PI * 2);
        
        let color = CONFIG.colors.peg;
        switch(this.type) {
            case 'bounce': color = CONFIG.colors.matBounce; break;
            case 'pierce': color = CONFIG.colors.matPierce; break;
            case 'scatter': color = CONFIG.colors.matScatter; break;
            case 'damage': color = CONFIG.colors.matDamage; break;
            case 'cryo': color = CONFIG.colors.matCryo; break;
            case 'pyro': color = CONFIG.colors.matPyro; break;
            case 'lightning': color = CONFIG.colors.matLightning; break;
            case 'pink': color = CONFIG.colors.pegPink; break;
            case 'laser': color = CONFIG.colors.laser; break;
        }
        
        // --- 1. ç»˜åˆ¶ä¸»ä½“ ---
        if (this.type === 'laser') {
            // æ¿€å…‰é’‰å­ä¿æŒå‘å…‰ç‰¹æ•ˆ
            ctx.shadowBlur = 10;
            ctx.shadowColor = CONFIG.colors.laser;
            ctx.fillStyle = isLit ? '#ffffff' : color;
        } else {
            // æ™®é€š/å…¶ä»–é’‰å­ï¼šå–æ¶ˆæ˜‚è´µçš„ createRadialGradientï¼Œæ”¹ç”¨çº¯è‰²æˆ–ç®€å•å¤„ç†
            // ä»…åœ¨è¢«å‡»ä¸­æ—¶é«˜äº®
            if (isLit) {
                ctx.fillStyle = '#ffffff';
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#ffffff';
            } else {
                ctx.fillStyle = color;
                // å–æ¶ˆé»˜è®¤é˜´å½±ï¼Œå¤§å¹…æå‡æ€§èƒ½
                ctx.shadowBlur = 0; 
            }
        }
        ctx.fill();

        // æ¢å¤ Context çŠ¶æ€
        ctx.shadowBlur = 0;
        ctx.shadowColor = 'transparent';

        // --- 2. ç»˜åˆ¶å…‰ç…§åå…‰ (Rim Light) ---
        // ä»…å½“å…‰ç…§å¼ºåº¦è¶³å¤Ÿæ—¶æ‰ç»˜åˆ¶ï¼Œä¸”ä½¿ç”¨ globalAlpha æ›¿ä»£æ¸å˜
        if (this.lightIntensity > 0.1 && !isLit) {
            ctx.save();
            ctx.globalAlpha = this.lightIntensity * 0.6; // ä½¿ç”¨é€æ˜åº¦æ§åˆ¶å¼ºå¼±
            ctx.fillStyle = '#ffffff';
            
            // ç®€å•çš„åå¿ƒåœ†æ¨¡æ‹Ÿåå…‰
            const offsetDist = currentRadius * 0.4;
            const fx = this.pos.x + Math.cos(this.lightAngle) * offsetDist;
            const fy = this.pos.y + Math.sin(this.lightAngle) * offsetDist;
            
            ctx.beginPath();
            ctx.arc(fx, fy, currentRadius * 0.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }
        
        // --- 3. ç»˜åˆ¶ç‰¹æ®Šé’‰å­è¾¹æ¡† ---
        if (isSpecial) { 
            ctx.strokeStyle = 'rgba(255,255,255,0.4)';
            ctx.lineWidth = 1.5; 
            ctx.stroke(); 
        }
    }

    hit() { 
        this.lit = true; 
        this.litTimer = 15; 
        this.cooldown = 30; 
        //  ç¬é—´æ”¾å¤§ï¼Œåˆ¶é€ æ’å‡»æ„Ÿ
        this.scale = 1.6; 
        audio.playHit(this.type); 
    }

    update() { 
        if (this.litTimer > 0) this.litTimer--; else this.lit = false; 
        if (this.cooldown > 0) this.cooldown--;
        
        //  å¼¹æ€§æ¢å¤åŠ¨ç”» (Lerp back to 1.0)
        if (this.scale > 1.0) {
            this.scale -= 0.1; // å›å¼¹é€Ÿåº¦
            if (this.scale < 1.0) this.scale = 1.0;
        }
    }
}

class DropBall {
	    /**
	     * æ”¶é›†é˜¶æ®µçš„å¼¹ç ç±»
	     * @param {number} x - **é‡è¦å‚æ•°** åˆå§‹ x åæ ‡
	     * @param {number} y - **é‡è¦å‚æ•°** åˆå§‹ y åæ ‡
	     * @param {MarbleDefinition} marbleDef - **é‡è¦å‚æ•°** å¼¹ç å®šä¹‰
	     * @param {object} session - **é‡è¦å‚æ•°** å½“å‰æ”¶é›†ä¼šè¯æ•°æ® (åŒ…å« collected, multicast, currentHits ç­‰)
	     */
	    constructor(x, y, marbleDef, session) {
	        this.pos = new Vec2(x, y); this.vel = new Vec2((Math.random() - 0.5) * 2, 2); this.radius = CONFIG.physics.marbleRadius; this.active = true; this.def = marbleDef; this.session = session;
	        this.isRainbowShard = false; // æ˜¯å¦ä¸ºå½©è™¹å¼¹ç åˆ†è£‚å‡ºçš„ç¢ç‰‡
	        this.portalCooldown = 0; // æ§½ä½å†·å´æ—¶é—´
	        this.hitCount = 0; // æ’å‡»æ¬¡æ•°
	        this.canTriggerSplitSlot = true; // æ˜¯å¦å¯ä»¥è§¦å‘åˆ†è£‚æ§½ä½
            this.rollingSound = audio.createRollingSound();
            // --- Visual State ---
            this.lifeTime = 0; // ç”¨äºé©±åŠ¨åŠ¨ç”»
            this.visualSeed = Math.random() * 1000; // éšæœºç§å­ï¼Œç”¨äºé—ªç”µ/å™ªç‚¹çš„ä¸è§„åˆ™è·³åŠ¨
	    }
        /**
         * [æ ¸å¿ƒæ–¹æ³•] è·å–å½“å‰æ‰€æœ‰å±æ€§çš„å±‚æ•°
         * ç»“åˆäº†â€œå¼¹ç è‡ªå¸¦å±æ€§â€å’Œâ€œæ”¶é›†åˆ°çš„å±æ€§â€
         */
        getBuffState() {
            const stats = {
                cryo: 0,
                pyro: 0,
                lightning: 0,
                laser: 0,
                intensity: 0 // æ€»å¼ºåº¦ï¼Œç”¨äºæ§åˆ¶é€šç”¨å…‰æ™•
            };

            // 1. ç»Ÿè®¡å¼¹ç è‡ªå¸¦å±æ€§
            

            // 2. ç»Ÿè®¡æ”¶é›†åˆ°çš„å±æ€§
            if (this.session && this.session.collected) {
                this.session.collected.forEach(type => {
                    if (stats.hasOwnProperty(type)) {
                        stats[type]++;
                    }
                });
            }
            
            // é™åˆ¶æœ€å¤§å±‚æ•°ä»¥å…ç‰¹æ•ˆå¤ªå¤¸å¼ 
            stats.cryo = Math.min(12, stats.cryo);
            stats.pyro = Math.min(12, stats.pyro);
            stats.lightning = Math.min(12, stats.lightning);
            stats.laser = Math.min(12, stats.laser);
            
            // è®¡ç®—æ€»å¼ºåº¦
            stats.intensity = stats.cryo + stats.pyro + stats.lightning + stats.laser;

            return stats;
        }

	    /**
	     * @method update
	     * @description æ›´æ–°å¼¹ç ä½ç½®å’Œå¤„ç†ç¢°æ’ã€‚
	     * @param {Peg[]} pegs - **é‡è¦å‚æ•°** æ‰€æœ‰é’‰å­ã€‚
	     * @param {SpecialSlot[]} slots - **é‡è¦å‚æ•°** æ‰€æœ‰ç‰¹æ®Šæ§½ä½ã€‚
	     * @param {number} width - æ¸¸æˆåŒºåŸŸå®½åº¦ã€‚
	     * @param {number} height - æ¸¸æˆåŒºåŸŸé«˜åº¦ã€‚
	     * @param {number} timeScale - æ—¶é—´ç¼©æ”¾å› å­ã€‚
	     * @returns {string|object|null} ç¢°æ’ç»“æœ ('finished' æˆ– {action: 'split', ...} æˆ– null)ã€‚
	     */
	    update(pegs, slots, width, height, timeScale, tilt = {x:0, y:0}) {
            if (!this.active) {
                this.stopSound(); // ç¡®ä¿éæ´»è·ƒæ—¶åœæ­¢å£°éŸ³
                return null;
            }

            this.lifeTime += timeScale;
            const buffs = this.getBuffState(); // è·å–å®æ—¶å±æ€§

            // --- ç²’å­ç”Ÿæˆé€»è¾‘ (åŸºäºå½“å‰æ‹¥æœ‰çš„å±æ€§) ---
            // åªè¦å¸¦æœ‰æŸç§å±æ€§ï¼Œå°±ä¼šæ‰è½å¯¹åº”ç²’å­
            if (Math.random() < 0.4 * timeScale) { 
                const r = this.radius;

                // --- ğŸ”¥ Pyro (è¿‡çƒ­): ä¸Šå‡çš„ä½™çƒ¬ (Rising Embers) ---
                if (buffs.pyro > 0) {
                    // å±‚æ•°è¶Šé«˜ï¼Œä½™çƒ¬è¶Šå¯†é›†
                    const burnChance = 0.3 + (buffs.pyro * 0.42); 
                    
                    if (Math.random() < burnChance) {
                        // 1. ç”Ÿæˆä½ç½®ï¼šåœ¨çƒä½“ä¸ŠåŠéƒ¨åˆ†éšæœºç”Ÿæˆ (æ¨¡æ‹Ÿçƒ­æ°”)
                        // ç¨å¾®å®½ä¸€ç‚¹ï¼Œè®©ä½™çƒ¬ä¸ä»…ä»ä¸­å¿ƒå†’å‡ºæ¥
                        const spawnX = this.pos.x + (Math.random() - 0.5) * r * 1.5;
                        const spawnY = this.pos.y - (Math.random() * r * 0.8); 

                        // 2. è°ƒç”¨æ–°çš„ ember æ¨¡å¼
                        // é¢œè‰²å‚æ•°åœ¨è¿™é‡Œä¼šè¢« ember å†…éƒ¨çš„åŠ¨æ€é¢œè‰²è¦†ç›–ï¼Œæ‰€ä»¥ä¼ ä¸ªå ä½ç¬¦å³å¯
                        const ember = new Particle(spawnX, spawnY, '#fbbf24', 'ember');
                        
                        // [å¾®è°ƒ] æ ¹æ®å±‚æ•°ï¼Œè®©ç«ç„°å‡è…¾å¾—æ›´å¿«
                        ember.vel.y -= (buffs.pyro * 0.2);  
                        ember.size *= (0.42 + Math.random() * 4.2); // å¤§å°éšæœº
                        
                        game.particles.push(ember);
                        
                        // 3. å¶å°”ç”Ÿæˆé»‘çƒŸ (å¢åŠ å¯¹æ¯”åº¦ï¼Œè®©äº®è‰²æ›´äº®)
                        if (Math.random() < 0.15) {
                            const smoke = new Particle(spawnX, spawnY, 'rgba(0,0,0,0.3)', 'smoke');
                            smoke.size = r * 0.6; // è¾ƒå°çš„çƒŸ
                            smoke.vel.y *= 0.5;   // æ…¢é€Ÿé£˜
                            game.particles.push(smoke);
                        }
                    }
                }

                // --- â„ï¸ Cryo (è¿‡å†·): ä¸‹æ²‰çš„å†·æ°” - [ä¼˜åŒ–ç‰ˆï¼šæ¨¡ç³Šå¯’é›¾] ---
                if (buffs.cryo > 0) {
                    // å±‚æ•°è¶Šé«˜ï¼Œå†·æ°”è¶Šæµ“ï¼Œç”Ÿæˆé¢‘ç‡è¶Šé«˜
                    const mistChance = 0.25 + (buffs.cryo * 0.15);

                    if (Math.random() < mistChance) {
                        // 1. ç”Ÿæˆä½ç½®ï¼šçƒä½“ä¸‹åŠéƒ¨åˆ† (å†·æ°”ä¸‹æ²‰)
                        const spawnX = this.pos.x + (Math.random() - 0.5) * r * 1.2;
                        const spawnY = this.pos.y + (Math.random() * r * 0.6); 
                        
                        // 2. ä½¿ç”¨ 'mist' æ¨¡å¼
                        // é¢œè‰²å‚æ•°ä¼ ç©ºå³å¯ï¼ŒParticle ç±»å†…éƒ¨å†™æ­»äº†å†·è‰²è°ƒæ¸å˜
                        const mist = new Particle(spawnX, spawnY, null, 'mist');
                        
                        // å¾®è°ƒï¼šæ ¹æ® Cryo å±‚æ•°ï¼Œé›¾æ°”å¯ä»¥æ›´å¤§ä¸€ç‚¹
                        mist.size *= (1 + buffs.cryo * 0.1);

                        game.particles.push(mist);
                        
                        // 3. å¶å°”ç”Ÿæˆä¸€ç‚¹ç‚¹æ™¶è¹çš„å†°æ¸£ (å¢åŠ å¯¹æ¯”åº¦)
                        if (Math.random() < 0.05) {
                            const shard = new Particle(spawnX, spawnY, '#a5f3fc', 'shard');
                            shard.size = 2; // å¾ˆå°çš„å†°æ™¶
                            game.particles.push(shard);
                        }
                    }
                }
                
                // --- âš¡ Lightning (é—ªç”µ): å¶å°”æ®‹ç•™ç”µå¼§ ---
                // (æ—¢ç„¶åšäº†å°±é¡ºä¾¿åŠ ä¸Š)
                if (buffs.lightning > 0 && Math.random() < 0.02 * buffs.lightning) {
                     game.createParticle(this.pos.x, this.pos.y, '#d8b4fe', 'spark');
                }
            }
            if (this.portalCooldown > 0) this.portalCooldown -= timeScale;
            // é‡åŠ›è®¡ç®—
            // åŸºç¡€é‡åŠ›
            let gx = 0;
            let gy = CONFIG.physics.gravity;

            // å åŠ å€¾æ–œå½±å“
            // xè½´å€¾æ–œç›´æ¥äº§ç”Ÿæ¨ªå‘é‡åŠ›
            gx += tilt.x * 0.05; // 0.25 æ˜¯å€¾æ–œé‡åŠ›ç³»æ•°ï¼Œå¯è°ƒæ•´æ‰‹æ„Ÿ
            
            // yè½´å€¾æ–œå¾®è°ƒå‚ç›´é‡åŠ› (å‰å€¾åŠ é€Ÿï¼Œåå€¾å‡é€Ÿ)
            // gy += tilt.y * 0.1;

            let gravityStep = new Vec2(gx * timeScale, gy * timeScale);
            
            this.vel = this.vel.add(gravityStep);
            this.pos = this.pos.add(this.vel.mult(timeScale));
            this.vel = this.vel.mult(Math.pow(CONFIG.physics.friction, timeScale));

            //  æ›´æ–°æ»šåŠ¨éŸ³æ•ˆ
            // è®¡ç®—å½“å‰é€Ÿåº¦çš„å¤§å° (Magnitude)
            const currentSpeed = this.vel.mag();
            // åªæœ‰å½“çƒåœ¨å‘ä¸‹æ»šåŠ¨æˆ–è€…é€Ÿåº¦è¾ƒå¿«æ—¶æ‰æœ‰å£°éŸ³ (é˜²æ­¢å¡åœ¨æŸå¤„æ—¶è¿˜æœ‰å£°éŸ³)
            if (this.rollingSound) {
                this.rollingSound.update(currentSpeed);
            }

            // è¾¹ç•Œç¢°æ’
            if (this.pos.x < this.radius) { this.pos.x = this.radius; this.vel.x *= -0.6; }
            if (this.pos.x > width - this.radius) { this.pos.x = width - this.radius; this.vel.x *= -0.6; }
            
            // åº•éƒ¨é€€å‡º
            if (this.pos.y > height + 150) { 
                this.active = false; 
                this.stopSound(); 
                return 'finished'; 
            }

            // ... (ç‰¹æ®Šæ§½ä½æ£€æµ‹é€»è¾‘ä¿æŒä¸å˜ï¼Œåªéœ€æ³¨æ„ active=false æ—¶è°ƒç”¨ this.stopSound()) ...
            for (let slot of slots) {
                if (slot.hit) continue;
                if (this.portalCooldown <= 0) {
                    let dx = Math.abs(this.pos.x - slot.x);
                    let dy = Math.abs(this.pos.y - slot.y);
                    if (dy < 12 && dx < slot.width / 2) {
                        slot.hit = true;
                        this.portalCooldown = 40; 
                        if (slot.type === 'recall') {
                            this.pos.y = 80; this.vel.y = 2; this.portalCooldown = 60; audio.playPowerup(); game.createExplosion(slot.x, slot.y, CONFIG.colors.slotRecall); showToast("æ™‚ç©ºå›æº¯ï¼");
                        } else if (slot.type === 'multicast') {
                            if (this.session.multicastAdded.indexOf(slot) === -1) { 
                                this.session.multicast += 2; audio.playPowerup(); game.createExplosion(slot.x, slot.y, CONFIG.colors.slotMulticast); showToast("é€£çºŒç™¼å°„+2ï¼");
                                    game.updateMulticastDisplay(2);
                            }
                        } else if (slot.type === 'split') {
                            if (this.canTriggerSplitSlot) {
                                this.active = false; 
                                this.stopSound(); // 
                                audio.playPowerup(); game.createExplosion(slot.x, slot.y, CONFIG.colors.slotSplit); 
                                return { action: 'split', pos: this.pos, vel: this.vel, def: this.def };
                            }
                        } else if (slot.type === 'relic') {
                            this.active = false; 
                            this.stopSound(); // 
                            audio.playPowerup(); 
                            game.createExplosion(slot.x, slot.y, '#facc15'); 
                            return { type: 'slot', slotType: 'relic', pos: this.pos };
                        } else if (slot.type === 'giant') {
                            // è¦–è¦ºèˆ‡ç‰©ç†è®Šå¤§ (é»˜èªæ˜¯ 9.2ï¼Œé€™è£¡è¨­ç‚º 14 è®“æ•ˆæœæ›´æ˜é¡¯)
                            this.radius = 14.0; 
                            audio.playPowerup(); 
                            game.createExplosion(slot.x, slot.y, CONFIG.colors.slotGiant); 
                            showToast("å·¨å¤§åŒ–!");
                        }
                        
                        // [æ–°å¢] æŠ€èƒ½é»æ§½é‚è¼¯
                        else if (slot.type === 'skill_point') {
                            // 1. æ¨™è¨˜æ§½ä½è¢«æ“Šä¸­ (ç«‹å³æ¶ˆå¤±)
                            slot.hit = true;

                            // 2. æ’­æ”¾åŸåœ°éŸ³æ•ˆèˆ‡çˆ†ç‚¸ (ç«‹å³åé¥‹)
                            audio.playPowerup();
                            game.createExplosion(slot.x, slot.y, CONFIG.colors.slotSkill); 
                            showToast("æŠ€èƒ½é»ç²å–!");

                            // --- [æ–°å¢] å¼•å°å‹•ç•«é‚è¼¯ ---
                            
                            // A. è¨ˆç®— UI ç›®æ¨™ä½ç½® (ä¸‹ä¸€å€‹ç©ºçš„æŠ€èƒ½æ§½)
                            // ç²å–æ‰€æœ‰æ§½ä½ DOM
                            const uiSlots = document.querySelectorAll('.sp-slot');
                            // ç•¶å‰é»æ•¸å³ç‚ºä¸‹ä¸€å€‹ç©ºæ§½çš„ç´¢å¼• (ä¾‹å¦‚æœ‰0é»ï¼Œä¸‹ä¸€å€‹æ˜¯ç¬¬0å€‹)
                            const targetIndex = game.skillPoints; 
                            
                            let targetX = game.width / 2; // é»˜èªå…œåº•ä½ç½®
                            let targetY = 80;

                            // å¦‚æœèƒ½æ‰¾åˆ°å°æ‡‰çš„ DOM å…ƒç´ ï¼Œè¨ˆç®—å…¶ä¸­å¿ƒåæ¨™
                            if (uiSlots && uiSlots[targetIndex]) {
                                const rect = uiSlots[targetIndex].getBoundingClientRect();
                                targetX = rect.left + rect.width / 2;
                                targetY = rect.top + rect.height / 2;
                            }

                            // B. å‰µå»ºé£›è¡Œèƒ½é‡çƒ
                            const orb = new EnergyOrb(
                                slot.x, slot.y,   // èµ·é»ï¼šæ§½ä½ä½ç½®
                                targetX, targetY, // çµ‚é»ï¼šUI ä½ç½®
                                CONFIG.colors.slotSkill, // é¡è‰²ï¼šç¶ è‰²
                                new Vec2(0, -8),  // åˆé€Ÿåº¦ï¼šå‘ä¸Šå™´å‡º
                                () => {
                                    // --- C. åˆ°é”å›èª¿ (On Arrive) ---
                                    // åªæœ‰ç•¶çƒé£›åˆ°æ™‚ï¼Œæ‰çœŸæ­£å¢åŠ é»æ•¸
                                    game.addSkillPoint(1);

                                    // è§¸ç™¼ UI é–ƒå…‰ç‰¹æ•ˆ
                                    // é‡æ–°ç²å–ä¸€æ¬¡ DOMï¼Œå› ç‚º addSkillPoint å¯èƒ½é‡ç¹ªäº†å®ƒå€‘
                                    const updatedSlots = document.querySelectorAll('.sp-slot');
                                    // å‰›å‰›åŠ äº†1é»ï¼Œæ‰€ä»¥ç¾åœ¨è¦é–ƒçˆçš„æ˜¯ (ç¸½é»æ•¸ - 1) çš„ä½ç½®
                                    const filledSlot = updatedSlots[game.skillPoints - 1];
                                    
                                    if (filledSlot) {
                                        filledSlot.classList.remove('flash');
                                        void filledSlot.offsetWidth; // å¼·åˆ¶é‡ç¹ª
                                        filledSlot.classList.add('flash');
                                    }
                                    
                                    // æ’­æ”¾åˆ°é”éŸ³æ•ˆ (å¯é¸)
                                    audio.playCollect();
                                }
                            );

                            // å°‡å…‰çƒåŠ å…¥éŠæˆ²å¾ªç’°
                            game.energyOrbs.push(orb);
                        }
                    }
                }
            }

            // ... (é’‰å­ç¢°æ’æ£€æµ‹é€»è¾‘ä¿æŒä¸å˜ï¼Œæ³¨æ„ rainbow_split è¿”å›å‰åœæ­¢å£°éŸ³) ...
            for (let peg of pegs) {
                let dist = this.pos.dist(peg.pos); let minDist = this.radius + peg.radius;
                if (dist < minDist) {
                    // ... (åå¼¹é€»è¾‘ä¸å˜) ...
                    let n = this.pos.sub(peg.pos).norm();
                    this.pos = peg.pos.add(n.mult(minDist + 0.1));
                    const impactVel = new Vec2(this.vel.x, this.vel.y);

                    let d = this.vel.dot(n);
                    if (d < 0) {
                        let elasticity = CONFIG.physics.elasticity; 
                        if (peg.type === 'pink') elasticity *= CONFIG.physics.pinkpegElasticityMuti; 
                        this.vel = this.vel.sub(n.mult(2 * d)).mult(elasticity);
                        this.vel.x += (Math.random() - 0.5) * 0.5;
                    }

                    if (peg.cooldown <= 0) {
                        // --- [å…³é”®ä¿®æ”¹ï¼šä¼ é€’é€Ÿåº¦å‚æ•°] ---
                        const impactSpeedVal = impactVel.mag(); 
                        peg.hit(impactSpeedVal);
                        this.hitCount++; 
                        this.session.currentHits++; 
                        game.createHitFeedback(this.pos.x, this.pos.y, impactVel);
                        if (this.session.currentHits >= this.session.nextTriggerThreshold) {
                            this.session.currentHits = 0;
                            this.session.multicast++;
                          // å¢åŠ é˜ˆå€¼
                            this.session.nextTriggerThreshold = this.session.nextTriggerThreshold + CONFIG.gameplay.nextTriggerThresholdIncrease;
                            // åŒæ­¥æ›´æ–° Game ç±»çš„æŒä¹…å˜é‡ï¼Œç¡®ä¿ä¸‹ä¸€é¢—çƒèƒ½ç»§æ‰¿è¿™ä¸ªæ•°å€¼
                            game.persistentThreshold = this.session.nextTriggerThreshold;
                              showToast(`å……èƒ½ï¼ä¸‹ä¸€æ¬¡: ${this.session.nextTriggerThreshold}`); audio.playPowerup();
                        }
                        if (peg.type !== 'normal' && peg.type !== 'pink') { 
                            // --- [æ–°å¢/ä¿®æ”¹] å®æ—¶åˆæˆé€»è¾‘ ---
                            let finalType = peg.type;
                            let isSynthesized = false;
                            const collectedList = this.session.collected;

                            // 1. æ¡åˆ°ç«ï¼Œæ‰¾å†°
                            if (peg.type === 'pyro') {
                                const iceIdx = collectedList.indexOf('cryo');
                                if (iceIdx !== -1) {
                                    collectedList.splice(iceIdx, 1); // ç§»é™¤ä¸€ä¸ªå†°
                                    finalType = 'lightning';         // å˜æˆé›·
                                    isSynthesized = true;
                                }
                            }
                            // 2. æ¡åˆ°å†°ï¼Œæ‰¾ç«
                            else if (peg.type === 'cryo') {
                                const fireIdx = collectedList.indexOf('pyro');
                                if (fireIdx !== -1) {
                                    collectedList.splice(fireIdx, 1); // ç§»é™¤ä¸€ä¸ªç«
                                    finalType = 'lightning';          // å˜æˆé›·
                                    isSynthesized = true;
                                }
                            }
                            // å°†æœ€ç»ˆç»“æœåŠ å…¥æ”¶é›†åˆ—è¡¨
                            this.session.collected.push(finalType); 
                            this.def.collected.push(finalType); 

                            // ---  åˆæˆåé¦ˆ ---
                            if (isSynthesized) {
                                game.createFloatingText(this.pos.x, this.pos.y, "âš¡ SYNTHESIS!", "#c084fc");
                                audio.playLightning(); // æ’­æ”¾é—ªç”µéŸ³æ•ˆ
                            }

                            return { type: 'collected', material: finalType };
                        }
                        let assimilationType = null;
                        if (this.def.type === 'colored' && this.def.subtype) {
                            assimilationType = this.def.subtype;
                        } else if (this.def.type === 'laser') {
                            assimilationType = 'laser';
                        }

                        if (assimilationType) { 
                            // åŒåŒ–æ¦‚ç‡ (å¦‚æœæ˜¯æ¿€å…‰ï¼Œæ¦‚ç‡ä¹Ÿå¯ä»¥å•ç‹¬è®¾ï¼Œè¿™é‡Œæ²¿ç”¨ colored çš„æ¦‚ç‡)
                            const chance = CONFIG.gameplay.assimilationChance[assimilationType] || 0.3;
                            
                            if (peg.type !== 'pink' && peg.type !== assimilationType && Math.random() < chance) {
        peg.type = assimilationType; // å˜æˆå¯¹åº”ç±»å‹
        audio.playMagic();
                                // ç²’å­ç‰¹æ•ˆ
                                const pColor = assimilationType === 'laser' ? CONFIG.colors.laser : this.def.getColor();
                                game.createParticle(peg.pos.x, peg.pos.y, pColor);
                                game.createShockwave(peg.pos.x, peg.pos.y, pColor);
                            }
                        }
                        if (this.def.type === 'rainbow' && !this.isRainbowShard) { 
                            this.active = false; 
                            this.stopSound(); // 
                            return { action: 'rainbow_split', pos: this.pos, vel: this.vel }; 
                        }
                    }
                }
            }
            return null;
        }
        stopSound() {
            if (this.rollingSound) {
                this.rollingSound.stop();
                this.rollingSound = null;
            }
        }

        /**
         * @method draw
         * @description åˆ†å±‚ç»˜åˆ¶å¼¹ç  (ä¼˜åŒ–ï¼šç«ç„°æ··æ²Œé—ªçƒ)
         */
                /**
         * @method draw
         * @description åˆ†å±‚ç»˜åˆ¶å¼¹ç  (æ›´æ–°ï¼šçˆ†ç ´å¼¹ç ä¸“å±è§†è§‰)
         */
        draw(ctx) {
            if (!this.active) return;
            
            const x = this.pos.x;
            const y = this.pos.y;
            const r = this.radius;
            const buffs = this.getBuffState();
            
            ctx.save();
            ctx.translate(x, y);

            // ==========================================
            //  ğŸ”¥ æ··æ²Œé—ªçƒè®¡ç®— (é€šç”¨ç«ç„°ä¸çˆ†ç ´)
            // ==========================================
            let fireFlicker = 0;
            if (buffs.pyro > 0 || this.def.type === 'redStripe') {
                const slow = Math.sin(this.lifeTime * 0.1); 
                const fast = Math.sin(this.lifeTime * 0.8);
                const noise = Math.random() * 0.3;
                fireFlicker = 0.6 + (slow * 0.1) + (fast * 0.1) + noise;
            }

            // ==========================================
            //  LAYER 0: ğŸ”¦ Ambient Spotlight (ç¯å¢ƒå…‰)
            // ==========================================
            let glowColor = '255, 255, 255'; 
            let maxStack = 0;

            if (buffs.pyro > maxStack) { maxStack = buffs.pyro; glowColor = '251, 146, 60'; } // Orange
            if (buffs.cryo > maxStack) { maxStack = buffs.cryo; glowColor = '103, 232, 249'; } // Cyan
            if (buffs.lightning > maxStack) { maxStack = buffs.lightning; glowColor = '216, 180, 254'; } // Purple
            if (buffs.laser > maxStack) { maxStack = buffs.laser; glowColor = '56, 189, 248'; } // Sky
            
            // [ä¿®æ”¹]ï¼šçˆ†ç ´å¼¹ç çš„ä¸“å±ç¯å¢ƒå…‰ (å±é™©çš„çº¢è‰²)
            if (this.def.type === 'redStripe') {
                 glowColor = '239, 68, 68'; // Red-500
                 maxStack = 5; // å¼ºåˆ¶æœ€å¤§å…‰æ™•
            } else if (maxStack === 0 && this.def.type === 'rainbow') {
                glowColor = '244, 114, 182'; 
            }

            let baseAlpha = 0.042 + (maxStack * 0.03); 
            let currentAlpha = baseAlpha;
            
            // [ä¿®æ”¹]ï¼šçˆ†ç ´å¼¹ç çš„å…‰æ™•ä¼šå‰§çƒˆé—ªçƒ
            if (this.def.type === 'redStripe') {
                 const strobe = (Math.sin(Date.now() / 50) + 1) / 2; // é«˜é¢‘é—ªçƒ
                 currentAlpha = baseAlpha * (0.5 + strobe); // 0.5 ~ 1.5 å€å¼ºåº¦
            } else if (buffs.pyro > 0 && maxStack === buffs.pyro) {
                currentAlpha = baseAlpha * fireFlicker;
            } else {
                const breathSpeed = 0.05 + (maxStack * 0.05);
                const breath = (Math.sin(this.lifeTime * breathSpeed) + 1) / 2; 
                currentAlpha = baseAlpha + (breath * 0.04);
            }

            const spotR = r * 30; 
            const spot = ctx.createRadialGradient(0, 0, r, 0, 0, spotR);
            spot.addColorStop(0, `rgba(${glowColor}, ${currentAlpha})`);
            spot.addColorStop(1, `rgba(${glowColor}, 0)`);

            ctx.fillStyle = spot;
            ctx.beginPath(); ctx.arc(0, 0, spotR, 0, Math.PI * 2); ctx.fill();

            // ==========================================
            //  LAYER 1: ğŸ”¦ Laser Back Aura (æ¿€å…‰èƒŒå…‰)
            // ==========================================
            if (buffs.laser > 0) {
                // ... (ä¿æŒåŸæœ‰çš„æ¿€å…‰ç»˜åˆ¶é€»è¾‘ä¸å˜) ...
                const laserColor = CONFIG.colors.laser || '#0ea5e9';
                const pulse = (Math.sin(this.lifeTime * 5) + 1) / 1; 
                const sizeMod = 1 + (buffs.laser * 0.15); 
                ctx.save();
                ctx.globalCompositeOperation = 'lighter'; 
                ctx.shadowBlur = (15 + pulse * 10) * sizeMod;
                ctx.shadowColor = laserColor;
                ctx.fillStyle = laserColor;
                ctx.globalAlpha = 0.5 + (pulse * 0.2); 
                ctx.beginPath(); ctx.arc(0, 0, r * (1.1 + pulse * 0.1) * sizeMod, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = '#ffffff';
                ctx.globalAlpha = 0.9;
                ctx.beginPath(); ctx.arc(0, 0, 2, 0, Math.PI*2); ctx.fill();
                ctx.restore();
            }

            // ==========================================
            //  LAYER 2: Base Ball (çƒä½“æœ¬ä½“)
            // ==========================================
            
            // [æ–°å¢/ä¿®æ”¹]ï¼šçˆ†ç ´å¼¹ç ä¸“å±ç»˜åˆ¶é€»è¾‘ (RedStripe)
            // å®ƒä¸å†å’Œ Pyro å…±ç”¨é€»è¾‘ï¼Œè€Œæ˜¯æ‹¥æœ‰ç‹¬ç«‹çš„"ä¸ç¨³å®šæ ¸å¿ƒ"å¤–è§‚
            if (this.def.type === 'redStripe') {
                // 1. ç‰©ç†æŠ–åŠ¨ (Visual Jitter)
                const shake = 1.2;
                ctx.save();
                ctx.translate((Math.random()-0.5)*shake, (Math.random()-0.5)*shake);

                // 2. è­¦æŠ¥è„‰å†² (Strobe)
                const time = Date.now();
                const pulse = (Math.sin(time / 60) + 1) / 2; // æå¿«
                
                // é¢œè‰²å¾ªç¯ï¼šæš—çº¢ -> é²œçº¢ -> çº¯ç™½ (ä¸´ç•ŒçŠ¶æ€)
                let coreColor = '#b91c1c'; // base red
                let shellColor = '#7f1d1d'; // dark shell
                let glowIntensity = 10;
                
                if (pulse > 0.8) {
                    coreColor = '#ffffff'; // Flash White
                    shellColor = '#ef4444'; // Bright Red Shell
                    glowIntensity = 30;
                } else {
                    coreColor = '#ef4444';
                    glowIntensity = 15;
                }

                // 3. ç»˜åˆ¶å¤–å£³ (Dark Containment)
                const shellGrad = ctx.createRadialGradient(-r*0.4, -r*0.4, 0, 0, 0, r);
                shellGrad.addColorStop(0, shellColor);
                shellGrad.addColorStop(1, '#450a0a'); // Almost black red
                ctx.fillStyle = shellGrad;
                ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI*2); ctx.fill();

                // 4. ç»˜åˆ¶ä¸ç¨³å®šæ ¸å¿ƒ (Unstable Core)
                ctx.shadowBlur = glowIntensity;
                ctx.shadowColor = '#ef4444';
                ctx.fillStyle = coreColor;
                
                // æ ¸å¿ƒæ˜¯ä¸€ä¸ªåœ¨å‘¼å¸çš„å°åœ†
                const coreSize = r * (0.4 + pulse * 0.2);
                ctx.beginPath(); ctx.arc(0, 0, coreSize, 0, Math.PI*2); ctx.fill();

                // 5. ç»˜åˆ¶è¡¨é¢çš„èƒ½é‡è£‚çº¹ (Cracks)
                ctx.strokeStyle = `rgba(255, 255, 255, ${0.4 + pulse * 0.6})`;
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                // ç”»ä¸€ä¸ªç®€å•çš„åå­—è£‚çº¹æˆ–è€… X å½¢
                ctx.moveTo(-r*0.6, 0); ctx.lineTo(r*0.6, 0);
                ctx.moveTo(0, -r*0.6); ctx.lineTo(0, r*0.6);
                ctx.stroke();

                ctx.restore(); // ç»“æŸæŠ–åŠ¨

            } 
            // [åŸæœ‰é€»è¾‘]ï¼šPyro ç«ç„°å±æ€§ (ä¿æŒæµä½“æ„Ÿ)
            else if (buffs.pyro > 0) {
                 const bodyGrad = ctx.createRadialGradient(-r*0.3, -r*0.3, 0, 0, 0, r);
                 bodyGrad.addColorStop(0, '#f97316'); 
                 bodyGrad.addColorStop(1, '#9a3412'); 
                 ctx.fillStyle = bodyGrad;
                 ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI*2); ctx.fill();

                 // å†…éƒ¨æµåŠ¨çš„èƒ½é‡ (Internal Plasma)
                 ctx.save();
                 ctx.globalCompositeOperation = 'lighter'; 
                 ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.clip();
                 const time = this.lifeTime;
                 for(let i=0; i<2; i++) {
                    ctx.save();
                    const dir = i===0 ? 1 : -1;
                    const speed = i===0 ? 1.0 : 0.6;
                    ctx.rotate(time * speed * dir);
                    const plasmaGrad = ctx.createRadialGradient(r*0.4, 0, 0, r*0.4, 0, r*0.8);
                    if (i===0) {
                        plasmaGrad.addColorStop(0, 'rgba(253, 224, 71, 0.5)'); 
                        plasmaGrad.addColorStop(1, 'rgba(253, 224, 71, 0)');
                    } else {
                        plasmaGrad.addColorStop(0, 'rgba(251, 146, 60, 0.4)'); 
                        plasmaGrad.addColorStop(1, 'rgba(251, 146, 60, 0)');
                    }
                    ctx.fillStyle = plasmaGrad;
                    ctx.beginPath();
                    ctx.ellipse(r*0.2, 0, r*0.9, r*0.6, 0, 0, Math.PI*2);
                    ctx.fill();
                    ctx.restore();
                 }
                 ctx.restore();
                 
                 // çƒ­æµªè¾¹ç¼˜
                 const pulse = (Math.sin(this.lifeTime * 3) + 1) / 2;
                 const heatSize = 1.05 + (buffs.pyro * 0.05) + (pulse * 0.05);
                 const heatGrad = ctx.createRadialGradient(0, 0, r, 0, 0, r * heatSize);
                 heatGrad.addColorStop(0, 'rgba(249, 115, 22, 0.5)');
                 heatGrad.addColorStop(1, 'rgba(249, 115, 22, 0)');
                 ctx.fillStyle = heatGrad;
                 ctx.beginPath(); ctx.arc(0, 0, r * heatSize, 0, Math.PI*2); ctx.fill();

            } else {
                 // ... (å…¶ä»–æ™®é€š/å½©è™¹/å¥—å¨ƒå¼¹ç é€»è¾‘ä¿æŒä¸å˜) ...
                 let baseLight = '#f8fafc';
                 let baseDark = '#334155';
                 
                 if (this.def.type === 'rainbow') {
                     const grad = ctx.createLinearGradient(-r, -r, r, r);
                     grad.addColorStop(0, '#fca5a5'); grad.addColorStop(0.5, '#facc15'); grad.addColorStop(1, '#60a5fa');
                     ctx.fillStyle = grad; 
                     ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 2); ctx.fill();
                 } 
                 else if (this.def.type === 'matryoshka') {
                     baseLight = '#f5d0fe'; baseDark = '#86198f';
                     this._drawBaseBall(ctx, r, baseLight, baseDark);
                     ctx.strokeStyle = 'rgba(255,255,255,0.5)'; ctx.lineWidth = 1;
                     ctx.beginPath(); ctx.arc(0, 0, r-2, 0, Math.PI*2); ctx.stroke();
                 } 
                 else {
                     const map = {
                         'bounce': ['#dcfce7', '#15803d'],
                         'pierce': ['#fee2e2', '#b91c1c'],
                         'scatter': ['#fef9c3', '#a16207'],
                         'damage': ['#f3e8ff', '#7e22ce'],
                         'laser':  ['#e0f2fe', '#0369a1'],
                         // 'redStripe' å·²ç»è¢«ä¸Šé¢å•ç‹¬å¤„ç†äº†ï¼Œè¿™é‡Œä¸éœ€è¦ map
                     };
                     if (this.def.subtype && map[this.def.subtype]) {
                         baseLight = map[this.def.subtype][0]; 
                         baseDark = map[this.def.subtype][1];
                     } else if (this.def.type && map[this.def.type]) {
                         baseLight = map[this.def.type][0];
                         baseDark = map[this.def.type][1];
                     }
                     this._drawBaseBall(ctx, r, baseLight, baseDark);
                 }
            }
            
            // ç»˜åˆ¶é¡¶éƒ¨é«˜å…‰ (é™¤äº†çˆ†ç ´å¼¹ï¼Œå› ä¸ºçˆ†ç ´å¼¹å·²ç»æœ‰æ ¸å¿ƒé«˜å…‰äº†)
            if (this.def.type !== 'redStripe') {
                this._drawHighlight(ctx, r);
            }

            // ==========================================
            //  LAYER 3: â„ï¸ Cryo (Overlay)
            // ==========================================
            if (buffs.cryo > 0) {
                // ... (ä¿æŒåŸæœ‰çš„å†°éœœç»˜åˆ¶é€»è¾‘) ...
                const alpha = 0.2 + (buffs.cryo * 0.12);
                const iceGrad = ctx.createRadialGradient(-r*0.4, -r*0.4, r*0.1, 0, 0, r);
                iceGrad.addColorStop(0, `rgba(255, 255, 255, ${alpha})`);
                iceGrad.addColorStop(1, `rgba(165, 243, 252, ${alpha * 1.2})`);
                ctx.fillStyle = iceGrad;
                ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 2); ctx.fill();
                ctx.globalCompositeOperation = 'overlay';
                ctx.fillStyle = `rgba(255, 255, 255, ${Math.min(0.6, alpha)})`;
                for(let i=0; i<3; i++) {
                     const angle = (this.visualSeed + i * 2.5 + this.lifeTime * 0.02) % (Math.PI*2);
                     const dist = r * 0.6;
                     ctx.beginPath(); ctx.arc(Math.cos(angle)*dist, Math.sin(angle)*dist, r*0.25, 0, Math.PI*2); ctx.fill();
                }
                ctx.globalCompositeOperation = 'source-over';
            }

            // ==========================================
            //  LAYER 4: âš¡ Lightning (Top Effect)
            // ==========================================
            if (buffs.lightning > 0) {
                 // ... (ä¿æŒåŸæœ‰çš„é—ªç”µç»˜åˆ¶é€»è¾‘) ...
                ctx.save();
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.globalCompositeOperation = 'lighter'; 
                const triggerChance = 0.2 + (buffs.lightning * 0.15);
                if (Math.random() < triggerChance) {
                    const arcCount = 1 + Math.floor(Math.random() * (buffs.lightning * 0.6));
                    ctx.shadowBlur = 10 + buffs.lightning * 3; 
                    ctx.shadowColor = '#a855f7'; 
                    ctx.strokeStyle = '#e9d5ff'; 
                    for (let k = 0; k < arcCount; k++) {
                        const startAngle = Math.random() * Math.PI * 2;
                        const arcLen = 0.8 + Math.random() * 0.8; 
                        ctx.beginPath();
                        const segments = 4 + Math.floor(Math.random() * 3);
                        for (let i = 0; i <= segments; i++) {
                            const t = i / segments;
                            const currentAngle = startAngle + t * arcLen;
                            const jitter = (Math.random() - 0.5) * (r * 0.4); 
                            const dist = r * 1.25 + jitter; 
                            const px = Math.cos(currentAngle) * dist;
                            const py = Math.sin(currentAngle) * dist;
                            if (i === 0) ctx.moveTo(px, py);
                            else ctx.lineTo(px, py);
                        }
                        ctx.lineWidth = 1.0 + Math.random() * 1.5;
                        ctx.stroke();
                    }
                    if (Math.random() < 0.3) {
                        ctx.fillStyle = 'rgba(216, 180, 254, 0.4)'; 
                        ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI*2); ctx.fill();
                    }
                }
                ctx.restore();
            }
            
            ctx.restore();
        }

   _drawBaseBall(ctx, r, cLight, cDark) {
            const grad = ctx.createRadialGradient(-r*0.3, -r*0.3, r*0.1, 0, 0, r);
            grad.addColorStop(0, cLight);
            grad.addColorStop(1, cDark);
            ctx.fillStyle = grad;
            ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 2); ctx.fill();
        }

        _drawHighlight(ctx, r) {
            ctx.beginPath();
            ctx.ellipse(-r*0.35, -r*0.35, r*0.3, r*0.2, Math.PI/4, 0, Math.PI*2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.fill();
        }
	}

class Enemy {
    constructor(x, y, width, height, hp, maxHp = hp, type = 'normal', affixes = []) {
        this.pos = new Vec2(x, y); 
        this.width = width; 
        this.height = height; 
        this.hp = hp;       
        this.maxHp = maxHp; 

        // --- [æ–°å¢/ä¿®æ”¹] è¡€æ¡åŠ¨ç”»ç›¸å…³ ---
        this.displayHp = this.hp;      // çœŸå®è¡€æ¡çš„æ˜¾ç¤ºå€¼ (å¹³æ»‘è¿‡æ¸¡)
        this.delayedHp = this.hp;      // ç™½è‰²å»¶è¿Ÿè¡€æ¡çš„å€¼
        this.whiteBarTimer = 0;        // å»¶è¿Ÿç¼“å†²è®¡æ—¶å™¨

        this.hpDropTimer = 0;
        this.active = true; 
        this.type = type;
        this.affixes = affixes;
        this.hitTimer = 0; 
        this.dropTargetY = y; 
        this.justSpawned = true; 
        this.temp = 0; 
        this.bumpOffsetY = 0; 
        this.isFrozenCurrentTurn = false; 

        // è§†è§‰ç§å­
        this.visualSeed = Math.random(); 
        
        // --- [æ ¸å¿ƒä¿®æ”¹] ç”Ÿæˆé«˜çº§æ–­è£‚çº¹è·¯ (Fissures) ---
        // ä¸å†æ˜¯ä¸­å¿ƒè¾å°„ï¼Œè€Œæ˜¯ç”Ÿæˆè´¯ç©¿èº«ä½“çš„éšæœºæŠ˜çº¿
        this.fissures = [];
        const crackCount = 3; // è£‚çº¹æ•°é‡
        
        for(let i=0; i<crackCount; i++) {
            const points = [];
            // 1. éšæœºèµ·ç‚¹ (åœ¨è¾¹ç•Œä¸Š)
            const angle = Math.random() * Math.PI * 2;
            // åŠå¾„ç•¥å°äºå®½çš„ä¸€åŠï¼Œä¿è¯åœ¨èº«ä½“å†…éƒ¨
            const startDist = (width/2) * 0.8; 
            const start = new Vec2(Math.cos(angle) * startDist, Math.sin(angle) * startDist);
            points.push(start);
            
            // 2. éšæœºç»ˆç‚¹ (åœ¨å¯¹é¢)
            // è§’åº¦åç§» 120~240åº¦ï¼Œä¿è¯è£‚çº¹æ˜¯æ¨ªç©¿çš„
            const endAngle = angle + Math.PI + (Math.random() - 0.5); 
            const endDist = (width/2) * 0.8;
            const end = new Vec2(Math.cos(endAngle) * endDist, Math.sin(endAngle) * endDist);
            
            // 3. ç”Ÿæˆ 2-3 ä¸ªä¸­é—´æ–­ç‚¹ (Jitter Nodes)
            // æ¨¡æ‹Ÿå²©çŸ³/å†°å±‚ä¸è§„åˆ™çš„å—åŠ›æ–­è£‚
            const steps = 3;
            for(let j=1; j<steps; j++) {
                const t = j / steps;
                // çº¿æ€§æ’å€¼ä½ç½®
                const lerpX = start.x + (end.x - start.x) * t;
                const lerpY = start.y + (end.y - start.y) * t;
                
                // å‚ç›´äºè·¯å¾„æ–¹å‘çš„éšæœºæ‰°åŠ¨
                const jitter = (Math.random() - 0.5) * (width * 0.4); 
                
                points.push(new Vec2(lerpX + jitter, lerpY + jitter));
            }
            points.push(end);
            this.fissures.push(points);
        }

        this.hasActedThisTurn = false;
        this.scanFeedbackTimer = 0;
    }
    
    update(timeScale) {
        if (!this.active) return;
        // ç§»åŠ¨é€»è¾‘ï¼šå¸é™„ç›®æ ‡ä½ç½®
        if (this.pos.y < this.dropTargetY) {
            this.pos.y += 3 * timeScale;
            if (this.pos.y > this.dropTargetY) this.pos.y = this.dropTargetY;
        }
        
        if (this.hitTimer > 0) this.hitTimer -= timeScale;
        if (this.justSpawned) { this.justSpawned = false; }
        
        // å¼¹è·³æ¢å¤
        if (this.bumpOffsetY < 0) {
            this.bumpOffsetY += 1 * timeScale;
            if (this.bumpOffsetY > 0) this.bumpOffsetY = 0;
        } else if (this.bumpOffsetY > 0) { // å¢åŠ å‘ä¸‹å›å¼¹çš„é€»è¾‘(å†°å†»æ—¶)
            this.bumpOffsetY -= 1 * timeScale;
            if (this.bumpOffsetY < 0) this.bumpOffsetY = 0;
        }
        // 1. çœŸå®è¡€æ¡å¹³æ»‘è¿‡æ¸¡ (ä¿æŒåŸé€»è¾‘)
        // this.displayHp = lerp(this.displayHp, this.hp, 0.2);

        
        // è¡€é‡æ»šåŠ¨
        if (this.displayHp > this.hp) {
            const diff = this.displayHp - this.hp;
            if (diff > 20) {
                this.displayHp -= diff * 0.2 * timeScale;
                this.hpDropTimer = 0;
            } else {
                this.hpDropTimer += timeScale;
                if (this.hpDropTimer >= Math.max(1, 5 - Math.floor(diff / 5))) {
                    this.hpDropTimer = 0;
                    this.displayHp -= 1;
                }
            }
            if (this.displayHp < this.hp) this.displayHp = this.hp;
        } else {
            this.displayHp = this.hp;
            this.hpDropTimer = 0;
        }

        // 2. ç™½è‰²å»¶è¿Ÿè¡€æ¡é€»è¾‘
        if (this.whiteBarTimer > 0) {
            // å¦‚æœè¿˜åœ¨ç¼“å†²æœŸï¼ˆåˆšå—è¿‡ä¼¤ï¼‰ï¼Œç™½è‰²è¡€æ¡ä¸åŠ¨ï¼Œä¿æŒåœ¨æ—§çš„é«˜ä½
            this.whiteBarTimer--;
        } else {
            // ç¼“å†²ç»“æŸï¼Œç™½è‰²è¡€æ¡å¿«é€Ÿè¿½èµ¶å½“å‰è¡€é‡
            if (this.delayedHp > this.displayHp) {
                // è¿½èµ¶é€Ÿåº¦æ¯” displayHp å¿«ï¼Œäº§ç”Ÿ"å´©å¡Œ"æ„Ÿ
                this.delayedHp = lerp(this.delayedHp, this.displayHp, 0.25);
                
                // é˜ˆå€¼ä¿®æ­£ï¼Œé˜²æ­¢æ— é™é€¼è¿‘
                if (Math.abs(this.delayedHp - this.displayHp) < 0.1) {
                    this.delayedHp = this.displayHp;
                }
            }
        }
        
        // ç¡®ä¿ç™½è‰²è¡€æ¡ä¸ä¼šä½äºçœŸå®è¡€æ¡ (æ¯”å¦‚æ²»ç–—æ—¶)
        if (this.delayedHp < this.displayHp) {
            this.delayedHp = this.displayHp;
        }
        this.updateTempParticles(timeScale);
    }

    /**
     * @method updateTempParticles
     * @description å¤„ç†éšæ¸©åº¦äº§ç”Ÿçš„æŒç»­ç²’å­ (Mistå·¨å‹åŒ–ç‰ˆ)
     */
    updateTempParticles(timeScale) {
        const absTemp = Math.abs(this.temp);
        if (!this.active || this.pos.y > game.height) return;

        // === ğŸ”¥ é«˜æ¸©ç‰¹æ•ˆ (Heat) ===
        if (this.temp >= 34) {
            
            // 1.  ç‡ƒçƒ§å‰çš„é»‘çƒŸ -> æ”¹ä¸º Mist (æ¨¡æ‹Ÿçƒ­æµª/è’¸æ±½)
            // æ¦‚ç‡éšæ¸©åº¦å‡é«˜
            if (Math.random() < (0.05 + (this.temp / 200)) * timeScale) {
                const spawnX = this.pos.x + (Math.random() - 0.5) * this.width * 0.8;
                const spawnY = this.pos.y - this.height * 0.4;
                
                // é¢œè‰²ï¼šä½¿ç”¨çº¯é»‘è‰²ï¼Œå¸¦ä¸€ç‚¹é€æ˜åº¦
                // å¿…é¡»åŒ…å« '0,0,0' ä»¥ä¾¿è®© Particle.draw è¯†åˆ«å¹¶å…³é—­æ··åˆæ¨¡å¼
                const smokeColor = `rgba(0, 0, 0, ${0.4 + Math.random() * 0.3})`;
                
                const heatSmoke = new Particle(spawnX, spawnY, smokeColor, 'mist');
                heatSmoke.vel.y = -0.8 - Math.random() * 0.8; // ä¸Šå‡é€Ÿåº¦ç¨å¿«
                heatSmoke.vel.x = (Math.random() - 0.5) * 0.5; // ç¨å¾®å·¦å³é£˜
                heatSmoke.size = this.width * 0.35; // å¤§å›¢çƒŸé›¾
                game.particles.push(heatSmoke);
            }

            // 2.  ç‡ƒçƒ§æ—¶çš„é»‘çƒŸ -> æ”¹ä¸º Ember (ç‡ƒçƒ§çš„ä½™çƒ¬/ç«æ˜Ÿ)
            if (this.temp >= 100) {
                const count = Math.ceil((this.temp - 90) / 20); 
                for(let i=0; i<count; i++) {
                    if(Math.random() < 0.4 * timeScale) {
                        // ä½ç½®ï¼šå…¨èº«éšæœºå†’å‡º
                        const px = this.pos.x + (Math.random() - 0.5) * this.width;
                        const py = this.pos.y + (Math.random() - 0.5) * this.height;
                        
                        // é¢œè‰²ï¼šäº®æ©™è‰²/é‡‘è‰²
                        // ç±»å‹ï¼š'ember' (ä¸€ç§é£˜å¿½ä¸å®šçš„ç«æ˜Ÿ)
                        // æ³¨æ„ï¼šç¡®ä¿ Particle ç±»èƒ½å¤„ç† 'ember'ï¼Œé€šå¸¸ 'ember' å’Œ 'spark' ç±»ä¼¼ä½†æ›´è½»
                        // è¿™é‡Œæˆ‘ä»¬ç›´æ¥ç”¨ 'spark' çš„ç‰©ç†é€»è¾‘ï¼Œä½†é¢œè‰²è°ƒå¾—æ›´äº®
                        game.createParticle(px, py, '#fbbf24', 'spark'); 
                        
                        // å¶å°”åŠ ä¸€ä¸ªé¢œè‰²æ·±ä¸€ç‚¹çš„ 'ember' é¢—ç²’
                         if (Math.random() < 0.3) {
                            game.createParticle(px, py, '#f97316', 'ember');
                        }
                    }
                }
            }
        }

        // === â„ï¸ ä½æ¸©ç‰¹æ•ˆ (Cold) - (ä¿æŒä¹‹å‰çš„ Mist ä¼˜åŒ–é€»è¾‘) ===
        if (this.temp <= -34) {
            const freezeIntensity = (absTemp - 34) / 66; 
            const sizeFactor = this.width / 100; 
            const baseChance = 0.2 * sizeFactor;  
            const mistChance = (baseChance + freezeIntensity * 0.2);

            let chancePool = mistChance * timeScale;
            while(chancePool > 0) {
                if (Math.random() < chancePool) {
                    const spawnX = this.pos.x + (Math.random() - 0.5) * this.width * 0.9;
                    const spawnY = this.pos.y + (Math.random() - 0.2) * this.height; 
                    
                    // è¿™é‡Œçš„ mist æ˜¯ç™½è‰²çš„å†·æ°”
                    const mist = new Particle(spawnX, spawnY, null, 'mist');
                    mist.size = this.width * (0.15 + Math.random() * 0.1); 
                    mist.size *= (1 + freezeIntensity * 0.2);
                    mist.vel = new Vec2((Math.random() - 0.5) * 0.3, 0.8 + Math.random() * 0.5); // ä¸‹æ²‰
                    mist.decay *= 1.5; 
                    game.particles.push(mist);
                }
                chancePool -= 1.0; 
            }
            
            if (this.temp <= -80 && Math.random() < 0.08 * timeScale) {
                const shard = new Particle(this.pos.x + (Math.random() - 0.5) * this.width, this.pos.y, '#a5f3fc', 'shard');
                shard.size = 2.5; 
                game.particles.push(shard);
            }
        }
    }

    advance(amount) { this.dropTargetY += amount; }

    // --- æ›¿æ¢ Enemy ç±»çš„ performTurnActionAndMove æ–¹æ³• ---

    performTurnActionAndMove(gameInstance) {
        const afx=CONFIG.balance.affixes
        let actionCount = 1;
        if (this.affixes.includes('haste')) actionCount = 2;
        else if (this.temp > 0 && this.temp < 100 && this.affixes.includes('berserk')) {
            if (Math.random() < (this.temp / 100) * afx.berserkChanceMult) actionCount = 2;
        }

        if (this.isFrozenCurrentTurn) {
            actionCount = 0;
            this.playFreezeBlockEffect(gameInstance);
        }

        for (let i = 0; i < actionCount; i++) {
            const isSecondAction = (i === 1);
            
            // --- 1. å†ç”Ÿ (Regen) ---
            if(this.affixes.includes('regen')) {
                const heal = Math.floor(this.maxHp * afx.regenPercent) || 1;
                if(this.hp < this.maxHp) {
                    this.hp = Math.min(this.maxHp, this.hp + heal);
                    gameInstance.createFloatingText(this.pos.x, this.pos.y - 30, `+${heal}`, '#4ade80');
                    gameInstance.createParticle(this.pos.x, this.pos.y, '#4ade80', 'spark');
                    audio.playEffect('regen');
                }
            }

            // --- 2. ç¯„åœæ²»ç™‚ (Healer) [æ–°å¢] ---
            if (this.affixes.includes('healer')) {
                // å®šç¾©ç¯„åœï¼šè‡ªèº«å¯¬åº¦çš„ 1.5 å€ (å¤§ç´„è¦†è“‹å‘¨åœ 8 æ ¼)
                const range = this.width * afx.healerRange;
                let healedCount = 0;
                
                gameInstance.enemies.forEach(other => {
                    if (other !== this && other.active && other.hp < other.maxHp && this.pos.dist(other.pos) < range) {
                            const healAmt = Math.ceil(other.maxHp * afx.healerPercent); // [ä¿®æ”¹]
                    
                        other.hp = Math.min(other.maxHp, other.hp + healAmt);
                        
                        // ç‰¹æ•ˆï¼šç™¼å°„æ²»ç™‚ç²’å­é£›å‘éšŠå‹
                        gameInstance.createParticle(other.pos.x, other.pos.y, '#f472b6', 'spark'); // ç²‰è‰²ç²’å­
                        gameInstance.createFloatingText(other.pos.x, other.pos.y - 20, `+${healAmt}`, '#f472b6');
                        healedCount++;
                    }
                });
                
                if (healedCount > 0) {
                     audio.playEffect('regen'); // å¾©ç”¨æ²»ç™‚éŸ³æ•ˆ
                     gameInstance.createShockwave(this.pos.x, this.pos.y, '#f472b6'); // è‡ªèº«ç²‰è‰²æ³¢å‹•
                }
            }

            // --- 3. åå™¬ (Devour) [æ–°å¢] ---
            // 50% æ¦‚ç‡è§¸ç™¼ï¼Œä¸”å¿…é ˆä¸æ˜¯æ»¿è¡€æˆ–è€…æƒ³ç²å–è©æ¢
            if (this.affixes.includes('devour') && Math.random() < afx.devourChance) {
                     const range = this.width * afx.devourRange;
                 // å°‹æ‰¾é„°å±… (ä¸èƒ½åå™¬ Boss)
                 const neighbors = gameInstance.enemies.filter(e => 
                     e !== this && e.active && e.type !== 'boss' && this.pos.dist(e.pos) < range
                 );

                 if (neighbors.length > 0) {
                     const victim = neighbors[Math.floor(Math.random() * neighbors.length)];
                     
                     // åå™¬æ•¸å€¼
                     const absorbHp = victim.hp;
                     const absorbMax = victim.maxHp;
                     
                     this.maxHp += absorbMax;
                     this.hp += absorbHp;
                     
                     // åå™¬è©æ¢ (å»é‡)
                     victim.affixes.forEach(af => {
                         if (!this.affixes.includes(af)) this.affixes.push(af);
                     });
                     
                     // è™•æ±ºå—å®³è€…
                     victim.hp = 0;
                     victim.active = false;
                     
                     // ç‰¹æ•ˆ
                     gameInstance.createFloatingText(this.pos.x, this.pos.y - 40, "DEVOUR!", "#ef4444");
                     gameInstance.createParticle(victim.pos.x, victim.pos.y, '#ef4444', 'mist'); // è¡€éœ§
                     gameInstance.createShockwave(this.pos.x, this.pos.y, '#ef4444');
                     audio.playEffect('split'); // æ’­æ”¾åˆ†è£‚éŸ³æ•ˆæ¨¡æ“¬åå™¬è²
                 }
            }

            // --- 4. å¢æ®– (Clone) ---
            if(this.affixes.includes('clone') && Math.random() < afx.cloneChanceTurn) {
                    gameInstance.triggerCloneSpawn(this);
                }

            if (isSecondAction) {
                gameInstance.createFloatingText(this.pos.x, this.pos.y - 50, "âš¡DOUBLE!", "#facc15");
            }

            // --- ç§»å‹•èˆ‡è·³èºé‚è¼¯ ---
            let moveAmount = gameInstance.enemyHeight;
            const targetY = this.dropTargetY + moveAmount;
            
            // æª¢æŸ¥å‰æ–¹æ˜¯å¦è¢«é˜»æ“‹
            const isBlocked = gameInstance.isAreaOccupied(this.pos.x, targetY, this.width * 0.8, this.height * 0.8, this);

            if (!isBlocked) {
                // æ­£å¸¸ç§»å‹•
                this.advance(moveAmount);
            } else {
                // --- 5. è·³èº (Jump) [æ–°å¢] ---
                // å¦‚æœè¢«é˜»æ“‹ï¼Œä¸”æ“æœ‰ jump è©æ¢ï¼Œæª¢æŸ¥ä¸‹ä¸‹å€‹æ ¼å­
                if (this.affixes.includes('jump')) {
                    // [ä¿®æ”¹] è·³è·ƒè¡Œæ•° (jumpRows)
                    const jumpTargetY = this.dropTargetY + (moveAmount * afx.jumpRows);
                    const isJumpBlocked = gameInstance.isAreaOccupied(this.pos.x, jumpTargetY, this.width * 0.8, this.height * 0.8, this);
                    
                    if (!isJumpBlocked) {
                        // åŸ·è¡Œè·³èº
                        this.advance(moveAmount * 2);
                        this.bumpOffsetY = -30; // è¦–è¦ºä¸Šè·³å¾—æ›´é«˜
                        gameInstance.createFloatingText(this.pos.x, this.pos.y, "JUMP!", "#38bdf8");
                        gameInstance.createParticle(this.pos.x, this.pos.y, '#38bdf8', 'mist'); // æ®˜å½±
                    } else {
                        // è·³èºä¹Ÿè¢«é˜»æ“‹ï¼Œæ’ç‰†
                        if (i === 0) {
                            this.bumpOffsetY = -10;
                            if (Math.random() < 0.3) gameInstance.createFloatingText(this.pos.x, this.pos.y - 20, "â›” BLOCKED", "#ef4444");
                        }
                    }
                } else {
                    // æ²’æœ‰è·³èºè©æ¢ï¼Œæ­£å¸¸æ’ç‰†
                    if (i === 0) {
                        this.bumpOffsetY = -10;
                        if (Math.random() < 0.3) gameInstance.createFloatingText(this.pos.x, this.pos.y - 20, "â›” BLOCKED", "#ef4444");
                    }
                }
            }
        }
    }

    playFreezeBlockEffect(gameInstance) {
        this.bumpOffsetY = 6; 
        gameInstance.createFloatingText(this.pos.x, this.pos.y, "â„ï¸FROZEN", "#06b6d4");
        
        const mistCount = 4 + Math.floor(this.width / 15); 
        for(let i=0; i<mistCount; i++) {
            const spawnX = this.pos.x + (Math.random() - 0.5) * this.width * 0.8;
            const spawnY = this.pos.y + this.height * 0.4; 
            const mist = new Particle(spawnX, spawnY, null, 'mist');
            const dirX = (spawnX - this.pos.x) / (this.width/2); 
            mist.vel = new Vec2(dirX * 1.5, 1.0); 
            mist.size = this.width * 0.5; 
            mist.life = 1.5; 
            gameInstance.particles.push(mist);
        }
        for(let i=0; i<5; i++) {
            gameInstance.createParticle(this.pos.x + (Math.random()-0.5) * this.width, this.pos.y, '#a5f3fc', 'shard');
        }
    }

    playBurnTickEffect(gameInstance, dmg) {
        this.hitTimer = 15;
        for(let i=0; i<8; i++) gameInstance.createParticle(this.pos.x, this.pos.y, '#f97316', 'spark');
        for(let i=0; i<3; i++) gameInstance.createParticle(this.pos.x, this.pos.y, 'rgba(0,0,0,0.6)', 'smoke');
        gameInstance.createFloatingText(this.pos.x, this.pos.y, `ğŸ”¥-${dmg}`, '#fbbf24');
        audio.playEffect('burn_tick');
    }

    playScanFeedback() {
        this.scanFeedbackTimer = 1.0; 
    }

    // [æ ¸å¿ƒä¿®æ”¹] ç»˜åˆ¶æ–¹æ³•ï¼šä¿®å¤å†°å†»è§†è§‰è¿‡å¤§å’Œè¾¹ç¼˜ç²—ç³™é—®é¢˜
    draw(ctx) {
        if (!this.active) return;
        ctx.save(); 
        ctx.translate(this.pos.x, this.pos.y + this.bumpOffsetY);
        
        // éœ‡åŠ¨
        if (this.hitTimer > 0) { 
            const shake = this.hitTimer * 0.5; 
            ctx.translate((Math.random()-0.5)*shake, (Math.random()-0.5)*shake); 
        }
        
        const w = this.width - 4; 
        const h = this.height - 4; 
        const r = 6;

        // === Layer 1: å®¹å™¨è£å‰ª ===
        ctx.beginPath(); 
        ctx.roundRect(-w/2, -h/2, w, h, r);
        ctx.fillStyle = '#0f172a'; 
        ctx.fill(); 
        ctx.clip(); 

        // === Layer 2: æ¶²ä½“è¡€æ¡ (å«å»¶è¿Ÿç™½æ¡) ===
        
        // A. è®¡ç®—é«˜åº¦æ¯”ä¾‹
        const hpRatio = Math.max(0, Math.min(1, this.displayHp / this.maxHp));
        const whiteRatio = Math.max(0, Math.min(1, this.delayedHp / this.maxHp)); // ç™½è‰²æ¡æ¯”ä¾‹
        
        const fillHeight = h * hpRatio;
        const whiteHeight = h * whiteRatio; // ç™½è‰²æ¡é«˜åº¦
        
        const fillY = (h/2) - fillHeight;
        const whiteY = (h/2) - whiteHeight; // ç™½è‰²æ¡Yåæ ‡
        
        // B. ç»˜åˆ¶ç™½è‰²å»¶è¿Ÿæ¡ (åœ¨å½©è‰²æ¡åº•ä¸‹)
        // åªæœ‰å½“ delayedHp > displayHp æ—¶æ‰ç»˜åˆ¶ï¼Œé¿å…ä¸å¿…è¦çš„é‡ç»˜
        if (whiteRatio > hpRatio) {
            ctx.fillStyle = '#ffffff'; 
            // ç¨å¾®åŠ ä¸€ç‚¹é€æ˜åº¦ï¼Œä¸é‚£ä¹ˆåˆºçœ¼
            ctx.globalAlpha = 0.8;
            ctx.fillRect(-w/2, whiteY, w, whiteHeight);
            ctx.globalAlpha = 1.0;
        }

        // C. ç»˜åˆ¶çœŸå®å½©è‰²æ¡ (ç›–åœ¨ç™½æ¡ä¸Šé¢)
        let baseColor = '#475569'; 
        if (this.type === 'elite') baseColor = '#581c87'; 
        if (this.type === 'boss') baseColor = '#7f1d1d';  
        
        // æ¸©åº¦å˜è‰²é€»è¾‘
        if (this.temp > 0) {
            const t = Math.min(1, this.temp / 34);
            baseColor = lerpColor(baseColor, '#ea580c', t); 
        } else if (this.temp < 0) {
            const t = Math.min(1, Math.abs(this.temp) / 34);
            baseColor = lerpColor(baseColor, '#0891b2', t);
        }

        ctx.fillStyle = baseColor; 
        ctx.fillRect(-w/2, fillY, w, fillHeight);
        
        // D. æ¶²é¢äº®è¾¹ (ä¿æŒä¸å˜)
        if (hpRatio > 0 && hpRatio < 1) {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)'; 
            ctx.fillRect(-w/2, fillY, w, 2);
        }

        // === Layer 3: å†…éƒ¨è¦†ç›–å±‚ (Glow & Mist) - [ä¿®æ”¹ï¼šé™ä½æµ“åº¦] ===

        // **è¿‡çƒ­ Stage 3: å†…éƒ¨ç‚™çƒ­å‘å…‰**
        if (this.temp >= 67) {
            const glowAlpha = Math.min(0.6, (this.temp - 60) / 60);
            const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, w * 0.8);
            grad.addColorStop(0, `rgba(251, 146, 60, ${glowAlpha})`); 
            grad.addColorStop(1, `rgba(251, 146, 60, 0)`);
            ctx.fillStyle = grad;
            ctx.fillRect(-w/2, -h/2, w, h);
        }

        // **è¿‡å†· Stage 2~4: åŠ¨æ€é›¾åŒ–è’™å±‚ (Mist Overlay) - [å¤§å¹…ä¼˜åŒ–]**
        if (this.temp <= -34) {
            ctx.save();
            ctx.globalCompositeOperation = 'screen'; 
            
            // --- ä¿®æ”¹ç‚¹ï¼šå¤§å¹…é™ä½ä¸é€æ˜åº¦ ---
            let mistOpacity = 0;
            // å³ä½¿å®Œå…¨å†»ç»“ï¼Œé€æ˜åº¦æœ€é«˜ä¹Ÿåªæœ‰ 0.5 (åŸæ¥æ˜¯ 0.9)
            if (this.isFrozenCurrentTurn || this.temp <= -100) mistOpacity = 0.5;
            else mistOpacity = Math.min(0.4, (Math.abs(this.temp) - 30) / 70);

            const time = Date.now() / 2500; 

            // ç»˜åˆ¶æµ®åŠ¨é›¾å›¢ (ä¿æŒé€»è¾‘ï¼Œä½†é¢œè‰²æ›´æ·¡)
            const patchCount = 2; // å‡å°‘å±‚æ•°
            for(let i=0; i<patchCount; i++) {
                const seed = this.visualSeed * 100 + i;
                const offsetX = Math.sin(seed + time) * (w * 0.25);
                const offsetY = Math.cos(seed + time * 1.2) * (h * 0.25);
                // ç¨å¾®å‡å°é›¾å›¢å°ºå¯¸
                const size = w * (0.5 + Math.sin(time * 2 + i) * 0.1);

                const grad = ctx.createRadialGradient(offsetX, offsetY, 0, offsetX, offsetY, size);
                // é¢œè‰²å˜å¾—ææ·¡
                grad.addColorStop(0, `rgba(207, 250, 254, ${mistOpacity * 0.4})`); 
                grad.addColorStop(1, `rgba(207, 250, 254, 0)`);
                
                ctx.fillStyle = grad;
                ctx.beginPath(); ctx.arc(offsetX, offsetY, size, 0, Math.PI*2); ctx.fill();
            }

            // å…¨èº«è–„éœœ (é™ä½æµ“åº¦)
            ctx.fillStyle = `rgba(165, 243, 252, ${mistOpacity * 0.15})`;
            ctx.fillRect(-w/2, -h/2, w, h);
            ctx.restore();
        }

        // === Layer 4: è£‚çº¹ç»˜åˆ¶ (Fissures) - [ä¿æŒä¸å˜] ===

        // **è¿‡çƒ­ Stage 3**
        if (this.temp >= 67) {
            const crackAlpha = Math.min(1, (this.temp - 60) / 40);
            ctx.save();
            ctx.globalCompositeOperation = 'lighter'; 
            ctx.strokeStyle = `rgba(255, 255, 255, ${crackAlpha * 0.9})`;
            ctx.shadowColor = '#f97316'; ctx.shadowBlur = 10; ctx.lineWidth = 1.5; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
            this.fissures.forEach(path => {
                if (path.length < 2) return;
                ctx.beginPath(); ctx.moveTo(path[0].x, path[0].y);
                for(let i=1; i<path.length; i++) ctx.lineTo(path[i].x, path[i].y);
                ctx.stroke();
            });
            ctx.restore();
        }

        // **è¿‡å†· Stage 4**
        if (this.temp <= -67 || this.isFrozenCurrentTurn) {
            const crackAlpha = this.isFrozenCurrentTurn ? 0.8 : Math.min(0.6, (Math.abs(this.temp) - 60) / 40);
            ctx.save();
            ctx.globalCompositeOperation = 'overlay';
            ctx.strokeStyle = `rgba(255, 255, 255, ${crackAlpha})`;
            ctx.lineWidth = 1.5; ctx.lineCap = 'round'; ctx.lineJoin = 'bevel';
            this.fissures.forEach(path => {
                if (path.length < 2) return;
                ctx.beginPath(); ctx.moveTo(path[0].x, path[0].y);
                for(let i=1; i<path.length; i++) ctx.lineTo(path[i].x, path[i].y);
                ctx.stroke();
            });
            ctx.restore();
        }

        // === Layer 5: å†…éƒ¨è¾¹æ¡† (ä¿æŒä¸å˜) ===
        ctx.strokeStyle = '#334155'; ctx.lineWidth = 2;
        if (this.type === 'elite') { ctx.strokeStyle = '#facc15'; ctx.lineWidth = 3; }
        if (this.type === 'boss') { ctx.strokeStyle = '#ef4444'; ctx.lineWidth = 4; }
        ctx.strokeRect(-w/2, -h/2, w, h);

        // æ–‡å­—ä¸å›¾æ ‡
        if (this.affixes.length > 0) {
            ctx.fillStyle = '#fff'; ctx.font = '10px sans-serif';
            let icons = '';
            if(this.affixes.includes('shield')) icons += 'ğŸ›¡ï¸';
            if(this.affixes.includes('haste')) icons += 'âš¡';
            if(this.affixes.includes('regen')) icons += 'ğŸ’š';
            if(this.affixes.includes('clone')) icons += 'ğŸ¦ ';
            if(this.affixes.includes('berserk')) icons += 'ğŸ˜¡';
            if(this.affixes.includes('healer')) icons += 'ğŸ’–';
    if(this.affixes.includes('devour')) icons += 'ğŸ‘…';
    if(this.affixes.includes('jump')) icons += 'ğŸ¦˜';
            ctx.textAlign = 'center'; ctx.fillText(icons, 0, -h/2 + 8);
        }
        if (!this.isFrozenCurrentTurn) {
            ctx.fillStyle = '#fff'; ctx.font = 'bold 14px sans-serif'; 
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; 
            if (this.displayHp > this.hp + 1) ctx.fillStyle = '#fca5a5';
            ctx.fillText(Math.ceil(this.displayHp), 0, 2);
        }
        
        // å—å‡»é—ªç™½
        if (this.hitTimer > 0) {
            ctx.fillStyle = `rgba(255, 255, 255, ${this.hitTimer / 10 * 0.6})`;
            ctx.fillRect(-w/2, -h/2, w, h);
        }

        ctx.restore(); // <--- è£å‰ªç»“æŸ

        // === Layer 6: å¤–éƒ¨ç‰¹æ•ˆ (å…‰ç¯/å†°å£³) ===

        // **è¿‡çƒ­ Stage 4: ç‚™çƒ­å‘å…‰è¾¹æ¡†**
        if (this.temp >= 100) {
            ctx.save();
            ctx.translate(this.pos.x, this.pos.y + this.bumpOffsetY);
            const pulse = (Math.sin(Date.now() / 200) + 1) * 0.5;
            ctx.shadowColor = '#f97316';
            ctx.shadowBlur = 15 + pulse * 10;
            ctx.strokeStyle = `rgba(251, 146, 60, ${0.6 + pulse * 0.4})`;
            ctx.lineWidth = 3;
            ctx.beginPath(); ctx.roundRect(-w/2 - 2, -h/2 - 2, w + 4, h + 4, r); ctx.stroke();
            ctx.restore();
        }

        // **è¿‡å†· Stage 4: å†°å°å¤–å£³ - [æ ¸å¿ƒä¿®æ”¹ï¼šæ™¶ä½“å†°å—]**
        if (this.temp <= -100 || this.isFrozenCurrentTurn) {
            ctx.save();
            ctx.translate(this.pos.x, this.pos.y + this.bumpOffsetY);
            
            // --- 1. ç»˜åˆ¶å†°å—è½®å»“ (ç¡¬æœ—çš„å¤šè¾¹å½¢) ---
            const borderW = w + 8;
            const borderH = h + 8;
            
            // ä½¿ç”¨ bevel è¿æ¥ï¼Œäº§ç”Ÿç¡¬è§’ï¼Œä¸ä½¿ç”¨ spike æ­£å¼¦æ³¢
            ctx.lineJoin = 'bevel'; 
            ctx.lineWidth = 2;
            
            // å†°çš„é¢œè‰²ï¼šè¾¹æ¡†äº®ç™½/é’ï¼Œå†…éƒ¨åŠé€æ˜
            ctx.strokeStyle = 'rgba(207, 250, 254, 0.9)'; // äº®é’ç™½
            ctx.fillStyle = 'rgba(165, 243, 252, 0.25)';  // å†…éƒ¨æ·¡æ·¡çš„å†»ç»“æ„Ÿ
            
            // ç»™æ•´ä¸ªå†°å—åŠ ä¸€ç‚¹å‘å…‰
            ctx.shadowColor = '#06b6d4';
            ctx.shadowBlur = 10;

            ctx.beginPath();
            // å·¦ä¸Šè§’ (åˆ‡è§’)
            ctx.moveTo(-borderW/2 + 5, -borderH/2);
            // å³ä¸Šè§’
            ctx.lineTo(borderW/2 - 2, -borderH/2);
            ctx.lineTo(borderW/2, -borderH/2 + 5);
            // å³ä¸‹è§’
            ctx.lineTo(borderW/2, borderH/2 - 3);
            ctx.lineTo(borderW/2 - 5, borderH/2);
            // å·¦ä¸‹è§’
            ctx.lineTo(-borderW/2 + 2, borderH/2);
            ctx.lineTo(-borderW/2, borderH/2 - 5);
            // å›åˆ°å·¦ä¸Š
            ctx.lineTo(-borderW/2, -borderH/2 + 5);
            ctx.closePath();
            
            ctx.fill();
            ctx.stroke();

            // --- 2. ç»˜åˆ¶å†°é¢åå…‰ (Glossy Highlight) ---
            // åœ¨å†°å—è¡¨é¢ç”»ä¸¤é“æ–œç€çš„äº®å…‰ï¼Œå¢åŠ è´¨æ„Ÿ
            ctx.shadowBlur = 0; // åå…‰ä¸éœ€è¦å‘å…‰
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            // æ–œçº¿ 1
            ctx.moveTo(-w/4, -h/2);
            ctx.lineTo(-w/2, -h/4);
            // æ–œçº¿ 2
            ctx.moveTo(w/4, h/2);
            ctx.lineTo(w/2, h/4);
            ctx.stroke();

            ctx.restore();
        }

        // === Layer 7: æ‰«æåé¦ˆ (ä¿æŒä¸å˜) ===
        if (this.scanFeedbackTimer > 0) {
            this.scanFeedbackTimer -= 0.05;
            const alpha = Math.max(0, this.scanFeedbackTimer);
            const expand = (1.0 - alpha) * 10;
            const bracketSize = 10;
            const hw = this.width / 2 + 4 + expand;
            const hh = this.height / 2 + 4 + expand;
            ctx.save();
            ctx.translate(this.pos.x, this.pos.y + this.bumpOffsetY);
            ctx.shadowColor = '#fff'; ctx.shadowBlur = 10;
            ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`; ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-hw, -hh + bracketSize); ctx.lineTo(-hw, -hh); ctx.lineTo(-hw + bracketSize, -hh);
            ctx.moveTo(hw - bracketSize, -hh); ctx.lineTo(hw, -hh); ctx.lineTo(hw, -hh + bracketSize);
            ctx.moveTo(hw, hh - bracketSize); ctx.lineTo(hw, hh); ctx.lineTo(hw - bracketSize, hh);
            ctx.moveTo(-hw + bracketSize, hh); ctx.lineTo(-hw, hh); ctx.lineTo(-hw, hh - bracketSize);
            ctx.stroke();
            ctx.restore();
        }
    }

    takeDamage(amount) {
        this.hp -= amount;
        this.hitTimer = 10; 
        
        // ---  é‡ç½®ç™½è‰²è¡€æ¡çš„æ»ç•™æ—¶é—´ ---
        // è®¾å®šä¸º 45 å¸§ (çº¦ 0.75ç§’)ï¼Œè¿™æ®µæ—¶é—´å†…ç™½è‰²è¡€æ¡ä¸ä¼šå‡å°‘
        this.whiteBarTimer = 45; 

        if (this.hp <= 0) {
            this.active = false;
            return true;
        }
        return false;
    }
    applyTemp(amount) { this.temp += amount; }
    getBounds() { return { left: this.pos.x - this.width/2, right: this.pos.x + this.width/2, top: this.pos.y - this.height/2, bottom: this.pos.y + this.height/2 }; }
}

class Projectile {
    constructor(x, y, vel, config, isCopy = false) {
        this.pos = new Vec2(x, y);
        this.vel = new Vec2(vel.x, vel.y);
        this.config = config;
        
        // --- 1. ä½¿ç”¨ç»Ÿä¸€çš„å…¬å¼è®¡ç®—åŠå¾„ ---
        const params = Projectile.calculateVisualParams(config, isCopy);
        this.radius = params.radius; 
        this.intensity = params.intensity; // å­˜å‚¨å…‰æ™•å¼ºåº¦ä¾› update ä½¿ç”¨

        this.active = true;
        this.isCopy = isCopy;
        this.bouncesLeft = config.bounce || 0;
        this.piercesLeft = config.pierce || 0;
        this.maxDurability = (this.maxBounces + this.maxPierces) || 1;

        this.hitCooldowns = new Map();
        this.destroyed = false;
        this.lifeTime = 60 * 15;
        this.chainHistory = [];

        // è§†è§‰ç›¸å…³
        this.trail = []; 
        this.rotation = 0;
        
        // ç‰©ç†å˜å½¢åˆå§‹åŒ–
        this.deformation = { x: 1, y: 1 }; 
        this.targetDeformation = { x: 1, y: 1 }; 
        this.elasticity = 0.2;

        this.crackSeed = [];
        for(let i=0; i<3; i++) {
            this.crackSeed.push({
                angle: Math.random() * Math.PI * 2,
                len: 0.3 + Math.random() * 0.4, // è£‚çº¹é•¿åº¦æ¯”ä¾‹
                jagged: (Math.random() - 0.5) * 0.5 // è£‚çº¹æ›²æŠ˜åº¦
            });
        }

    }

    /**
     * ç»Ÿä¸€è®¡ç®—è§†è§‰å‚æ•° (å°ºå¯¸ã€å…‰æ™•)
     */
    static calculateVisualParams(config, isCopy) {
        const v = CONFIG.visuals;
        // 1. è®¡ç®—åŠå¾„ï¼šåŸºç¡€ + (ä¼¤å®³åŠ æˆï¼Œä½†ä¸è¶…è¿‡ä¸Šé™)
        let r = v.baseRadius + Math.min(v.maxSizeBonus, (config.damage - 2) * v.damageGrowth);

        // 2. åº”ç”¨ç±»å‹å€ç‡
        if (isCopy) r *= v.copyScale;
        if (config.explosive) r *= v.explosiveScale;
        if (config.pierce > 0) r *= v.arrowScale;

        // 3. è®¡ç®—å…‰æ™•å¼ºåº¦
        let glow = 1.0 + (config.damage * v.glowPerDamage) / 10;
        glow = Math.min(v.maxGlow / v.glowBase, glow);

        return { radius: r, intensity: glow };
    }

    /**
     * æ ¸å¿ƒæ›´æ–°é€»è¾‘ï¼šèåˆäº†ã€è§†è§‰ç‰¹æ•ˆã€‘ä¸ã€ç‰©ç†ç¢°æ’ã€‘
     */
    update(width, height, enemies, spawnCallback, timeScale) {
        if (!this.active) return;

        // --- A. è§†è§‰è¡¨ç°æ›´æ–° ---
        // 1. æ—‹è½¬
        if (this.config.pierce > 0) {
            this.rotation = Math.atan2(this.vel.y, this.vel.x);
        } else if (this.config.scatter > 0) {
            this.rotation += 0.3 * timeScale; 
        } else {
            this.rotation += 0.1 * timeScale;
        }

        // 2. å¼¹æ€§å˜å½¢ (Qå¼¹æ•ˆæœ)
        if (this.config.bounce > 0) {
            const speed = this.vel.mag();
            if (speed > 1) {
                const wobble = 1.0 + Math.sin(Date.now() / 100) * 0.1;
                this.targetDeformation = { x: 1/wobble, y: wobble };
            }
        }
        this.deformation.x += (this.targetDeformation.x - this.deformation.x) * this.elasticity * timeScale;
        this.deformation.y += (this.targetDeformation.y - this.deformation.y) * this.elasticity * timeScale;

        // 3. æ‹–å°¾æ›´æ–°
        this.trail.push({x: this.pos.x, y: this.pos.y});
        if (this.trail.length > 8) this.trail.shift();


        // --- B. ç‰©ç†ä¸ç¢°æ’é€»è¾‘ (æ‰¾å›ä¸¢å¤±çš„éƒ¨åˆ†) ---
        
        // æ›´æ–°å†·å´
        for (const [enemy, timer] of this.hitCooldowns) {
            if (timer > 0) this.hitCooldowns.set(enemy, timer - timeScale);
            else this.hitCooldowns.delete(enemy);
        }

        this.lifeTime -= timeScale;
        if (this.lifeTime <= 0) { this.destroy(spawnCallback); return; }

        const fullMove = this.vel.mult(timeScale);
        const totalSpeed = fullMove.mag();

        // 1. ç²—æµ‹é˜¶æ®µ (Broadphase)
        let potentialEnemies = enemies;
        if (totalSpeed > this.radius) {
            const minX = Math.min(this.pos.x, this.pos.x + fullMove.x) - this.radius;
            const maxX = Math.max(this.pos.x, this.pos.x + fullMove.x) + this.radius;
            const minY = Math.min(this.pos.y, this.pos.y + fullMove.y) - this.radius;
            const maxY = Math.max(this.pos.y, this.pos.y + fullMove.y) + this.radius;

            potentialEnemies = [];
            for (let e of enemies) {
                if (!e.active) continue;
                const ex = e.pos.x - e.width/2;
                const ey = e.pos.y - e.height/2;
                if (minX < ex + e.width && maxX > ex && minY < ey + e.height && maxY > ey) {
                    potentialEnemies.push(e);
                }
            }
        }

        if (potentialEnemies.length === 0) {
             this._applyMove(fullMove, width, height, spawnCallback);
             return;
        }

        // 2. ç²¾æµ‹é˜¶æ®µ (Sub-stepping)
        const safeStepSize = this.radius * 0.8; 
        const steps = Math.ceil(totalSpeed / safeStepSize);
        const subStepVel = fullMove.mult(1 / steps);

        for (let s = 0; s < steps; s++) {
            // æ‰§è¡Œä¸€å°æ­¥ç§»åŠ¨
            this._applyMove(subStepVel, width, height, spawnCallback);
            if (!this.active) return; 

            // æ£€æµ‹ç¢°æ’
            for (let e of potentialEnemies) {
                if (!e.active) continue;
                const halfW = e.width / 2;
                const halfH = e.height / 2;
                const dx = this.pos.x - e.pos.x;
                const dy = this.pos.y - e.pos.y;
                const overlapX = (halfW + this.radius) - Math.abs(dx);
                const overlapY = (halfH + this.radius) - Math.abs(dy);

                if (overlapX > 0 && overlapY > 0) {
                    // å‘½ä¸­åˆ¤å®š
                    let dealDamage = false;
                    if (!this.hitCooldowns.has(e)) {
                this.hitCooldowns.clear();         dealDamage = true;
                        this.hitCooldowns.set(e, CONFIG.gameplay.hitCooldowns);
                        this.onHit(e, enemies);

                        // å‘½ä¸­æ—¶è§¦å‘Qå¼¹å˜å½¢
                        if (this.config.bounce > 0) {
                            this.deformation = { x: 1.4, y: 0.6 };
                        }
                    }

                    // ç©¿é€/é”€æ¯é€»è¾‘
                    if (dealDamage) {
                        if (this.piercesLeft > 0) {
                            this.piercesLeft--;
                            continue; // ç»§ç»­é£è¡Œ
                        } else if (this.bouncesLeft > 0) {
                            this.bouncesLeft--;
                        } else {
                            this.destroy(spawnCallback);
                            return;
                        }
                    } else {
                        if (this.piercesLeft > 0) continue;
                    }

                    // ç‰©ç†åå¼¹
                    if (overlapX < overlapY) {
                        this.vel.x *= -1;
                        subStepVel.x *= -1;
                        if (dx < 0) this.pos.x = e.pos.x - halfW - this.radius - 0.1;
                        else        this.pos.x = e.pos.x + halfW + this.radius + 0.1;
                    } else {
                        this.vel.y *= -1;
                        subStepVel.y *= -1; 
                        if (dy < 0) this.pos.y = e.pos.y - halfH - this.radius - 0.1;
                        else        this.pos.y = e.pos.y + halfH + this.radius + 0.1;
                    }
                }
            }
        }
        
        // 1. çˆ†ç ´å¼¹ç ï¼šå¼•ä¿¡ç‡ƒçƒ§æ•ˆæœ (é«˜é¢‘æ‰è½ç«æ˜Ÿ)
        if (this.config.explosive) {
            // æ¯å¸§éƒ½æœ‰å¾ˆé«˜æ¦‚ç‡æ‰è½ç«æ˜Ÿ
            if (Math.random() < 0.7) {
    const trailDir = this.vel.norm().mult(-1);
    const smokeX = this.pos.x + trailDir.x * this.radius + (Math.random() - 0.5) * 4;
    const smokeY = this.pos.y + trailDir.y * this.radius + (Math.random() - 0.5) * 4;
    
    // ä½¿ç”¨æ·±ç°è‰²/é»‘è‰²ï¼Œå¸¦æœ‰ä¸€å®šçš„é€æ˜åº¦
    // æ¨¡æ‹Ÿæœªå®Œå…¨ç‡ƒçƒ§çš„ç«è¯çƒŸé›¾
    game.createParticle(smokeX, smokeY, 'rgba(51, 65, 85, 0.6)', 'smoke');
}
if (Math.random() < 0.2) {
                const trailDir = this.vel.norm().mult(-1);
                const dustX = this.pos.x + trailDir.x * this.radius;
                const dustY = this.pos.y + trailDir.y * this.radius;
                
                // ä½¿ç”¨æš—çº¢è‰²ï¼Œä¸ä½¿ç”¨ 'spark' æ¨¡å¼(å› ä¸º spark ä¼šå‘å…‰)
                // æ”¹ç”¨ 'normal' æ¨¡å¼ï¼Œå°±æ˜¯ä¸€ä¸ªæ™®é€šçš„çº¢è‰²åœ†ç‚¹
                const p = new Particle(dustX, dustY, '#ef4444', 'normal');
                p.size = Math.random() * 1.5 + 0.5; // å¾ˆå°çš„ç²‰å°˜
                p.life = 0.5; // æ¶ˆå¤±å¾—å¾ˆå¿«
                game.particles.push(p);
            }
        } else if (Math.random() < 0.3) {
             let color = null;
             if (this.config.pyro > 0) color = '#f97316';
             else if (this.config.cryo > 0) color = '#06b6d4';
             else if (this.config.lightning > 0) color = '#c084fc';
             if (color) game.createParticle(this.pos.x, this.pos.y, color);
        
        }
    }

    /**
     * å†…éƒ¨ç§»åŠ¨ä¸è¾¹ç•Œå¤„ç† (åŒ…å«æ’å¢™å˜å½¢)
     */
    _applyMove(vel, width, height, spawnCallback) {
        this.pos = this.pos.add(vel);

        // å·¦å³å¢™åå¼¹
        if (this.pos.x < this.radius) { 
            this.pos.x = this.radius; 
            this.vel.x = Math.abs(this.vel.x); 
            if(this.config.bounce > 0) this.deformation = { x: 0.7, y: 1.3 };
        }
        if (this.pos.x > width - this.radius) { 
            this.pos.x = width - this.radius; 
            this.vel.x = -Math.abs(this.vel.x); 
            if(this.config.bounce > 0) this.deformation = { x: 0.7, y: 1.3 };
        }
        // é¡¶éƒ¨åå¼¹
        if (this.pos.y < this.radius) { 
            this.pos.y = this.radius; 
            this.vel.y = Math.abs(this.vel.y); 
            if(this.config.bounce > 0) this.deformation = { x: 1.3, y: 0.7 };
        }
        
        // åº•éƒ¨é€»è¾‘
        if (this.pos.y > height - this.radius) {
            let didBounce = false;
            // å¦‚æœæœ‰æˆ˜æ–—åº•å¢™é—ç‰©
            if (game.hasCombatWall && (this.piercesLeft > 0 || this.config.bounce > 0)) {
                if (this.piercesLeft > 0) {
                    this.piercesLeft--;
                    didBounce = true;
                    game.createShockwave(this.pos.x, height);
                } else if (this.config.bounce > 0) {
                    // å¼¹åŠ›çƒå±æ€§ä¹Ÿå…è®¸åå¼¹
                    didBounce = true; 
                }
            }

            if (didBounce) {
                this.pos.y = height - this.radius;
                this.vel.y *= -1;
                this.vel.x += (Math.random() - 0.5) * 2;
                audio.playHit('bounce');
                if(this.config.bounce > 0) this.deformation = { x: 1.4, y: 0.6 };
            } else {
                this.destroy(spawnCallback);
            }
        }
        if (this.pos.y > height + 50) { this.destroy(spawnCallback); }
    }
    
    onHit(enemy, allEnemies) {
        game.damageEnemy(enemy, this);
    }

    destroy(spawnCallback) {
        this.active = false; this.destroyed = true;
        
        // å¥—å¨ƒç”Ÿæˆé€»è¾‘
        if (this.config.nestedPayload && !this.isCopy) {
             let nextVel = this.vel.norm().mult(this.vel.mag() * 1.1); 
             if (nextVel.mag() < 2) nextVel = new Vec2(0, -5);
             spawnCallback({ x: this.pos.x, y: this.pos.y, vel: nextVel, config: this.config.nestedPayload });
        }
        // è¿é”ç”Ÿæˆé€»è¾‘
        else if (this.config.chainPayload && !this.isCopy) {
            let nextVel = this.vel; if (nextVel.mag() < 1) nextVel = new Vec2(0, 5);
            spawnCallback({ x: this.pos.x, y: this.pos.y, vel: nextVel.norm().mult(10), config: this.config.chainPayload });
        }
    }

    // --- å®ä¾‹ç»˜åˆ¶ ---
    // --- åœ¨ Projectile ç±»ä¸­ ---
    draw(ctx) {
        // 1. è®¡ç®—å½“å‰è€ä¹…åº¦æ¯”ä¾‹
        const currentDurability = (this.bouncesLeft + this.piercesLeft);
        let integrity = 1.0;
        if (this.maxDurability > 0) {
            integrity = currentDurability / this.maxDurability;
        }
        integrity = Math.max(0.2, integrity);

        // --- æ ¸å¿ƒä¿®å¤ï¼šåˆ¤å®šæ˜¯å¦éœ€è¦ç»˜åˆ¶æ‹–å°¾ ---
        const hasElementalTrail = this.config.pyro > 0 || 
                                  this.config.cryo > 0 || 
                                  this.config.pierce > 0 || 
                                  this.config.scatter > 0 || 
                                  this.config.explosive;

        if ((this.config.bounce === 0 || hasElementalTrail) && this.trail.length > 1) {
            ctx.save();
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.globalCompositeOperation = 'lighter'; 
            
            let trailColor = '255, 255, 255'; 
            if (this.config.explosive) trailColor = '252, 165, 165'; 
            else if (this.config.pyro) trailColor = '251, 146, 60'; 
            else if (this.config.cryo) trailColor = '165, 243, 252'; 
            else if (this.config.pierce) trailColor = '252, 165, 165'; 
            else if (this.config.scatter) trailColor = '253, 224, 71'; 

            for (let i = 0; i < this.trail.length - 1; i++) {
                const p1 = this.trail[i];
                const p2 = this.trail[i+1];
                const progress = i / this.trail.length; 
                
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);

                // 1. åŸºç¡€ç³»æ•° (æ™®é€šå¼¹ä¿æŒ 0.6, å¼¹æ€§å¼¹ä¿æŒ 0.4)
                let widthMod = this.config.bounce > 0 ? 0.2 : 0.42;
                
                // 2. å¦‚æœæ˜¯çˆ†ç ´å¼¹ç ï¼Œå¼ºåˆ¶ä½¿ç”¨æå°çš„ç³»æ•°
                // å› ä¸ºçˆ†ç ´å¼¹æœ¬æ¥å°±å¾ˆå¤§ï¼Œä¸èƒ½è®©æ‹–å°¾è·Ÿç€å˜å¤§
                if (this.config.explosive) {
                    widthMod = 0.15; 
                }
                
                // 3. è®¡ç®—å®½åº¦
                let finalWidth = (this.radius * widthMod) * progress * integrity;

                // 4. [ç»å¯¹é˜²çº¿]ï¼šå¦‚æœæ˜¯çˆ†ç ´å¼¹ï¼Œè®¾ç½®ä¸€ä¸ªåƒç´ çº§çš„ç¡¬ä¸Šé™
                // æ— è®ºç‚¸å¼¹å˜å¾—å¤šå·¨å¤§ï¼Œæ‹–å°¾æœ€ç²—ä¸èƒ½è¶…è¿‡ 4px
                if (this.config.explosive) {
                    finalWidth = Math.min(finalWidth, 4); 
                }

                ctx.lineWidth = finalWidth;
                
                // ç¨å¾®é™ä½ä¸€ç‚¹é€æ˜åº¦
                ctx.strokeStyle = `rgba(${trailColor}, ${progress * 0.2 * integrity})`;
                ctx.stroke();
            }
            ctx.restore();
        }

        // ... ç»˜åˆ¶å­å¼¹æœ¬ä½“çš„ä»£ç ä¿æŒä¸å˜ ...
        const dimIntensity = this.intensity * (0.5 + 0.5 * integrity); 

        Projectile.drawVisuals(
            ctx, 
            this.pos.x, 
            this.pos.y, 
            this.radius, 
            this.config, 
            this.rotation, 
            dimIntensity, 
            this.deformation,
            integrity,      
            this.crackSeed  
        );
    }

    // --- é™æ€ç»˜åˆ¶æ–¹æ³• (å·²åŒ…å«ä¿®æ­£åçš„ç®­å¤´å’Œç»„åˆç‰¹æ•ˆ) ---
    // --- é™æ€ç»˜åˆ¶æ–¹æ³• (ä¿®å¤å†°éœœè±å½¢ä¸¢å¤±é—®é¢˜) ---
    static drawVisuals(ctx, x, y, radius, config, rotation, intensity, deformation = {x:1, y:1}, integrity = 1.0, crackSeed = []) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(rotation);
        if (config.explosive) {
            const time = Date.now();
            
            // 1. é«˜é¢‘è„‰å†² (æ¯ç§’é—ªçƒçº¦ 10 æ¬¡)
            // äº§ç”Ÿä¸€ä¸ª 0.0 ~ 1.0 çš„æ³¢åŠ¨å€¼
            const pulse = (Math.sin(time / 50) + 1) / 2; 

            // 2. é¢œè‰²é—ªçƒ (æ ¸å¿ƒè¿‡çƒ­è­¦å‘Š)
            // å½“è„‰å†²è¾¾åˆ°å³°å€¼æ—¶ï¼Œé¢œè‰²ç”±çº¢è‰²å˜ä¸ºçº¯ç™½ï¼Œæ¨¡æ‹Ÿä¸´ç•ŒçŠ¶æ€
            let coreColor = '#ef4444'; // åŸºç¡€çº¢
            let glowColor = '#b91c1c'; // æ·±çº¢å…‰æ™•
            
            if (pulse > 0.7) {
                coreColor = '#ffffff'; // é—ªç™½
                glowColor = '#fca5a5'; // å…‰æ™•å˜äº®çº¢
                intensity *= 1.5; // å…‰æ™•æš´æ¶¨
            }

            // 3. ä½“ç§¯è†¨èƒ€ (å‘¼å¸æ„Ÿ)
            // è®©å­å¼¹åœ¨ 100% ~ 115% å¤§å°ä¹‹é—´éœ‡è¡
            const scaleMod = 1.0 + pulse * 0.15;
            ctx.scale(deformation.x * scaleMod, deformation.y * scaleMod);

            // 4. ä½ç½®é¢¤æŠ– (Jitter - å…³é”®ç‰¹æ•ˆ)
            // å°±åœ¨åŸä½ç½®ç–¯ç‹‚æŠ–åŠ¨ï¼Œè¡¨ç°å‡ºèƒ½é‡æ— æ³•æ§åˆ¶çš„æ„Ÿè§‰
            const shakeAmount = 1.5; 
            ctx.translate((Math.random() - 0.5) * shakeAmount, (Math.random() - 0.5) * shakeAmount);

            // --- ç»˜åˆ¶ç‚¸å¼¹æœ¬ä½“ ---
            // å…‰æ™•
            ctx.shadowBlur = CONFIG.visuals.glowBase * intensity * 1.5;
            ctx.shadowColor = glowColor;
            
            // æ ¸å¿ƒåœ†
            ctx.fillStyle = coreColor;
            ctx.beginPath();
            ctx.arc(0, 0, radius, 0, Math.PI * 2);
            ctx.fill();

            // å†…éƒ¨é«˜å…‰ (è®©å®ƒçœ‹èµ·æ¥åƒçƒä½“)
            ctx.shadowBlur = 0;
            ctx.fillStyle = 'rgba(255,255,255,0.4)';
            ctx.beginPath();
            ctx.arc(-radius*0.3, -radius*0.3, radius*0.3, 0, Math.PI*2);
            ctx.fill();

            ctx.restore();
            return; // *** çˆ†ç ´å¼¹ç»˜åˆ¶å®Œæ¯•ï¼Œç›´æ¥è¿”å›ï¼Œè·³è¿‡åç»­é€šç”¨é€»è¾‘ ***
        }


        // 1. å†³å®šå½¢çŠ¶ (ä¿®å¤ï¼šåŠ å› crystal)
        let shapeType = 'circle';
        if (config.isMatryoshka) shapeType = 'matryoshka';
        else if (config.pierce > 0) shapeType = 'arrow';
        else if (config.scatter > 0) shapeType = 'star';
        else if (config.cryo > 0) shapeType = 'crystal'; // <--- æ‰¾å›äº†ä¸¢å¤±çš„å†°éœœå½¢çŠ¶åˆ¤å®š
        else if (config.isLaser) shapeType = 'orb';

        // 2. å†³å®šé¢œè‰²
        let mainColors = [];
        let glowColors = [];
        
        if (config.isLaser) { 
            mainColors.push('#ffffff'); // æ ¸å¿ƒçº¯ç™½
            glowColors.push(CONFIG.colors.laser); // å¤–åœˆå¤©è“
        }

        if (config.explosive) { mainColors.push('#fff'); glowColors.push('#ef4444'); }
        if (config.pyro > 0) { mainColors.push('#fdba74'); glowColors.push('#f97316'); }
        if (config.cryo > 0) { mainColors.push('#cffafe'); glowColors.push('#06b6d4'); }
        if (config.lightning > 0) { mainColors.push('#f3e8ff'); glowColors.push('#c084fc'); }
        if (config.pierce > 0 && mainColors.length === 0) { mainColors.push('#fee2e2'); glowColors.push('#ef4444'); }

        if (mainColors.length === 0) {
            if (config.bounce > 0) { mainColors.push('#dcfce7'); glowColors.push('#22c55e'); }
            else { mainColors.push('#f1f5f9'); glowColors.push('#94a3b8'); }
        }

        const mainColor = mainColors[mainColors.length - 1];
        const glowColor = glowColors[glowColors.length - 1];

        if (config.explosive && integrity > 0.1) {
            const time = Date.now();
            
            // 1. é«˜é¢‘è„‰å†² (æ¯ç§’é—ªçƒçº¦ 10 æ¬¡)
            // äº§ç”Ÿä¸€ä¸ª 0.0 ~ 1.0 çš„æ³¢åŠ¨å€¼
            const pulse = (Math.sin(time / 50) + 1) / 2; 

            // 2. é¢œè‰²é—ªçƒ (æ ¸å¿ƒè¿‡çƒ­)
            // å½“è„‰å†²è¾¾åˆ°å³°å€¼æ—¶ï¼Œé¢œè‰²ç”±çº¢è‰²å˜ä¸ºçº¯ç™½
            if (pulse > 0.7) {
                // æ··åˆç™½è‰²ï¼šç®€å•çš„é€»è¾‘æ˜¯ç›´æ¥è¦†ç›– mainColor
                // è§†è§‰ä¸Šä¼šäº§ç”Ÿçº¢-ç™½-çº¢çš„æ€¥ä¿ƒè­¦æŠ¥æ„Ÿ
                mainColors[mainColors.length - 1] = '#ffffff'; 
                glowColors[glowColors.length - 1] = '#fca5a5'; // å…‰æ™•å˜äº®çº¢
                intensity *= 1.5; // å…‰æ™•æš´æ¶¨
            }

            // 3. ä½“ç§¯è†¨èƒ€ (å‘¼å¸æ„Ÿ)
            // è®©å­å¼¹åœ¨ 100% ~ 115% å¤§å°ä¹‹é—´éœ‡è¡
            const scaleMod = 1.0 + pulse * 0.15;
            deformation.x *= scaleMod;
            deformation.y *= scaleMod;

            // 4. ä½ç½®é¢¤æŠ– (Jitter)
            // å°±åœ¨åŸä½ç½®ç–¯ç‹‚æŠ–åŠ¨ï¼Œè¡¨ç°å‡ºèƒ½é‡æ— æ³•æ§åˆ¶
            const shakeAmount = 1.5; 
            ctx.translate((Math.random() - 0.5) * shakeAmount, (Math.random() - 0.5) * shakeAmount);
        }
        // ---  å…‰çƒçš„ç‰¹æ®Šæ¸²æŸ“é€»è¾‘ (ç»‘å®šç‰¹æ•ˆ) ---
        if (shapeType === 'orb') {
            // 1. åŠ¨æ€è„‰å†² (æ¨¡æ‹Ÿèƒ½é‡ä¸ç¨³å®šçš„æ„Ÿè§‰)
            const time = Date.now() / 200;
            const pulse = Math.sin(time) * 0.1 + 1.0; 
            
            // 2. æ ¹æ®æ¿€å…‰å±‚æ•° (config.laser) å¢å¼ºå…‰æ™•å’Œå¤§å°
            // config.laser è¶Šé«˜ï¼Œçƒä½“è¶Šäº®ï¼Œæ ¸å¿ƒè¶Šå¤§
            const laserPower = config.laser || 0;
            const sizeMod = 1 + (laserPower * 0.1); 
            
            // ç»˜åˆ¶å¼ºå…‰æ™• (å¤šå±‚å åŠ )
            ctx.shadowBlur = 20 * intensity * sizeMod;
            ctx.shadowColor = glowColor;
            
            // å¤–å±‚å…‰ç¯
            ctx.fillStyle = glowColor;
            ctx.globalAlpha = 0.4;
            ctx.beginPath();
            ctx.arc(0, 0, radius * 1.2 * pulse * sizeMod, 0, Math.PI * 2);
            ctx.fill();

            // å†…å±‚æ ¸å¿ƒ (é«˜äº®)
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#fff';
            ctx.fillStyle = '#ffffff';
            ctx.globalAlpha = 1.0;
            ctx.beginPath();
            ctx.arc(0, 0, radius * 0.8 * sizeMod, 0, Math.PI * 2);
            ctx.fill();
            
            // æ¢å¤ä¸Šä¸‹æ–‡ï¼Œè·³è¿‡åç»­é€šç”¨ç»˜åˆ¶
            ctx.restore();
            return; 
        }
        // 3. ç»˜åˆ¶å½¢çŠ¶
        ctx.beginPath();
        if (shapeType === 'arrow') {
            ctx.moveTo(radius * 1.3, 0); 
            ctx.lineTo(-radius * 0.8, radius * 0.5); 
            ctx.lineTo(-radius * 0.4, 0); 
            ctx.lineTo(-radius * 0.8, -radius * 0.5); 
        } else if (shapeType === 'star') {
            for (let i = 0; i < 4; i++) {
                ctx.rotate(Math.PI / 2);
                ctx.lineTo(radius, 0);
                ctx.lineTo(radius * 0.4, radius * 0.4);
            }
        } else if (shapeType === 'crystal') { // <--- æ‰¾å›äº†ä¸¢å¤±çš„è±å½¢ç»˜åˆ¶é€»è¾‘
            ctx.moveTo(0, -radius * 1.3);
            ctx.lineTo(radius * 0.8, 0);
            ctx.lineTo(0, radius * 1.3);
            ctx.lineTo(-radius * 0.8, 0);
        } else if (shapeType === 'matryoshka') {
             ctx.arc(0, 0, radius, 0, Math.PI * 2);
        } else {
            // é»˜è®¤åœ†å½¢/æµä½“
            if (config.pyro > 0) {
                const time = Date.now() / 60;
                for (let i = 0; i <= 20; i++) {
                    const angle = (i / 20) * Math.PI * 2;
                    const wave = Math.sin(time + angle * 4) * (radius * 0.2); 
                    const r = radius + wave;
                    ctx.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);
                }
            } else {
                ctx.arc(0, 0, radius, 0, Math.PI * 2);
            }
        }
        ctx.closePath();

        // --- [è§†è§‰ä¿®æ”¹]ï¼šåº”ç”¨è€åŒ–æ•ˆæœ ---
    
        // A. å…‰æ™•å‡å¼±
        ctx.shadowBlur = CONFIG.visuals.glowBase * intensity * integrity; // è¶Šç ´æŸå…‰æ™•è¶Šå°
        ctx.shadowColor = glowColor;
        
        // B. é¢œè‰²å˜æš— (ä½¿ç”¨ globalAlpha ç®€å•æ¨¡æ‹Ÿæˆ–è€…åœ¨é¢œè‰²ä¸Šè¦†ç›–é»‘è‰²å±‚)
        // è¿™é‡Œæˆ‘ä»¬å¡«å……ä¸»è‰²
        ctx.fillStyle = mainColor;
        ctx.fill();

        // å¦‚æœè€ä¹…åº¦ä¸æ»¡ï¼Œè¦†ç›–ä¸€å±‚åŠé€æ˜é»‘è‰²ï¼Œä½¿å…¶çœ‹èµ·æ¥å˜æš—/è„
        if (integrity < 1.0) {
            ctx.fillStyle = `rgba(0, 0, 0, ${0.6 - 0.6 * integrity})`; // æœ€å¤š 60% çš„é»‘åº¦
            ctx.fill();
        }

        // 4. å¡«å……
        ctx.shadowBlur = CONFIG.visuals.glowBase * intensity;
        ctx.shadowColor = glowColor;
        ctx.fillStyle = mainColor;
        ctx.fill();

        // 5. å†…éƒ¨ç»†èŠ‚
        if (config.cryo > 0) {
            ctx.shadowBlur = 0;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.beginPath();
            if (shapeType === 'arrow') {
                ctx.moveTo(0, -radius * 0.25); ctx.lineTo(radius*0.3, 0); ctx.lineTo(0, radius*0.25); ctx.lineTo(-radius*0.3, 0);
            } else if (shapeType === 'crystal') {
                // å¦‚æœæ˜¯è±å½¢ï¼Œå†…éƒ¨ç”»ä¸ªå°è±å½¢é«˜å…‰
                ctx.moveTo(0, -radius * 0.6); 
                ctx.lineTo(radius * 0.3, 0); 
                ctx.lineTo(0, radius * 0.6); 
                ctx.lineTo(-radius * 0.3, 0);
            } else {
                for(let i=0; i<6; i++) {
                    const a = i * Math.PI / 3;
                    const r = radius * 0.5;
                    ctx.lineTo(Math.cos(a)*r, Math.sin(a)*r);
                }
            }
            ctx.fill();
        }

        // --- [è§†è§‰ä¿®æ”¹]ï¼šç»˜åˆ¶è£‚çº¹ ---
        // åªæœ‰å½“å®Œæ•´åº¦ä½äº 60% æ—¶æ‰å¼€å§‹å‡ºç°è£‚çº¹
        if (integrity < 0.6 && crackSeed && crackSeed.length > 0) {
            ctx.save();
            ctx.shadowBlur = 0; // è£‚çº¹æ²¡æœ‰å…‰æ™•
            ctx.lineWidth = 1.5; // è£‚çº¹å®½åº¦
            // è£‚çº¹é¢œè‰²ï¼šæ·±è‰²ï¼Œå¸¦ä¸€ç‚¹ç‚¹ glowColor çš„ä½™å…‰
            ctx.strokeStyle = 'rgba(30, 41, 59, 0.8)'; 
            
            // å‰ªåˆ‡è·¯å¾„ï¼Œä¿è¯è£‚çº¹åªç”»åœ¨å­å¼¹å†…éƒ¨
            ctx.clip(); 

            crackSeed.forEach(seed => {
                ctx.beginPath();
                ctx.moveTo(0, 0); // ä»ä¸­å¿ƒè£‚å¼€
                // è®¡ç®—è£‚çº¹ç»ˆç‚¹
                const r = radius * seed.len;
                const endX = Math.cos(seed.angle) * r;
                const endY = Math.sin(seed.angle) * r;
                
                // ç”»ä¸€ä¸ªæŠ˜çº¿ï¼Œå¢åŠ ç ´ç¢æ„Ÿ
                const midX = endX * 0.5 + Math.cos(seed.angle + Math.PI/2) * (radius * seed.jagged);
                const midY = endY * 0.5 + Math.sin(seed.angle + Math.PI/2) * (radius * seed.jagged);
                
                ctx.lineTo(midX, midY);
                ctx.lineTo(endX, endY);
                ctx.stroke();
            });
            ctx.restore();
        }
        
        // --- [è§†è§‰ä¿®æ”¹]ï¼šå¦‚æœå¼¹æ€§è€—å°½ï¼Œç»˜åˆ¶ä¸€ä¸ªæ²‰é‡çš„å¤–è¾¹æ¡† ---
        // åˆ¤æ–­é€»è¾‘ï¼šå¦‚æœ config é‡Œæœ¬æ¥æœ‰å¼¹æ€§ï¼Œä½†ç°åœ¨ integrity å¾ˆä½
        if (config.bounce > 0 && integrity < 0.2) {
            ctx.strokeStyle = '#475569'; // é“ç°è‰²
            ctx.lineWidth = 2;
            ctx.stroke(); // ç»™åœ†çƒç”»ä¸ªåœˆï¼Œè¡¨ç¤ºå®ƒå˜æˆäº†å®å¿ƒé“çƒï¼Œä¸å†Qå¼¹
        }
        // --- [æ–°å¢/ä¿®æ”¹]ï¼šå­å¼¹çš„ç‹‚æš´ç”µå¼§ç‰¹æ•ˆ ---
        if (config.lightning > 0) {
            ctx.save();
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.globalCompositeOperation = 'lighter'; // é«˜äº®å åŠ 

            // 1. åŠ¨æ€æ•°é‡ï¼šå±‚æ•°è¶Šé«˜ï¼Œç”µå¼§è¶Šå¤š
            // å­å¼¹é£è¡Œé€Ÿåº¦å¿«ï¼Œæ¯å¸§åˆ·æ–°ä¼šå¯¼è‡´ç”µå¼§ç–¯ç‹‚è·³åŠ¨ï¼Œè¿™æ­£ç¬¦åˆâ€œçƒçŠ¶é—ªç”µâ€çš„ä¸ç¨³å®šæ„Ÿ
            const arcCount = 1 + Math.floor(config.lightning / 2);

            ctx.shadowBlur = 8 + config.lightning;
            ctx.shadowColor = '#a855f7'; // Purple-500
            ctx.strokeStyle = '#e9d5ff'; // Purple-200 (åŒæ¬¾é«˜äº®ç´«)
            
            for (let k = 0; k < arcCount; k++) {
                ctx.beginPath();
                
                // éšæœºèµ·å§‹è§’åº¦
                const startAngle = Math.random() * Math.PI * 2;
                // å¼§é•¿æ¯” DropBall å°ä¸€ç‚¹ï¼Œæ˜¾å¾—æ›´ç´§å‡‘
                const arcLen = 0.5 + Math.random() * 0.5; 
                
                // 3~5 æ®µæŠ˜çº¿
                const segments = 3 + Math.floor(Math.random() * 2);

                for (let i = 0; i <= segments; i++) {
                    const t = i / segments;
                    const currentAngle = startAngle + t * arcLen;
                    
                    // æ‚¬æµ®è·ç¦»ï¼šåŠå¾„çš„ 1.1 ~ 1.4 å€
                    // åŠ ä¸Š deformation ä¿®æ­£ï¼Œç¡®ä¿ç”µå¼§è·Ÿéšå­å¼¹è¢«å‹æ‰/æ‹‰é•¿
                    const jitter = (Math.random() - 0.5) * (radius * 0.3);
                    const dist = radius * 1.2 + jitter;
                    
                    const px = Math.cos(currentAngle) * dist;
                    const py = Math.sin(currentAngle) * dist;
                    
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                
                // çº¿æ¡ç¨å¾®ç»†ä¸€ç‚¹ï¼Œå› ä¸ºå­å¼¹æœ¬æ¥å°±å°
                ctx.lineWidth = 0.8 + Math.random() * 1.2;
                ctx.stroke();
            }
            
            // å¶å°”çš„æ ¸å¿ƒé—ªçƒ (High Voltage Flicker)
            if (Math.random() < 0.2) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.beginPath();
                ctx.arc(0, 0, radius * 0.8, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();
        }

        if (config.isMatryoshka) {
            ctx.shadowBlur = 0;
            ctx.fillStyle = '#d946ef'; 
            ctx.beginPath(); ctx.arc(0, -radius*0.2, radius*0.4, 0, Math.PI*2); ctx.fill(); 
            ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; 
            ctx.beginPath(); ctx.arc(0, 0, radius*0.8, 0, Math.PI*2); ctx.stroke();
        }

        ctx.restore();
    }
}
// --- æ–°å¢ï¼šåˆ†èº«å­¢å­å‹•ç•«å¯¦é«” ---
class CloneSpore {
    constructor(startX, startY, targetX, targetY, onLandCallback) {
        this.start = new Vec2(startX, startY);
        this.end = new Vec2(targetX, targetY);
        this.pos = new Vec2(startX, startY);
        this.onLand = onLandCallback;
        
        this.progress = 0;
        this.speed = 0.05; // å‹•ç•«é€Ÿåº¦
        this.arcHeight = 100; // æ‹‹ç‰©ç·šé«˜åº¦
        this.active = true;
    }

    update(timeScale) {
        this.progress += this.speed * timeScale;
        
        if (this.progress >= 1) {
            this.progress = 1;
            this.active = false;
            this.onLand(); // è½åœ°ï¼Œå‘¼å«å›èª¿ç”Ÿæˆæ•µäºº
            game.createExplosion(this.end.x, this.end.y, '#a855f7'); // è½åœ°ç‰¹æ•ˆ
            audio.playPowerup();
        }

        // ç·šæ€§æ’å€¼è¨ˆç®—æ°´å¹³ä½ç½®
        const tx = this.start.x + (this.end.x - this.start.x) * this.progress;
        // ç·šæ€§æ’å€¼å‚ç›´ä½ç½®
        const tyBase = this.start.y + (this.end.y - this.start.y) * this.progress;
        // åŠ ä¸Šæ‹‹ç‰©ç·šåç§» (sin(0~PI) * height)
        const arc = Math.sin(this.progress * Math.PI) * this.arcHeight;
        
        this.pos.x = tx;
        this.pos.y = tyBase - arc; // å‘ä¸Šæ‹‹
    }

    draw(ctx) {
        if (!this.active) return;
        ctx.save();
        ctx.translate(this.pos.x, this.pos.y);
        ctx.rotate(this.progress * Math.PI * 4); // æ—‹è½‰æ•ˆæœ
        
        // ç¹ªè£½å­¢å­
        ctx.fillStyle = '#d8b4fe';
        ctx.shadowColor = '#a855f7';
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(0, 0, 6, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(2, -2, 2, 0, Math.PI * 2); // é«˜å…‰
        ctx.stroke();
        
        ctx.restore();
    }
}

class Particle {
    constructor(x, y, color, mode = 'normal') {
        this.pos = new Vec2(x, y);
        this.color = color;
        this.mode = mode;
        this.life = 1.0;
        this.maxLife = 1.0; 
        
        const angle = Math.random() * Math.PI * 2;
        
        // --- åˆå§‹åŒ–ç‰©ç†å‚æ•° ---
        if (mode === 'spark') {
            const speed = Math.random() * 5 + 2;
            this.vel = new Vec2(Math.cos(angle) * speed, Math.sin(angle) * speed);
            this.drag = 0.85; this.gravity = 0.1; 
            this.decay = 0.05 + Math.random() * 0.05; 
            this.size = Math.random() * 2 + 1; 

        } else if (mode === 'ember') {
            this.vel = new Vec2((Math.random() - 0.5) * 1.5, (Math.random() - 0.5) * 1.5);
            this.drag = 0.96; this.gravity = -0.05; 
            this.decay = 0.02 + Math.random() * 0.03; 
            this.size = Math.random() * 3 + 1.5; 
            this.wobble = Math.random() * 10; 

        } else if (mode === 'mist') {
            this.vel = new Vec2((Math.random() - 0.5) * 0.8, Math.random() * 0.5 + 0.5); 
            this.drag = 0.96; this.gravity = 0.02; 
            this.decay = 0.015 + Math.random() * 0.01; 
            this.size = Math.random() * 8 + 6; 
            this.angle = Math.random() * Math.PI * 2; 

        } else if (mode === 'shard') {
            // [ä¼˜åŒ–] å†°æ¸£ï¼šæ›´çŒ›çƒˆçš„çˆ†å‘é€Ÿåº¦
            const speed = Math.random() * 6 + 2; // é€Ÿåº¦æ›´å¿«
            // å‘ä¸Šå–·æº…çš„å€¾å‘æ›´æ˜æ˜¾ (y - 4)
            this.vel = new Vec2(Math.cos(angle) * speed, Math.sin(angle) * speed - 4); 
            this.drag = 0.94; // ç©ºæ°”é˜»åŠ›
            this.gravity = 0.8; // é‡åŠ›è¾ƒé‡ï¼Œå¿«é€Ÿä¸‹å 
            this.decay = 0.03 + Math.random() * 0.02;
            
            //  å½¢çŠ¶éšæœºåŒ–ï¼šæœ‰çš„é•¿æœ‰çš„çŸ­
            this.size = Math.random() * 4 + 2;
            this.scaleX = Math.random() * 0.5 + 0.5; // å®½åº¦å˜å¼‚
            this.scaleY = Math.random() * 1.5 + 1.0; // é•¿åº¦æ‹‰ä¼¸ (åšæˆå†°åˆº)
            
            this.angle = Math.random() * Math.PI * 2;
            this.spin = (Math.random() - 0.5) * 0.5; // æ—‹è½¬

        } else if (mode === 'smoke') {
            this.vel = new Vec2((Math.random() - 0.5) * 0.5, -Math.random() * 1.5 - 0.5);
            this.drag = 0.98; this.gravity = -0.02; this.decay = 0.015;
            this.size = Math.random() * 6 + 4; this.life = 1.2; 
        } else {
            this.vel = new Vec2((Math.random() - 0.5) * 4, (Math.random() - 0.5) * 4);
            this.drag = 0.92; this.gravity = 0; this.decay = 0.05; this.size = Math.random() * 2 + 1;
        }
        this.maxLife = this.life;
    }

    update(timeScale) {
        if (this.mode === 'ember') {
            this.pos.x += Math.sin(this.life * 10 + this.wobble) * 0.5 * timeScale;
        }
        this.pos = this.pos.add(this.vel.mult(timeScale));
        this.vel = this.vel.mult(Math.pow(this.drag, timeScale));
        this.vel.y += this.gravity * timeScale;
        if (this.mode === 'shard' || this.mode === 'mist') {
            this.angle += this.spin * timeScale;
        }
        this.life -= this.decay * timeScale;
    }

    // --- Particle ç±»çš„ draw æ–¹æ³• ---
    draw(ctx) {
        if (this.life <= 0) return;
        ctx.save();
        ctx.translate(this.pos.x, this.pos.y);
        
        // è®¾ç½®æ··åˆæ¨¡å¼
        if (this.mode === 'mist' && this.color && this.color.includes('0,0,0')) {
             ctx.globalCompositeOperation = 'source-over'; // é»‘çƒŸ
        } else if (this.mode === 'shard' || this.mode === 'spark' || this.mode === 'mist') {
             ctx.globalCompositeOperation = this.mode === 'mist' ? 'screen' : 'lighter';
        }

        ctx.globalAlpha = Math.max(0, this.life);

        // --- ä¼˜åŒ–ï¼šæ ¹æ®æ¨¡å¼ç®€åŒ–ç»˜åˆ¶ ---
        if (this.mode === 'mist') {
            // åªæœ‰ Mist è¿™ç§å¤§é¢ç§¯ç²’å­æ‰ä½¿ç”¨æ¸å˜
            const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, this.size);
            // ç®€åŒ–æ¸å˜é¢œè‰²è®¡ç®—
            if (this.color) {
                grad.addColorStop(0, this.color); 
                grad.addColorStop(1, 'rgba(0,0,0,0)');
            } else {
                grad.addColorStop(0, `rgba(207, 250, 254, ${this.life * 0.4})`); 
                grad.addColorStop(1, `rgba(165, 243, 252, 0)`); 
            } 
            ctx.fillStyle = grad;
            ctx.beginPath(); ctx.arc(0, 0, this.size, 0, Math.PI * 2); ctx.fill();

        } else if (this.mode === 'ember') {
            // ä½™çƒ¬æ”¹ä¸ºå®å¿ƒåœ†ï¼Œä¾é  globalAlpha å®ç°æ·¡å‡º
            ctx.fillStyle = `rgba(255, 180, 0, ${this.life})`; // ç®€åŒ–çš„æ©™è‰²
            ctx.beginPath(); ctx.arc(0, 0, this.size, 0, Math.PI * 2); ctx.fill();

        } else if (this.mode === 'shard') {
            // å†°æ¸£ä¿æŒåŸæ ·ï¼Œå› ä¸ºå®ƒæ˜¯çº¯è‰²å¡«å……ï¼Œå¼€é”€ä¸å¤§
            ctx.rotate(this.angle);
            ctx.scale(this.scaleX, this.scaleY);
            ctx.fillStyle = this.color; 
            ctx.beginPath();
            ctx.moveTo(0, -this.size);
            ctx.lineTo(this.size * 0.6, 0);
            ctx.lineTo(0, this.size * 1.5);
            ctx.lineTo(-this.size * 0.6, 0);
            ctx.fill();

        } else {
            // æ™®é€šç²’å­ (spark/normal) ç›´æ¥ç”»åœ†ï¼Œä¸ç”¨æ¸å˜
            ctx.fillStyle = this.color;
            if (this.mode === 'spark') {
                const rot = Math.atan2(this.vel.y, this.vel.x);
                ctx.rotate(rot);
                ctx.beginPath();
                ctx.ellipse(0, 0, this.size * 2, this.size * 0.4, 0, 0, Math.PI * 2);
            } else {
                ctx.beginPath();
                ctx.arc(0, 0, this.size, 0, Math.PI * 2);
            }
            ctx.fill();
        }
        
        ctx.restore();
    }
}
// --- æ–°å¢ï¼šæ”¶é›†å®Œæˆçš„å…‰æŸ±ç‰¹æ•ˆ ---
class CollectionBeam {
    constructor(x, bottomY) {
        this.x = x;
        this.bottomY = bottomY;
        this.width = 60; // å…‰æŸ±å®½åº¦
        this.life = 1.0;
        this.decay = 0.04;
        this.height = 0;
        this.maxHeight = bottomY + 100; // å‘ä¸Šå»¶ä¼¸çš„é«˜åº¦
    }

    update(timeScale) {
        this.life -= this.decay * timeScale;
        // å…‰æŸ±å¿«é€Ÿå†²é«˜
        this.height = lerp(this.height, this.maxHeight, 0.2 * timeScale);
    }

    draw(ctx) {
        if (this.life <= 0) return;
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        
        // 1. æ ¸å¿ƒå…‰æŸ± (å‘ä¸Šæ¸å˜æ¶ˆå¤±)
        const grad = ctx.createLinearGradient(this.x, this.bottomY, this.x, this.bottomY - this.height);
        grad.addColorStop(0, `rgba(255, 255, 255, ${this.life})`);
        grad.addColorStop(0.4, `rgba(14, 165, 233, ${this.life * 0.5})`); // Sky Blue
        grad.addColorStop(1, `rgba(14, 165, 233, 0)`);

        ctx.fillStyle = grad;
        ctx.beginPath();
        // æ¢¯å½¢å…‰æŸ± (åº•éƒ¨çª„ï¼Œä¸Šéƒ¨å®½)
        const wBottom = this.width * 0.4;
        const wTop = this.width;
        
        ctx.moveTo(this.x - wBottom, this.bottomY);
        ctx.lineTo(this.x + wBottom, this.bottomY);
        ctx.lineTo(this.x + wTop, this.bottomY - this.height);
        ctx.lineTo(this.x - wTop, this.bottomY - this.height);
        ctx.fill();

        // 2. åº•éƒ¨çˆ†å‘å…‰æ™•
        const glowSize = 40 * this.life;
        const radial = ctx.createRadialGradient(this.x, this.bottomY, 0, this.x, this.bottomY, glowSize);
        radial.addColorStop(0, `rgba(255, 255, 255, ${this.life})`);
        radial.addColorStop(1, `rgba(14, 165, 233, 0)`);
        
        ctx.fillStyle = radial;
        ctx.beginPath();
        ctx.arc(this.x, this.bottomY, glowSize, 0, Math.PI*2);
        ctx.fill();

        ctx.restore();
    }
}
class Shockwave {
    constructor(x, y, color) { 
        this.x = x; 
        this.y = y; 
        this.radius = 1; 
        this.alpha = 1.0; 
        this.color = color || '#ffffff'; 
        this.maxRadius = 120; // ç¨å¾®åŠ å¤§ä¸€ç‚¹çˆ†ç‚¸èŒƒå›´è§†è§‰
    }

    update(timeScale) { 
        this.radius += 4 * timeScale; // æ‰©æ•£é€Ÿåº¦
        this.alpha -= 0.04 * timeScale; // æ¶ˆå¤±é€Ÿåº¦
    }

    draw(ctx) { 
        if(this.alpha <= 0) return; 
        ctx.save(); 
        
        // --- æ ¸å¿ƒä¿®æ”¹ï¼šè®©æ³¢çº¹å‘å…‰ ---
        ctx.globalCompositeOperation = 'lighter'; 
        ctx.globalAlpha = this.alpha;
        
        ctx.beginPath(); 
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); 
        
        // 1. å¡«å……éƒ¨ (å¾ˆæ·¡)
        ctx.fillStyle = this.color; 
        ctx.globalAlpha = this.alpha * 0.2; 
        ctx.fill();

        // 2. é«˜äº®è¾¹ç¼˜ (å†²å‡»æ³¢æœ¬ä½“)
        ctx.globalAlpha = this.alpha; 
        ctx.strokeStyle = this.color; 
        ctx.lineWidth = 4; // ç¨å¾®åŠ ç²—
        ctx.stroke(); 
        
        // 3. å†…éƒ¨çš„ä¸€åœˆç»†çº¿ (å¢åŠ å±‚æ¬¡æ„Ÿ)
        if (this.radius > 10) {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius * 0.7, 0, Math.PI*2);
            ctx.lineWidth = 1;
            ctx.globalAlpha = this.alpha * 0.5;
            ctx.stroke();
        }
        
        ctx.restore(); 
    }
}

// --- æ–°å¢ï¼šæ¿€å…‰å…‰æŸç‰¹æ•ˆ ---
class LaserBeam {
    constructor(segments, width, color) {
        this.segments = segments; // Array of Vec2 points [start, p1, p2, end]
        this.width = width;
        this.initialWidth = width;
        this.color = color;
        this.life = 1.0; 
        this.decay = 0.04; // æ¶ˆå¤±é€Ÿåº¦
    }

    update(timeScale) {
        this.life -= this.decay * timeScale;
    }

    draw(ctx) {
        if (this.life <= 0) return;
        ctx.save();
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        // ä½¿ç”¨ lighter è®©å åŠ éƒ¨åˆ†æ›´äº®
        ctx.globalCompositeOperation = 'lighter';
        
        const currentWidth = this.initialWidth * this.life;
        const opacity = Math.pow(this.life, 0.5); // éçº¿æ€§é€æ˜åº¦

        // 1. å¤–å‘å…‰ (å®½ä¸”æ·¡)
        ctx.beginPath();
        ctx.moveTo(this.segments[0].x, this.segments[0].y);
        for (let i = 1; i < this.segments.length; i++) {
            ctx.lineTo(this.segments[i].x, this.segments[i].y);
        }
        ctx.strokeStyle = this.color;
        ctx.lineWidth = currentWidth * 2.5;
        ctx.globalAlpha = opacity * 0.3;
        ctx.shadowBlur = 20;
        ctx.shadowColor = this.color;
        ctx.stroke();

        // 2. æ ¸å¿ƒå…‰æŸ (çª„ä¸”äº®)
        ctx.beginPath();
        ctx.moveTo(this.segments[0].x, this.segments[0].y);
        for (let i = 1; i < this.segments.length; i++) {
            ctx.lineTo(this.segments[i].x, this.segments[i].y);
        }
        ctx.strokeStyle = '#ffffff'; // æ ¸å¿ƒæ€»æ˜¯ç™½è‰²
        ctx.lineWidth = currentWidth;
        ctx.globalAlpha = opacity;
        ctx.shadowBlur = 10;
        ctx.stroke();

        ctx.restore();
    }
}

class FloatingText {
    /**
     * æµ®åŠ¨æ–‡å­—ç‰¹æ•ˆç±»
     * @param {number} x - x åæ ‡
     * @param {number} y - y åæ ‡
     * @param {string} text - æ–‡æœ¬
     * @param {string} [color='#fbbf24'] - é¢œè‰² (é»˜è®¤ä¸ºé‡‘è‰²)
     */
    constructor(x, y, text, color = '#fbbf24') { 
        this.pos = new Vec2(x, y); 
        this.vel = new Vec2(0, -1); // å‘ä¸Šé£„
        this.life = 1.0; 
        this.text = text; 
        this.color = color; 
    }

    update(timeScale) { 
        this.pos = this.pos.add(this.vel.mult(timeScale)); 
        this.life -= 0.02 * timeScale; 
    }

    draw(ctx) { 
        if (this.life <= 0) return;
        ctx.save();
        ctx.globalAlpha = Math.max(0, this.life); 
        ctx.font = 'bold 16px sans-serif'; 
        ctx.textAlign = 'center';
        
        // ç¹ªè£½æé‚Šè®“æ–‡å­—æ›´æ¸…æ¥š
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.lineWidth = 3;
        ctx.strokeText(this.text, this.pos.x, this.pos.y);
        
        // ç¹ªè£½å¡«å……
        ctx.fillStyle = this.color; 
        ctx.fillText(this.text, this.pos.x, this.pos.y); 
        ctx.restore();
    }
}
// --- æ–°å¢ï¼šèƒ½é‡çƒç‰¹æ•ˆ (å¸¦æ‹–å°¾çš„è´å¡å°”æ›²çº¿è¿åŠ¨) ---

// --- ä¿®æ”¹åçš„ EnergyOrb ç±»ï¼šç‰©ç†çˆ†å‘ + ç£åŠ›å¸é™„ ---
// --- ç‰©ç†ä¼˜åŒ–ç‰ˆ EnergyOrbï¼šæº…å°„ -> æ»ç©ºä¸Šæµ® -> å¼ºåŠ›å¸é™„ ---
class EnergyOrb {
    /**
     * @param {number} x èµ·å§‹X
     * @param {number} y èµ·å§‹Y
     * @param {number} targetX ç›®æ ‡UI X
     * @param {number} targetY ç›®æ ‡UI Y
     * @param {string} color é¢œè‰²
     * @param {Vec2} initialVel å¼¹ç ç¢°æ’æ—¶çš„åˆé€Ÿåº¦
     * @param {Function} onArrive åˆ°è¾¾å›è°ƒ
     */
    constructor(x, y, targetX, targetY, color, initialVel, onArrive) {
        this.pos = new Vec2(x, y);
        this.target = new Vec2(targetX, targetY);
        this.onArrive = onArrive;
        this.color = color || '#fbbf24';

        // ç‰©ç†å‚æ•°
        let burstVel = new Vec2(initialVel.x * 4.2, initialVel.y * 0.72);
        const spreadAngle = (Math.random() - 0.5) * 0.6;
        this.vel = burstVel.rotate(spreadAngle);
        
        if (this.vel.mag() < 3) {
            this.vel = this.vel.norm().mult(3);
        }

        this.active = true;
        
        // --- ä¼˜åŒ–ï¼šå‡å°‘æ‹–å°¾é•¿åº¦ ---
        this.trail = []; 
        this.maxTrailLen = 8; // åŸæ¥æ˜¯12ï¼Œå‡å°‘åˆ°8ï¼Œé™ä½ç»˜åˆ¶å¾ªç¯æ¬¡æ•°

        this.baseSize = 2.5; 
        this.timer = 0;
        this.seed = Math.random() * 100;

        this.hoverTime = 20;     
        this.friction = 0.88;    
        this.floatForce = 0.21;  
        this.suctionAcc = 0.07;  
        this.currentSuction = 0; 
    }

    update(timeScale) {
        if (!this.active) return;
        this.timer += timeScale;

        // 1. æ»ç©ºé˜»åŠ›
        this.vel = this.vel.mult(Math.pow(this.friction, timeScale));
        // 2. ä¸Šæµ®åŠ›
        this.vel.y -= this.floatForce * timeScale;

        // 3. å¸é™„é€»è¾‘
        if (this.timer > this.hoverTime) {
            let dir = this.target.sub(this.pos);
            const dist = dir.mag();

            if (dist < 20) { 
                this.active = false;
                if (this.onArrive) this.onArrive();
                return;
            }

            dir = dir.norm();
            this.currentSuction += this.suctionAcc * timeScale;
            this.vel = this.vel.add(dir.mult(this.currentSuction * timeScale));
        }

        this.pos = this.pos.add(this.vel.mult(timeScale));

        // æ›´æ–°æ‹–å°¾ (åªå­˜ç®€å•çš„ x,y å¯¹è±¡ï¼Œå‡å°‘ Vec2 å¼€é”€)
        this.trail.push({x: this.pos.x, y: this.pos.y});
        if (this.trail.length > this.maxTrailLen) this.trail.shift(); 
    }

    draw(ctx) {
        if (!this.active) return;
        ctx.save();
        
        // å…³é”®ä¼˜åŒ–ï¼šä½¿ç”¨ lighter æ··åˆæ¨¡å¼ä»£æ›¿é˜´å½±æ¥å®ç°å‘å…‰
        // è¿™æ¯” shadowBlur å¿«å¾—å¤š
        ctx.globalCompositeOperation = 'lighter'; 

        // ------------------------------------
        // 1. ç»˜åˆ¶æç®€æ‹–å°¾
        // ------------------------------------
        if (this.trail.length > 2) {
            // ä¼˜åŒ–ï¼šä¸å†åˆ†æ®µç»˜åˆ¶ä¸åŒå®½åº¦ï¼Œè€Œæ˜¯ç”»ä¸€æ¡è¿è´¯çš„çº¿
            ctx.beginPath();
            const len = this.trail.length;
            ctx.moveTo(this.trail[0].x, this.trail[0].y);
            
            // ä½¿ç”¨äºŒæ¬¡è´å¡å°”æ›²çº¿è®©æ‹–å°¾æ›´å¹³æ»‘ï¼ˆå¯é€‰ï¼Œè¿™é‡Œç”¨ç›´çº¿å¤Ÿå¿«äº†ï¼‰
            for (let i = 1; i < len; i++) {
                ctx.lineTo(this.trail[i].x, this.trail[i].y);
            }

            ctx.lineCap = 'round';
            ctx.lineWidth = this.baseSize; 
            ctx.strokeStyle = this.color;
            ctx.globalAlpha = 0.3; // ä½é€æ˜åº¦
            
            // å½»åº•ç§»é™¤å¾ªç¯å†…çš„ shadow è®¾ç½®
            ctx.shadowBlur = 0; 
            ctx.stroke();
        }

        // ------------------------------------
        // 2. ç»˜åˆ¶æ ¸å¿ƒ (æ— æ¸å˜ä¼˜åŒ–ç‰ˆ)
        // ------------------------------------
        
        // è®¡ç®—é—ªçƒ
        const flicker = 0.8 + Math.sin(this.timer * 0.5 + this.seed) * 0.2;
        
        // ç»˜åˆ¶å¤–å‘å…‰ (ç”¨åŠé€æ˜å®å¿ƒåœ†ä»£æ›¿æ¸å˜)
        ctx.beginPath();
        ctx.fillStyle = this.color;
        ctx.globalAlpha = 0.4; // é™ä½é€æ˜åº¦æ¨¡æ‹Ÿå…‰æ™•
        // å¤§å°éšé—ªçƒå˜åŒ–
        ctx.arc(this.pos.x, this.pos.y, this.baseSize * 2.5 * flicker, 0, Math.PI * 2);
        ctx.fill();

        // ç»˜åˆ¶æ ¸å¿ƒäº®ç‚¹
        ctx.beginPath();
        ctx.fillStyle = '#ffffff';
        ctx.globalAlpha = 1.0;
        ctx.arc(this.pos.x, this.pos.y, this.baseSize * 0.8, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
    }
}

class LightningBolt {
    constructor(x1, y1, x2, y2) {
        this.start = new Vec2(x1, y1);
        this.end = new Vec2(x2, y2);
        this.life = 1.0; 
        this.segments = [];
        this.generateSegments();
    }

    generateSegments() {
        const dist = this.start.dist(this.end);
        const steps = Math.floor(dist / 10); // æ¯10åƒç´ ä¸€å€‹ç¯€é»
        let current = this.start;
        const tangent = this.end.sub(this.start).norm();
        const normal = new Vec2(-tangent.y, tangent.x); // æ³•å‘é‡

        for (let i = 0; i < steps; i++) {
            const t = (i + 1) / steps;
            // ç·šæ€§æ’å€¼ä½ç½®
            const basePos = this.start.add(this.end.sub(this.start).mult(t));
            // éš¨æ©Ÿåç§» (ä¸­é–“åç§»å¤§ï¼Œå…©ç«¯å°)
            const offsetAmount = Math.sin(t * Math.PI) * 30; 
            const jitter = normal.mult((Math.random() - 0.5) * offsetAmount);
            
            const nextPos = (i === steps - 1) ? this.end : basePos.add(jitter);
            
            // ä¸»å¹¹
            this.segments.push({ p1: current, p2: nextPos, width: 3, alpha: 1.0 });

            // éš¨æ©Ÿç”Ÿæˆåˆ†æ”¯
            if (Math.random() < 0.3) {
                const branchEnd = nextPos.add(new Vec2((Math.random()-0.5)*40, (Math.random()-0.5)*40));
                this.segments.push({ p1: nextPos, p2: branchEnd, width: 1, alpha: 0.6 });
            }
            current = nextPos;
        }
    }

    update(timeScale) {
        this.life -= 0.08 * timeScale; // é–ƒé›»æ¶ˆå¤±é€Ÿåº¦
    }

    draw(ctx) {
        if (this.life <= 0) return;
        ctx.save();
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        
        // é–ƒçˆæ•ˆæœ
        const flicker = Math.random() > 0.5 ? 1 : 0.5;
        const opacity = this.life * flicker;

        this.segments.forEach(seg => {
            ctx.beginPath();
            ctx.moveTo(seg.p1.x, seg.p1.y);
            ctx.lineTo(seg.p2.x, seg.p2.y);

            // 1. ç¹ªè£½ç´«è‰²å…‰æšˆ (å¯¬ç·šæ¢)
            ctx.strokeStyle = `rgba(192, 132, 252, ${opacity * seg.alpha * 0.5})`; // Purple-400
            ctx.lineWidth = seg.width * 4;
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#c084fc';
            ctx.stroke();

            // 2. ç¹ªè£½ç™½è‰²æ ¸å¿ƒ (ç´°ç·šæ¢)
            ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * seg.alpha})`;
            ctx.lineWidth = seg.width;
            ctx.shadowBlur = 0;
            ctx.stroke();
        });
        
        // èµ·é»å’Œçµ‚é»çš„å…‰çƒ
        ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
        ctx.shadowColor = '#fff';
        ctx.shadowBlur = 10;
        ctx.beginPath(); ctx.arc(this.start.x, this.start.y, 3, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(this.end.x, this.end.y, 4, 0, Math.PI*2); ctx.fill();

        ctx.restore();
    }
}

class FireWave {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.radius = 10;
        this.maxRadius = 80; // æ“´æ•£ç¯„åœ
        this.life = 1.0;
    }

    update(timeScale) {
        this.radius += 5 * timeScale; // æ“´æ•£é€Ÿåº¦
        this.life -= 0.05 * timeScale;
    }

    draw(ctx) {
        if (this.life <= 0) return;
        ctx.save();
        // ä½¿ç”¨ lighter æ··åˆæ¨¡å¼è®“ç«ç„°çœ‹èµ·ä¾†æ›´äº®
        ctx.globalCompositeOperation = 'lighter'; 
        
        const grad = ctx.createRadialGradient(this.x, this.y, this.radius * 0.6, this.x, this.y, this.radius);
        grad.addColorStop(0, `rgba(255, 200, 0, 0)`); // ä¸­å¿ƒé€æ˜
        grad.addColorStop(0.5, `rgba(249, 115, 22, ${this.life * 0.8})`); // æ©™è‰²ç«ç„°
        grad.addColorStop(1, `rgba(255, 0, 0, 0)`); // é‚Šç·£é€æ˜

        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }
}
class UIManager {
    constructor() {
        this.drawer = document.getElementById('info-drawer');
        this.currentTab = 'status';
        this.hoveredEnemy = null;
        this.isOpen = false;
        this.spContainer = document.getElementById('sp-panel');
        const afx = CONFIG.balance.affixes;
        // è¯æ¡å­—å…¸
        // --- åœ¨ UIManager constructor ä¸­ ---
// --- åœ¨ UIManager constructor ä¸­ ---
this.affixDict = {
    'shield': { 
        name: 'ğŸ›¡ï¸ è­·ç›¾', 
        desc: `å—åˆ°çš„å‚·å®³æ¸›å°‘ ${afx.shieldReduction * 100}%ã€‚(å¯åå°„æ¿€å…‰)` 
    },
    'haste': { 
        name: 'âš¡ æ¥µé€Ÿ', 
        desc: `æ¯å›åˆå›ºå®šè¡Œç§»å‹• ${afx.hasteActions} æ¬¡ã€‚` 
    },
    'regen': { 
        name: 'ğŸ’š å†ç”Ÿ', 
        desc: `æ¯å›åˆæ¢å¾© ${afx.regenPercent * 100}% æœ€å¤§ç”Ÿå‘½å€¼ã€‚` 
    },
    'clone': { 
        name: 'ğŸ¦  å¢æ®–', 
        desc: `æ¯å›åˆé–‹å§‹å’Œå—åˆ°æ”»å‡»æ—¶ï¼Œæœ‰ ${afx.cloneChanceHit * 100}% æ¦‚ç‡äº§ç”Ÿåˆ†èº«` 
    },
    'berserk': { 
        name: 'ğŸ˜¡ ç‹‚æš´', 
        desc: 'æœ‰æ¦‚ç‡è¡ŒåŠ¨ä¸¤æ¬¡ (æ¦‚ç‡éšæ¸©åº¦å‡é«˜)' 
    },
    'healer': { 
        name: 'ğŸ’– æ²»ç™’', 
        desc: `å›åˆè¡Œå‹•æ™‚ï¼Œæ²»ç™‚å‘¨åœå‹è» (${afx.healerPercent * 100}% HP)ã€‚` 
    },
    'devour': { 
        name: 'ğŸ‘… åå™¬', 
        desc: 'éš¨æ©Ÿåå™¬ç›¸é„°å‹è»ï¼Œç¹¼æ‰¿å…¶è¡€é‡èˆ‡è©æ¢ã€‚' 
    },
    'jump': { 
        name: 'ğŸ¦˜ è·³èº', 
        desc: 'ç§»å‹•å—é˜»æ™‚ï¼Œå¯è·³éå‰æ–¹æ•µäººå‰é€²ã€‚' 
    }
};

    }

    // åˆ‡æ¢ Tab
    switchTab(tabName) {
        this.currentTab = tabName;
        // æ›´æ–°æŒ‰é’®æ ·å¼
        document.querySelectorAll('.tab-btn').forEach((btn, idx) => {
            const targets = ['status', 'affix', 'recipe'];
            if (targets[idx] === tabName) {
                btn.classList.add('active', 'text-amber-400', 'border-b-2', 'border-amber-400');
                btn.classList.remove('text-slate-400');
            } else {
                btn.classList.remove('active', 'text-amber-400', 'border-b-2', 'border-amber-400');
                btn.classList.add('text-slate-400');
            }
        });
        // åˆ‡æ¢å†…å®¹æ˜¾ç¤º
        document.querySelectorAll('.tab-content').forEach(el => el.classList.add('hidden'));
        document.getElementById(`tab-${tabName}`).classList.remove('hidden');
    }
    updateSkillBar(currentSP) {
        const container = document.getElementById('skill-bar');
        if (!container) return;
        container.innerHTML = '';

        SKILL_DB.forEach(skill => {
            const btn = document.createElement('div');
            // æ ·å¼ï¼šåœ†å½¢æŒ‰é’®ï¼Œå¸¦å†·å´é®ç½©æ•ˆæœ
            const isDisabled = currentSP < skill.cost;
            
            btn.className = `
                w-12 h-12 rounded-full border-2 flex items-center justify-center 
                text-xl shadow-lg transition-all duration-200 relative group
                ${isDisabled ? 'border-slate-600 bg-slate-800 opacity-50 cursor-not-allowed grayscale' : 'cursor-pointer hover:scale-110 active:scale-95'}
            `;
            
            // åŠ¨æ€è¾¹æ¡†é¢œè‰²
            if (!isDisabled) {
                btn.style.borderColor = skill.color;
                btn.style.background = `radial-gradient(circle, ${adjustColorBrightness(skill.color, 0.5)} 0%, #0f172a 100%)`;
                btn.style.boxShadow = `0 0 10px ${skill.color}`;
            }

            btn.innerHTML = `
                <span>${skill.icon}</span>
                <div class="absolute -bottom-2 -right-2 bg-black border border-white text-[10px] w-5 h-5 flex items-center justify-center rounded-full text-white font-bold">
                    ${skill.cost}
                </div>
            `;

            // ç‚¹å‡»äº‹ä»¶
            if (!isDisabled) {
                // 1. å®šä¹‰ä¸€ä¸ªé˜»æ­¢å†’æ³¡çš„å‡½æ•°
                const stopProp = (e) => { e.stopPropagation(); };

                // 2. å…³é”®ï¼šç›‘å¬æŒ‰ä¸‹äº‹ä»¶ï¼Œé˜²æ­¢å®ƒä»¬ç©¿é€åˆ° Canvas è§¦å‘ç„å‡†æ‹–æ‹½
                btn.addEventListener('mousedown', stopProp);
                btn.addEventListener('touchstart', stopProp, { passive: false });

                // 3. ç‚¹å‡»äº‹ä»¶å¤„ç†
                btn.onclick = (e) => {
                    e.stopPropagation(); // é˜²æ­¢è§¦å‘å…¶ä»–é€»è¾‘
                    game.activateSkill(skill);
                };
            }

            container.appendChild(btn);
        });
    }
    updateSkillPoints(current, max = Math.max(5, current + 1)) {
        this.spContainer.innerHTML = ''; // æ¸…ç©ºå½“å‰

        for (let i = 0; i < max; i++) {
            // 1. åˆ›å»ºæ§½ä½
            const slot = document.createElement('div');
            slot.className = 'sp-slot';
            
            // 2. åˆ›å»ºå®çŸ³
            const gem = document.createElement('div');
            gem.className = 'sp-gem';
            
            // 3. å¦‚æœå½“å‰ç´¢å¼• < æ‹¥æœ‰çš„ç‚¹æ•°ï¼Œåˆ™ç‚¹äº®å®çŸ³
            if (i < current) {
                gem.classList.add('active');
                slot.style.borderColor = '#10b981'; // äº®ç»¿è‰²è¾¹æ¡†
                slot.style.boxShadow = '0 0 10px rgba(16, 185, 129, 0.3)';
            }

            slot.appendChild(gem);
            this.spContainer.appendChild(slot);
        }
    }
    // æ‰“å¼€/æ›´æ–°æŠ½å±‰
    showEnemyInfo(enemy) {
        if (!enemy || !enemy.active) {
            this.closeDrawer();
            return;
        }

        this.hoveredEnemy = enemy;
        this.isOpen = true;
        this.drawer.classList.remove('translate-y-full'); // æ»‘å…¥

        // --- Tab 1: çŠ¶æ€æ›´æ–° ---
        
        // æ ‡é¢˜ä¸è¡€é‡
        const typeName = enemy.type === 'boss' ? 'ğŸ’€ BOSS' : (enemy.type === 'elite' ? 'âš ï¸ ç²¾è‹±é­”åƒ' : 'æ™®é€šé­”åƒ');
        document.getElementById('info-enemy-type').innerText = typeName;
        document.getElementById('info-enemy-type').className = enemy.type === 'boss' ? 'text-xl font-bold text-red-500' : (enemy.type === 'elite' ? 'text-lg font-bold text-yellow-400' : 'text-lg font-bold text-slate-200');
        document.getElementById('info-hp').innerText = `HP: ${Math.ceil(enemy.displayHp)}/${enemy.maxHp}`;

        // æ¸©åº¦æ¡æ›´æ–°
        const tempBar = document.getElementById('info-temp-bar');
        const tempText = document.getElementById('info-temp-text');
        
        const tempPct = Math.min(100, Math.abs(enemy.temp));
        tempBar.style.width = `${tempPct/2}%`; // 0-100 æ˜ å°„åˆ°åŠè¾¹
        
        if (enemy.temp > 0) {
            tempBar.style.left = '50%';
            tempBar.style.transformOrigin = 'left';
            tempBar.style.background = '#f97316'; // Orange
            tempText.innerText = `æº«åº¦: +${enemy.temp.toFixed(0)}Â°C (éç†±)`;
            tempText.style.color = '#fbbf24';
        } else if (enemy.temp < 0) {
            tempBar.style.left = `${50 - tempPct/2}%`;
            tempBar.style.transformOrigin = 'right';
            tempBar.style.background = '#06b6d4'; // Cyan
            tempText.innerText = `æº«åº¦: ${enemy.temp.toFixed(0)}Â°C (éå†·)`;
            tempText.style.color = '#67e8f9';
        } else {
            tempBar.style.width = '0';
            tempText.innerText = `æº«åº¦: 0Â°C (ç©©å®š)`;
            tempText.style.color = '#94a3b8';
        }

        // çŠ¶æ€åˆ—è¡¨ç”Ÿæˆ
        const statusList = document.getElementById('info-status-list');
        statusList.innerHTML = '';

        // 1. å†°å†»åˆ¤å®š
        if (enemy.isFrozenCurrentTurn || enemy.temp <= -100) {
             this.addStatusItem(statusList, 'â„ï¸ æ·±åº¦å‡çµ', 'ç„¡æ³•ç§»å‹•èˆ‡è¡Œå‹•ã€‚', 'text-cyan-300');
        } else if (enemy.temp < 0) {
            const freezeChance = Math.min(100, Math.abs(enemy.temp)) / 2;
            this.addStatusItem(statusList, 'ğŸ“‰ ä½æº«å½±éŸ¿', `ä¸‹å›åˆæœ‰ ${freezeChance.toFixed(0)}% æ¦‚ç‡è¢«å‡çµã€‚`, 'text-cyan-200');
        }

        // 2. ç‡ƒçƒ§åˆ¤å®š
        if (enemy.temp > 0) {
            if (enemy.temp >= 100) {
                const dmg = 5 + (enemy.temp - 100);
                 this.addStatusItem(statusList, 'ğŸ”¥ æ¥µé™ç‡ƒç‡’', `æ¯å›åˆå—åˆ° ${dmg.toFixed(0)} é»å‚·å®³ï¼Œä¸¦å‘å‘¨åœæ“´æ•£ã€‚`, 'text-orange-400');
            } else {
                 this.addStatusItem(statusList, 'ğŸŒ¡ï¸ éç†±ç‹€æ…‹', 'æº«åº¦ >100Â°C æ™‚è§¸ç™¼ç‡ƒç‡’å‚·å®³ã€‚', 'text-orange-200');
            }
            
            // ç‹‚æš´åˆ¤å®š
            if (enemy.affixes.includes('berserk')) {
                const berserkChance = (enemy.temp / 100) * 0.5 * 100;
                this.addStatusItem(statusList, 'ğŸ˜¡ ç†±èƒ½ç‹‚æš´', `å› éç†±ï¼Œæœ‰ ${berserkChance.toFixed(0)}% æ¦‚ç‡è¡Œå‹•å…©æ¬¡ã€‚`, 'text-red-400');
            }
        }
        
        // 3. å¯¼ç”µåˆ¤å®š (å¦‚æœæœ‰é—ªç”µæœºåˆ¶)
        if (enemy.temp < 0) {
             // å‡è®¾ï¼šä½æ¸©å¢åŠ å¯¼ç”µç‡
             const conductBonus = Math.min(100, 15 + Math.abs(enemy.temp) * 0.85);
             this.addStatusItem(statusList, 'âš¡ å°é›»é«”è³ª', `ä½æº«ä½¿é€£é–é–ƒé›»å‚³å°æ¦‚ç‡æå‡è‡³ ${(conductBonus).toFixed(0)}%ã€‚`, 'text-purple-300');
        } else {
             this.addStatusItem(statusList, 'âš¡ å°é›»é«”è³ª', `åŸºç¤é€£é–é–ƒé›»å‚³å°æ¦‚ç‡ 15%ã€‚`, 'text-purple-300/50');
        }

        // --- Tab 2: è¯æ¡æ›´æ–° ---
        const affixContainer = document.getElementById('info-affix-list');
        affixContainer.innerHTML = '';
        if (enemy.affixes.length === 0) {
            affixContainer.innerHTML = '<p class="text-slate-500 text-center italic mt-4">è©²æ•µäººç„¡ç‰¹æ®Šè©æ¢</p>';
        } else {
            enemy.affixes.forEach(affix => {
                const info = this.affixDict[affix];
                if (info) {
                    const div = document.createElement('div');
                    div.className = 'bg-slate-800 p-2 rounded border border-slate-700';
                    div.innerHTML = `<div class="font-bold text-amber-100 mb-1">${info.name}</div><div class="text-xs text-slate-400">${info.desc}</div>`;
                    affixContainer.appendChild(div);
                }
            });
        }
    }

    addStatusItem(container, title, desc, colorClass) {
        const div = document.createElement('div');
        div.className = 'flex justify-between items-start';
        div.innerHTML = `<span class="font-bold ${colorClass}">${title}</span> <span class="text-right max-w-[70%]">${desc}</span>`;
        container.appendChild(div);
    }

    closeDrawer() {
        this.isOpen = false;
        this.hoveredEnemy = null;
        this.drawer.classList.add('translate-y-full');
    }
}
// --- ä¸»æ¸¸æˆæ§åˆ¶å™¨ ---
class Game {
    /**
     * æ„é€ å‡½æ•°ï¼šåˆå§‹åŒ–æ¸¸æˆçŠ¶æ€ã€Canvas å’Œäº‹ä»¶ç›‘å¬å™¨
     */
    constructor() {
        this.canvas = document.getElementById('gameCanvas'); this.ctx = this.canvas.getContext('2d');
        this.resize();
        // çª—å£å¤§å°å˜åŒ–æ—¶é‡æ–°è°ƒæ•´ Canvas å¤§å°å¹¶é‡æ–°åˆå§‹åŒ–å¼¹ç å°å¸ƒå±€
        window.addEventListener('resize', () => { this.resize(); if (this.phase === 'gathering') this.initPachinko(); });
        this.ui = new UIManager();
        this.boardTilt = {
            current: { x: 0, y: 0 }, // å½“å‰å¹³æ»‘åçš„å€¾æ–œå€¼ (-1 ~ 1)
            target: { x: 0, y: 0 },  // ç›®æ ‡å€¾æ–œå€¼ (æ¥è‡ªä¼ æ„Ÿå™¨æˆ–é¼ æ ‡)
            enabled: false           // æ˜¯å¦å·²å¯ç”¨é™€èºä»ª
        };
        // æ¸¸æˆçŠ¶æ€å˜é‡
        this.phase = 'selection'; // å½“å‰é˜¶æ®µ ('selection', 'gathering', 'combat', 'gameover')
        this.marblesPool = []; // å¼¹ç æ± 
        this.selectedMarbles = []; // å·²é€‰æ‹©çš„å¼¹ç  (3ä¸ª)
        this.marbleQueue = []; // å¾…æ”¶é›†çš„å¼¹ç é˜Ÿåˆ—
        this.ammoQueue = []; // ç‚¼é‡‘å®Œæˆçš„å¼¹è¯é…ç½®é˜Ÿåˆ—
        this.collectionBeams = [];
        this.skillPoints = 0;

        //  ç‰¹æ€§çŠ¶æ€ç®¡ç†
        this.pinkPegCount = 0;      // ç²‰è‰²é’‰å­æ•°é‡
        this.hasCombatWall = false; // æ˜¯å¦æ‹¥æœ‰æˆ˜æ–—åº•å¢™
        this.unlockedSlots = ['skill_point']; 
        this.slotCount = 1;

        // æ¸¸æˆå®ä½“åˆ—è¡¨
        this.pegs = []; // é’‰å­ (æ”¶é›†é˜¶æ®µ)
        this.enemies = []; // æ•Œäºº (æˆ˜æ–—é˜¶æ®µ)
        this.specialSlots = []; // ç‰¹æ®Šæ§½ä½ (æ”¶é›†é˜¶æ®µ)
        this.dropBalls = []; // æ­£åœ¨ä¸‹è½çš„å¼¹ç  (æ”¶é›†é˜¶æ®µ)
        this.projectiles = []; // æ­£åœ¨é£è¡Œçš„å¼¹ä¸¸ (æˆ˜æ–—é˜¶æ®µ)
        this.particles = []; // ç²’å­ç‰¹æ•ˆ
        this.shockwaves = []; // å†²å‡»æ³¢ç‰¹æ•ˆ
        this.floatingTexts = []; // æµ®åŠ¨æ–‡å­— (å¦‚ HIT)
        this.rainbowBuffer = []; // å½©è™¹å¼¹ç åˆ†è£‚çš„ç¢ç‰‡ç¼“å­˜
        this.lightningBolts = []; // é—ªç”µç‰¹æ•ˆ
        this.pendingShots = []; // å¾…å‘å°„çš„å¼¹ä¸¸ (ç”¨äºå¤šé‡å‘å°„)
        this.burstQueue = []; // æ•£å°„å¼¹ä¸¸é˜Ÿåˆ—
        this.ownedRelics = []; // ç©å®¶å½“å‰æ‹¥æœ‰çš„é—ç‰© ID åˆ—è¡¨
        this.spores = []; // æ–°å¢ï¼šå­˜å„²åˆ†èº«å­¢å­
        this.fireWaves = []; // æ–°å¢ç«ç„°æ³¢æ•¸çµ„
        this.spores = []; // æ–°å¢ï¼šå­˜å„²åˆ†èº«å­¢å­
        this.fireWaves = []; // æ–°å¢ç«ç„°æ³¢æ•¸çµ„
        this.energyOrbs = []; //  å­˜å„²èƒ½é‡çƒ
        //  åˆå§‹åŒ–æ‰€æœ‰ç´°åˆ†æ¬Šé‡
        this.unlockedWeights = { ...CONFIG.probabilities };
        
        // ä¸‹ä¸€è¼ªä¿è­‰å‡ºç¾çš„å½ˆç é¡å‹åˆ—è¡¨
        this.guaranteedNextRound = [];

        // è¾“å…¥çŠ¶æ€
        this.isDragging = false; 
        this.dragStart = new Vec2(0,0); 
        this.dragCurrent = new Vec2(0,0); 
        this.lastMousePos = new Vec2(0,0); 
        this.currentSession = null; // å½“å‰æ”¶é›†ä¼šè¯
        this.isTiltingGrip = false;
        this.gripStartPos = new Vec2(0, 0); // æŠ“å–èµ·å§‹ç‚¹
        // æ¸¸æˆç»Ÿè®¡å’Œæ§åˆ¶
        this.gameOver = false; 
        this.defeatLineY = 570; // æ•Œäººåˆ°è¾¾æ­¤çº¿æ¸¸æˆå¤±è´¥
        this.timeScale = 1.0; // æ—¶é—´ç¼©æ”¾ (åŠ é€Ÿ/å‡é€Ÿ)
        this.round = 1; // å½“å‰æ³¢æ•°
        this.score = 0; // åˆ†æ•°
        this.scoreMultiplier = 1.0; // åˆ†æ•°ä¹˜æ•°
        this.hudExpanded = false; // æˆ˜æ–— HUD æ˜¯å¦å±•å¼€
        this.roundDamage = 0; // æœ¬å›åˆé€ æˆçš„ä¼¤å®³
        this.prevRoundDamage = 0; // ä¸Šå›åˆé€ æˆçš„ä¼¤å®³

        // --- æ–°å¢ï¼šæ•µäººå›åˆæ§åˆ¶è®Šé‡ ---
        this.isEnemyTurn = false;      // æ˜¯å¦è™•æ–¼æ•µäººè¡Œå‹•éšæ®µ
        this.enemyTurnTimer = 0;       // è¨ˆæ™‚å™¨
        //  æ‰«ææ³¢ç›¸å…³å˜é‡
        this.enemyWaveY = 0;       // æ³¢å½“å‰çš„ Y åæ ‡
        this.enemyWaveActive = false; // æ³¢æ˜¯å¦æ­£åœ¨è¿è¡Œ
        this.waveSpeed = 4;        // æ³¢çš„ç§»åŠ¨é€Ÿåº¦ (åƒç´ /å¸§)
        this.waveMomentumTimer = 0;
        this.nextRoundHpMultiplier = 1; // é»˜è®¤ä¸º 1 (æ­£å¸¸è¡€é‡)
        // ---------------------------

        this.setupInputs(); 
        this.initGameStart(); 
        
        // å¯åŠ¨æ¸¸æˆä¸»å¾ªç¯ (ä¿®å¤äº†åŸå§‹çš„ this.loop is not a function é”™è¯¯
        this.currentRows = CONFIG.gameplay.rows; 
        this.boardBottomY = 0;
        this.loop();
    }

    /**
     * @method loop
     * @description æ¸¸æˆä¸»å¾ªç¯
     */
    loop() {
        // 1. æ¸…ç†ç”»å¸ƒ
        this.ctx.clearRect(0, 0, this.width, this.height);
        this.ctx.fillStyle = CONFIG.colors.bg;
        this.ctx.fillRect(0, 0, this.width, this.height);

        const timeScale = this.timeScale; 

        // --- [æ ¸å¿ƒä¿®å¤ 1]ï¼šå…¨å±€å€¾æ–œå¹³æ»‘è®¡ç®— ---
        // æ— è®ºåœ¨å“ªä¸ªé˜¶æ®µï¼Œéƒ½è¦æ›´æ–°å½“å‰çš„å€¾æ–œè§’åº¦ï¼Œå¦åˆ™æˆ˜æ–—é˜¶æ®µé™€èºä»ªä¼šå¤±æ•ˆ
        const smoothSpeed = 0.05 * timeScale;
        this.boardTilt.current.x += (this.boardTilt.target.x - this.boardTilt.current.x) * smoothSpeed;
        this.boardTilt.current.y += (this.boardTilt.target.y - this.boardTilt.current.y) * smoothSpeed;

        // --- [æ ¸å¿ƒä¿®å¤ 2]ï¼šèƒŒæ™¯ç½‘æ ¼ ---
        // ä»…åœ¨ã€éæˆ˜æ–—ã€‘é˜¶æ®µç»˜åˆ¶åŸºç¡€ç½‘æ ¼ã€‚
        // æˆ˜æ–—é˜¶æ®µç”± updateCombat é‡Œçš„ 3D è§†å·®ç½‘æ ¼æ¥ç®¡ï¼Œé¿å…åŒé‡ç½‘æ ¼ã€‚
        if (this.phase !== 'combat') {
            this.ctx.save();
            const gridSpacing = 40;
            // è·å–å½“å‰çš„å€¾æ–œåç§» (ä¸»è¦ç”¨äºæ”¶é›†é˜¶æ®µçš„è§†å·®)
            const tiltX = -this.boardTilt.current.x * 15; 
            const tiltY = this.boardTilt.current.y * 10;
            
            this.ctx.strokeStyle = 'rgba(71, 85, 105, 0.15)'; 
            this.ctx.lineWidth = 1;

            // ç»˜åˆ¶ç«–çº¿
            for (let x = (tiltX % gridSpacing); x < this.width; x += gridSpacing) {
                this.ctx.beginPath(); this.ctx.moveTo(x, 0); this.ctx.lineTo(x, this.height); this.ctx.stroke();
            }
            // ç»˜åˆ¶æ¨ªçº¿
            for (let y = (tiltY % gridSpacing); y < this.height; y += gridSpacing) {
                this.ctx.beginPath(); this.ctx.moveTo(0, y); this.ctx.lineTo(this.width, y); this.ctx.stroke();
            }
            this.ctx.restore();
        }

        // 3. é˜¶æ®µåˆ†å‘
        if (this.phase === 'gathering') {
            this.updateGathering(timeScale);
        } else if (this.phase === 'combat') {
            this.updateCombat(timeScale);
        }

        // 4. å…¨å±€æµ®åŠ¨æ–‡å­—æ›´æ–°
        for (let i = this.floatingTexts.length - 1; i >= 0; i--) {
            this.floatingTexts[i].update(timeScale);
            this.floatingTexts[i].draw(this.ctx);
            if (this.floatingTexts[i].life <= 0) {
                this.floatingTexts.splice(i, 1);
            }
        }

        requestAnimationFrame(() => this.loop());
    }

    /**
     * @method resize
     * @description å“åº”çª—å£å¤§å°å˜åŒ–ï¼Œè°ƒæ•´ Canvas å°ºå¯¸å’Œæ¸¸æˆå¸ƒå±€å‚æ•°ã€‚
     */
    resize() {
        const container = document.getElementById('game-container'); 
        
        // --- ä¿®æ”¹å¼€å§‹ï¼šå¼ºåˆ¶ JS åŒæ­¥çª—å£é«˜åº¦ï¼Œè§£å†³éƒ¨åˆ†å®‰å“æµè§ˆå™¨å…¼å®¹é—®é¢˜ ---
        // è¿™ä¸€æ­¥ä¼šè¦†ç›– CSS çš„è®¾ç½®ï¼Œç¡®ä¿ canvas åˆšå¥½å¡«æ»¡å¯è§†åŒºåŸŸ
        container.style.height = `${window.innerHeight}px`;
        container.style.width = `${window.innerWidth}px`;
        // --- ä¿®æ”¹ç»“æŸ ---

        this.width = this.canvas.width = container.clientWidth; 
        this.height = this.canvas.height = container.clientHeight; 
        
        // åŠ¨æ€è°ƒæ•´å¤±è´¥åˆ¤å®šçº¿ï¼Œé˜²æ­¢åœ¨çŸ®å±å¹•ä¸Šå¤ªé«˜
        // å»ºè®®æ”¹ä¸ºç™¾åˆ†æ¯”ï¼Œè€Œä¸æ˜¯å›ºå®šçš„ -150
        this.defeatLineY = this.height - 120; // ç¨å¾®è°ƒä½ä¸€ç‚¹ï¼Œç»™åº•éƒ¨ UI ç•™ç©ºé—´
        
        this.enemyWidth = (this.width / CONFIG.gameplay.enemyCols); 
        this.enemyHeight = this.enemyWidth; 
        this.updateUICache();
        // å¦‚æœæ˜¯åœ¨æ”¶é›†é˜¶æ®µï¼Œä¸”å·²ç»åˆå§‹åŒ–è¿‡ï¼Œå¯èƒ½éœ€è¦é‡æ–°è®¡ç®—é’‰å­ä½ç½®ï¼ˆå¯é€‰ï¼‰
        // if (this.phase === 'gathering') this.initPachinko();
    }
    /**
     * @method initGameStart
     * @description åˆå§‹åŒ–æ¸¸æˆå¼€å§‹çŠ¶æ€ (ç”Ÿæˆåˆå§‹æ•Œäººå’Œè¿›å…¥é€‰æ‹©é˜¶æ®µ)ã€‚
     */
    initGameStart() {
        const startY = 80; 
        // æ ¹æ®é…ç½®ç”Ÿæˆåˆå§‹æ•Œäººè¡Œ
        for(let i=0; i<CONFIG.gameplay.startRows; i++) { 
            this.spawnEnemyRowAt(startY + i * this.enemyHeight); 
        }
        this.showRelicSelection();
        // this.initSelectionPhase(); // è¿›å…¥å¼¹ç é€‰æ‹©é˜¶æ®µ
    }
    resetGame() {
        this.gameOver = false;
        this.round = 1;
        this.score = 0;
        this.scoreMultiplier = 1.0;
        
        // [é—œéµ] é‡ç½®è§£é–æ¬Šé‡å›åˆå§‹ç‹€æ…‹
        this.unlockedWeights = { ...CONFIG.probabilities }; // å›åˆ°åªæœ‰ white å’Œ bounce çš„ç‹€æ…‹
        this.guaranteedNextRound = [];
        this.ownedRelics = []; // æ¸…ç©ºéºç‰©
        
        // æ¸…ç©ºå¯¦é«”
        this.enemies = [];
        this.projectiles = [];
        this.dropBalls = [];
        this.ammoQueue = [];
        this.marbleQueue = [];
        this.energyOrbs = [];
        this.spores = [];
        this.currentRows = CONFIG.gameplay.rows;
        this.skillPoints = 0; // é‡ç½®
        this.ui.updateSkillPoints(this.skillPoints);

        // é‡æ–°ç”Ÿæˆåˆå§‹æ•µäºº
        this.spawnEnemyRow(CONFIG.gameplay.startRows);
        
        // é€²å…¥é¸æ“‡éšæ®µ
        // this.initSelectionPhase();
        this.showRelicSelection();
        // é‡ç½® UI
        document.getElementById('combat-message').innerHTML = '';
        document.getElementById('score-num').innerText = '0';
        document.getElementById('round-num').innerText = '1';
    }
    /**
     * @method setupInputs
     * @description è®¾ç½®æ‰€æœ‰è¾“å…¥äº‹ä»¶ç›‘å¬å™¨ï¼ˆé¼ æ ‡/è§¦æ‘¸ã€æŒ‰é’®ç‚¹å‡»ï¼‰ã€‚
     */
    setupInputs() {
        // è¾…åŠ©å‡½æ•°ï¼šè·å–é¼ æ ‡/è§¦æ‘¸åœ¨ Canvas ä¸Šçš„ç›¸å¯¹ä½ç½®
        const handler = (e) => {
            const rect = this.canvas.getBoundingClientRect(); 
            const x = (e.touches && e.touches.length > 0) ? e.touches[0].clientX : e.clientX; 
            const y = (e.touches && e.touches.length > 0) ? e.touches[0].clientY : e.clientY; 
            return new Vec2(x - rect.left, y - rect.top);
        };
        // ç»‘å®šè¾“å…¥äº‹ä»¶åˆ° Canvas å’Œ Window
        this.canvas.addEventListener('mousedown', e => this.handleInputStart(handler(e))); 
        this.canvas.addEventListener('touchstart', e => this.handleInputStart(handler(e)), {passive: false});
        window.addEventListener('mousemove', e => this.handleInputMove(handler(e), e)); 
        window.addEventListener('touchmove', e => this.handleInputMove(handler(e), e), {passive: false});
        window.addEventListener('mouseup', () => this.handleInputEnd()); 
        window.addEventListener('touchend', () => this.handleInputEnd());
        document.getElementById('confirm-selection-btn').onclick = () => this.confirmSelection(); // ç¡®è®¤é€‰æ‹©æŒ‰é’®

        // é€Ÿåº¦æ§åˆ¶æŒ‰é’®
        const speedBtn = document.getElementById('speed-btn'); 
        speedBtn.onclick = () => { 
            if (this.timeScale === 1.0) this.timeScale = 2.0; 
            else if (this.timeScale === 2.0) this.timeScale = 0.5; 
            else this.timeScale = 1.0; 
            speedBtn.innerText = `â© x${this.timeScale}`; // æ›´æ–°æŒ‰é’®æ–‡æœ¬
        };
        // é™éŸ³æŒ‰é’®
        const muteBtn = document.getElementById('mute-btn'); 
        muteBtn.onclick = () => { 
            audio.resume(); // ç¡®ä¿éŸ³é¢‘ä¸Šä¸‹æ–‡å·²æ¿€æ´»
            const isMuted = audio.toggleMute(); 
            muteBtn.innerText = isMuted ? 'ğŸ”‡' : 'ğŸ”Š'; 
        };
        //  é™€èºä»ªæƒé™ç”³è¯·ä¸ç›‘å¬
        // æ³¨æ„ï¼šiOS 13+ éœ€è¦ç”¨æˆ·äº¤äº’ï¼ˆç‚¹å‡»ï¼‰æ‰èƒ½ç”³è¯·æƒé™
        const enableGyro = async () => {
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                try {
                    const permission = await DeviceOrientationEvent.requestPermission();
                    if (permission === 'granted') {
                        this.boardTilt.enabled = true;
                        window.addEventListener('deviceorientation', e => this.handleOrientation(e));
                    }
                } catch (e) { console.log("Gyro permission failed", e); }
            } else if ('ondeviceorientation' in window) {
                // é iOS è®¾å¤‡é€šå¸¸ç›´æ¥æ”¯æŒ
                this.boardTilt.enabled = true;
                window.addEventListener('deviceorientation', e => this.handleOrientation(e));
            }
        };

        // å°†æƒé™ç”³è¯·ç»‘å®šåˆ°ç¬¬ä¸€æ¬¡ç‚¹å‡»
        const initialClickHandler = () => {
            enableGyro();
            // ç§»é™¤ç›‘å¬ï¼Œé¿å…æ¯æ¬¡ç‚¹å‡»éƒ½ç”³è¯·
            window.removeEventListener('click', initialClickHandler);
            window.removeEventListener('touchstart', initialClickHandler);
        };
        window.addEventListener('click', initialClickHandler);
        window.addEventListener('touchstart', initialClickHandler);
    }
    // åœ¨ Game ç±»ä¸­æ·»åŠ 
    addSkillPoint(amount = 1) {
        this.skillPoints += amount;
        this.ui.updateSkillPoints(this.skillPoints);
    }
    //  å¤„ç†è®¾å¤‡å€¾æ–œ
    handleOrientation(e) {
        if (!this.boardTilt.enabled) return;
        
        // gamma: å·¦å€¾/å³å€¾ (-90 ~ 90)
        // beta:  å‰å€¾/åå€¾ (-180 ~ 180)
        
        // é™åˆ¶æœ€å¤§å€¾æ–œè§’åº¦ (ä¾‹å¦‚ 15åº¦)ï¼Œå¹¶å½’ä¸€åŒ–åˆ° -1 ~ 1
        const maxTilt = 2; 
        
        let x = e.gamma || 0;
        let y = e.beta || 0;
        
        // ä¿®æ­£ï¼šé€šå¸¸æ‰‹æœºç«–æ‹¿æ—¶ beta çº¦ä¸º 45-90åº¦ã€‚æˆ‘ä»¬éœ€è¦ç›¸å¯¹äºâ€œç«–ç›´æ¡æŒâ€çš„åç§»ã€‚
        // è¿™é‡Œç®€åŒ–å¤„ç†ï¼šå‡è®¾ beta 60åº¦æ˜¯åŸºå‡†
        y = y - 60; 

        // é’³åˆ¶èŒƒå›´
        x = Math.max(-maxTilt, Math.min(maxTilt, x));
        y = Math.max(-maxTilt, Math.min(maxTilt, y));
        
        this.boardTilt.target.x = x / maxTilt; 
        this.boardTilt.target.y = y / maxTilt;
    }
    /**
     * @method createFloatingText
     * @description å‰µå»ºé€šç”¨æµ®å‹•æ–‡å­— (ä¿®å¾©å ±éŒ¯çš„é—œéµ)
     * @param {number} x - ä½ç½® X
     * @param {number} y - ä½ç½® Y
     * @param {string} text - æ–‡å­—å…§å®¹
     * @param {string} [color] - æ–‡å­—é¡è‰² (å¯é¸)
     */
    createFloatingText(x, y, text, color) { 
        this.floatingTexts.push(new FloatingText(x, y, text, color)); 
    }
    // --- [æ–°å¢] æ›´æ–°é€£å°„å€ç‡ UI ---
    updateMulticastDisplay(bonusAmount = 0) {
        // åŸºç¤æ˜¯ 1ï¼ŒåŠ ä¸Šç•¶å‰ç´¯ç©çš„ multicast
        const total = 1 + (this.currentSession ? this.currentSession.multicast : 0);
        
        const ui = document.getElementById('multicast-ui');
        const num = document.getElementById('multicast-num');
        
        if (ui && num) {
            // é¡¯ç¤º UI
            ui.classList.add('multicast-visible');
            
            // æ›´æ–°æ•¸å­—
            num.innerText = `x${total}`;
            
            // å¦‚æœæœ‰å¢åŠ  (bonusAmount > 0)ï¼Œæ’­æ”¾ç‰¹æ•ˆ
            if (bonusAmount > 0) {
                // 1. å®¹å™¨å½ˆè·³
                ui.classList.remove('multicast-pop');
                void ui.offsetWidth; // é‡ç¹ª
                ui.classList.add('multicast-pop');
                
                // 2. æ–‡å­—é–ƒç™½
                num.classList.add('multicast-flash');
                setTimeout(() => num.classList.remove('multicast-flash'), 300);
            }
        }
    }

    // --- [æ–°å¢] æ’­æ”¾å€ç‡è½‰ç§»é£›è¡Œç‰¹æ•ˆ ---
    playMulticastTransferEffect(multicastValue) {
        // 1. ç²å–èµ·é» (å³ä¸‹è§’å€ç‡ UI)
        const startEl = document.getElementById('multicast-ui');
        // 2. ç²å–çµ‚é» (å·¦å´ç•¶å‰é…æ–¹å¡ç‰‡)
        // æ³¨æ„ï¼šactiveMarbleIndex å°æ‡‰çš„æ˜¯ gathering-hud-mount è£¡çš„ç¬¬ N å€‹å­å…ƒç´ 
        const targetEl = document.querySelector(`#gathering-hud-mount .recipe-card:nth-child(${this.activeMarbleIndex + 1})`);

        if (!startEl || !targetEl) return;

        const startRect = startEl.getBoundingClientRect();
        const targetRect = targetEl.getBoundingClientRect();

        // 3. å‰µå»ºé£›è¡Œå…ƒç´ 
        const flyer = document.createElement('div');
        flyer.className = 'flying-badge';
        flyer.innerText = `x${multicastValue}`;
        
        // åˆå§‹ä½ç½® (è¨­ç½®åœ¨èµ·é»)
        // è¨ˆç®—ä¸­å¿ƒé»åç§»
        const startX = startRect.left + startRect.width / 2 - 20; // 20æ˜¯å¯¬åº¦çš„ä¸€åŠ
        const startY = startRect.top + startRect.height / 2 - 20;
        
        flyer.style.left = `${startX}px`;
        flyer.style.top = `${startY}px`;
        flyer.style.transform = 'scale(1.2)'; // èµ·é£›æ™‚ç¨å¾®æ”¾å¤§

        document.body.appendChild(flyer);

        // 4. åŸ·è¡Œé£›è¡Œ (ä¸‹ä¸€å¹€è¨­ç½®çµ‚é»ä½ç½®ä»¥è§¸ç™¼ transition)
        requestAnimationFrame(() => {
            const targetX = targetRect.left + targetRect.width / 2 - 20;
            const targetY = targetRect.top + targetRect.height / 2 - 20;

            flyer.style.left = `${targetX}px`;
            flyer.style.top = `${targetY}px`;
            flyer.classList.add('arrived'); // é…åˆ CSS è®Šå°è®Šæ·¡
        });

        // 5. é£›è¡ŒçµæŸå¾Œæ¸…ç†ä¸¦è§¸ç™¼å¡ç‰‡é«˜äº®
        setTimeout(() => {
            flyer.remove();
            
            // è®“ç›®æ¨™å¡ç‰‡é–ƒä¸€ä¸‹ï¼Œè¡¨ç¤ºæ¥æ”¶åˆ°äº†å€ç‡
            targetEl.style.transition = 'none';
            targetEl.style.filter = 'brightness(2) drop-shadow(0 0 10px orange)';
            targetEl.style.transform = 'scale(1.1)';
            
            setTimeout(() => {
                targetEl.style.transition = 'all 0.3s';
                targetEl.style.filter = 'none';
                targetEl.style.transform = 'scale(1)';
            }, 100);

            // æ’­æ”¾éŸ³æ•ˆ
            audio.playCollect(); 
        }, 600); // é€™è£¡çš„æ™‚é–“è¦å’Œ CSS transition åŒ¹é…
    }
    // --- æ•Œäººç”Ÿæˆä¸è¯ç¼€ç³»ç»Ÿ ---
    /**
     * éšæœºç”Ÿæˆæ•Œäººè¯ç¼€
     * @returns {string[]} è¯ç¼€æ•°ç»„
     */
    /**
     * @method generateAffixes
     * @description éšæœºç”Ÿæˆæ•Œäººçš„è¯ç¼€åˆ—è¡¨ã€‚
     * @returns {Array<string>} è¯ç¼€åˆ—è¡¨ã€‚
     */
    generateAffixes() {
        if (this.round <= 3) return [];

        const affixes = [];
        const possible = ['shield', 'haste', 'regen', 'clone','healer', 'devour', 'jump'];
        // --- ä¿®æ”¹å¼€å§‹ï¼šä½¿ç”¨ CONFIG.balance ---
        // è®¡ç®—è·å¾—è¯ç¼€çš„æ¦‚ç‡
        const chance = CONFIG.balance.affixBaseChance + (this.round * CONFIG.balance.affixRoundGrowth);
        // ç®€å•é€»è¾‘ï¼šæ ¹æ®æ¦‚ç‡å†³å®šè·å¾—1ä¸ªæˆ–2ä¸ªè¯ç¼€
        const count = Math.random() < (chance * 0.5) ? 2 : (Math.random() < chance ? 1 : 0);
        // --- ä¿®æ”¹ç»“æŸ ---
        
        for(let i=0; i<count; i++) {
            const af = possible[Math.floor(Math.random()*possible.length)];
            if(!affixes.includes(af)) affixes.push(af);
        }
        return affixes;
    }
    /**
     * @method isAreaOccupied
     * @description æª¢æŸ¥æŒ‡å®šå€åŸŸæ˜¯å¦è¢«å…¶ä»–æ•µäººä½”ç”¨ (ä¿®æ­£ç‰ˆï¼šåŸºäºé€»è¾‘ç›®æ ‡ä½ç½®åˆ¤æ–­)
     */
    isAreaOccupied(x, y, w, h, excludeEnemy = null) {
        // å®šç¾©æ£€æµ‹åŒºåŸŸçš„é‚Šç•Œ
        const l1 = x - w / 2;
        const r1 = x + w / 2;
        const t1 = y - h / 2;
        const b1 = y + h / 2;

        for (let e of this.enemies) {
            if (!e.active || e === excludeEnemy) continue;

            // --- [æ ¸å¿ƒä¿®å¤] ---
            // ä½¿ç”¨ dropTargetY (é€»è¾‘ä¸Šçš„ç›®æ ‡ä½ç½®) è€Œä¸æ˜¯ pos.y (å½“å‰çš„åŠ¨ç”»ä½ç½®)
            // è¿™æ ·å½“åº•éƒ¨æ•Œäººå†³å®šç§»åŠ¨åï¼Œä¸Šæ–¹æ•Œäººç«‹åˆ»å°±èƒ½çŸ¥é“è¯¥æ ¼å­åœ¨é€»è¾‘ä¸Šå·²ç»ç©ºå‡ºæ¥äº†
            const enemyY = e.dropTargetY; 
            const enemyX = e.pos.x; // Xè½´é€šå¸¸ä¸æ”¹å˜ï¼Œç”¨ pos.x å³å¯

            // æ‰‹åŠ¨è®¡ç®—è¾¹ç•Œï¼Œä»£æ›¿ e.getBounds()
            const eLeft = enemyX - e.width / 2;
            const eRight = enemyX + e.width / 2;
            const eTop = enemyY - e.height / 2;
            const eBottom = enemyY + e.height / 2;

            // AABB ç¢°æ’æª¢æ¸¬ (ä¿ç•™ margin é˜²æ­¢è¾¹ç¼˜è¯¯è§¦)
            const margin = 2;
            if (l1 < eRight - margin &&
                r1 > eLeft + margin &&
                t1 < eBottom - margin &&
                b1 > eTop + margin) {
                return true;
            }
        }
        return false;
    }
    /**
     * @method spawnEnemyRowAt
     * @description åœ¨æŒ‡å®š Y åæ ‡ç”Ÿæˆä¸€æ’æ•Œäºº (åŒ…å«åˆæœŸæœºä¼šæœºåˆ¶)
     */
    spawnEnemyRowAt(yPos) {
        const b = CONFIG.balance;
        const baseHP = Math.floor(b.enemyBaseHp + (this.round * b.enemyHpPerRound) * this.nextRoundHpMultiplier);
        const w = this.enemyWidth;
        
        // æ¨™è¨˜è¢«ä½”ç”¨çš„åˆ— (0-9)
        const occupiedCols = Array(CONFIG.gameplay.enemyCols).fill(false);
        
        // --- 1. Boss / Elite ç”Ÿæˆé€»è¾‘ (ä¿æŒä¸å˜ï¼Œç•¥) ---
        if (this.round > 3 && Math.random() < b.eliteChance) {
             // ... (è¿™é‡Œä¿ç•™ä½ åŸæœ‰çš„ Boss/Elite ç”Ÿæˆä»£ç ) ...
             // è®°å¾—åŒæ­¥æ›´æ–° occupiedCols æ•°ç»„
             // å‡è®¾ä½ ä¹‹å‰çš„ä»£ç åœ¨è¿™é‡Œå·²ç»å¤„ç†å¥½äº† occupiedCols
        }

        // --- 2.  æœºä¼šç”Ÿæˆå™¨ï¼šè®¾è®¡å…³å¡å¸ƒå±€ ---
        // ä»…åœ¨é Boss è¦†ç›–çš„åŒºåŸŸç”Ÿæ•ˆï¼Œä¸”åœ¨åˆæœŸ (å‰15å…³) æ¦‚ç‡æ›´é«˜ï¼Œç»™ç©å®¶ä¸€ç§â€œå¯ä»¥çªç ´â€çš„æ„Ÿè§‰
        let layoutType = 'random'; 
        const helpChance = this.round < 8 ? 0.7 : 0.3; // å‰8å…³æœ‰70%æ¦‚ç‡å‡ºç°ç‰¹æ®Šå¸ƒå±€

        if (Math.random() < helpChance) {
            const types = ['gap', 'weak_spot', 'checkerboard'];
            layoutType = types[Math.floor(Math.random() * types.length)];
        }

        // ç­–ç•¥ A: [ç¼ºå£] å¼ºåˆ¶ç•™ç©ºä¸€åˆ—ï¼Œåˆ¶é€ â€œé’»å…¥åæ’â€çš„é€šé“
        if (layoutType === 'gap') {
            const gapCol = Math.floor(Math.random() * CONFIG.gameplay.enemyCols);
            if (!occupiedCols[gapCol]) {
                occupiedCols[gapCol] = true; // æ ‡è®°ä¸ºå ç”¨ï¼Œä½†ä¸ç”Ÿæˆæ•Œäºº -> å˜ä¸ºç©ºæ ¼
            }
        }
        
        // ç­–ç•¥ B: [å¼±ç‚¹] ç”Ÿæˆä¸€ä¸ª 1 HP çš„æ•Œäººï¼Œä¸€è§¦å³ç¢çš„â€œå¤§é—¨â€
        let weakSpotCol = -1;
        if (layoutType === 'weak_spot') {
            // æ‰¾ä¸€ä¸ªæ²¡è¢«å ç”¨çš„ç©ºä½
            const freeIndices = occupiedCols.map((occupied, idx) => occupied ? -1 : idx).filter(idx => idx !== -1);
            if (freeIndices.length > 0) {
                weakSpotCol = freeIndices[Math.floor(Math.random() * freeIndices.length)];
            }
        }

        // ç­–ç•¥ C: [æ£‹ç›˜] å¼ºåˆ¶éš”ä¸€ä¸ªç”Ÿæˆä¸€ä¸ªï¼Œå®¹æ˜“äº§ç”Ÿæ–œå‘åå¼¹
        if (layoutType === 'checkerboard') {
            const parity = Math.random() > 0.5 ? 0 : 1; // å¶æ•°æˆ–å¥‡æ•°
            for (let c = 0; c < CONFIG.gameplay.enemyCols; c++) {
                if (c % 2 === parity) {
                    occupiedCols[c] = true; // è¿™äº›åˆ—å¼ºåˆ¶ç•™ç©º
                }
            }
        }

        // --- 3. å¡«å……æ™®é€šæ•Œäºº (ä¿®æ”¹ç‰ˆ) ---
        const minEnemies = Math.min(CONFIG.gameplay.enemyCols, CONFIG.gameplay.spawnMin + Math.floor(this.round / 4));
        let currentCount = occupiedCols.filter(x => x).length; // æ³¨æ„ï¼šå¦‚æœæ˜¯ gap ç­–ç•¥ï¼Œè¿™é‡Œçš„ count ä¼šè™šé«˜ï¼Œä½†è¿™æ­£æ˜¯æˆ‘ä»¬è¦çš„ï¼ˆç”Ÿæˆæ›´å°‘çš„æ€ªï¼‰
        
        // è·å–æ‰€æœ‰æœªå ç”¨çš„åˆ—
        let freeCols = [];
        for(let c=0; c<CONFIG.gameplay.enemyCols; c++) {
            if(!occupiedCols[c]) freeCols.push(c);
        }
        
        // æ´—ç‰Œ
        for (let i = freeCols.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [freeCols[i], freeCols[j]] = [freeCols[j], freeCols[i]];
        }

        // ç”Ÿæˆ
        for (let c of freeCols) {
            const centerX = c * w + w / 2;
            
            // åŸºç¡€ç”Ÿæˆåˆ¤å®š
            let shouldSpawn = false;
            
            // å¦‚æœæ˜¯å¼±ç‚¹ä½ç½®ï¼Œå¼ºåˆ¶ç”Ÿæˆ
            if (c === weakSpotCol) shouldSpawn = true;
            // å¦åˆ™æŒ‰æ¦‚ç‡æˆ–æœ€å°æ•°é‡ç”Ÿæˆ
            else if (currentCount < minEnemies || Math.random() < b.spawnProb) shouldSpawn = true;

            if (shouldSpawn && !this.isAreaOccupied(centerX, yPos, w * 0.8, this.enemyHeight * 0.8)) {
                
                // å†³å®šè¡€é‡
                let hp = Math.floor(baseHP * (0.8 + Math.random() * 0.4));
                
                // [åº”ç”¨å¼±ç‚¹ç­–ç•¥]ï¼šå¦‚æœæ˜¯é€‰å®šçš„å¼±ç‚¹åˆ—ï¼Œè¡€é‡å¼ºåˆ¶è®¾ä¸º 1 (æˆ–è€…æä½)
                if (c === weakSpotCol) {
                    hp = 1; 
                }

                const e = new Enemy(centerX, yPos, w, this.enemyHeight, hp);
                e.affixes = this.generateAffixes();
                if (e.affixes.length > 0) e.type = 'elite'; 
                
                // [è§†è§‰æš—ç¤º] å¦‚æœæ˜¯å¼±ç‚¹æ€ªï¼Œå“ªæ€•å®ƒæ˜¯æ™®é€šæ€ªï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥ç¨å¾®æ”¹ä¸€ä¸‹é¢œè‰²æˆ–å»æ‰è¯ç¼€ï¼Œè®©å®ƒçœ‹èµ·æ¥å¥½æ¬ºè´Ÿ
                if (c === weakSpotCol) {
                    e.affixes = []; // å¼±ç‚¹æ€ªä¸å¸¦è¯ç¼€
                    // ä¹Ÿå¯ä»¥åœ¨ Enemy.draw é‡Œåˆ¤æ–­ hp=1 æ—¶ç”»ä¸ªè£‚çº¹ï¼Œæˆ–è€…ç®€å•çš„ï¼š
                    e.maxHp = 1; // ç¡®ä¿è¡€æ¡æ˜¾ç¤ºä¹Ÿæ˜¯æ»¡çš„ä½†æ˜¯å¾ˆçŸ­
                }

                this.enemies.push(e);
                currentCount++;
            }
        }
    }
    addSkillPoint(amount = 1) {
        this.skillPoints += amount;
        this.ui.updateSkillPoints(this.skillPoints);
        this.ui.updateSkillBar(this.skillPoints); // <--- [æ–°å¢] æ›´æ–°æŠ€èƒ½æ çŠ¶æ€
    }

    /**
     * @method startCombatPhase
     * @description å¼€å§‹æˆ˜æ–—é˜¶æ®µï¼Œåˆå§‹åŒ–æ•Œäººå’ŒUIã€‚
     */
    startCombatPhase() { 
        this.energyOrbs = [];
        this.switchPhase('combat'); 
        
        // --- [æ ¸å¿ƒä¿®å¤ 1]ï¼šæ˜¾å¼ç”Ÿæˆå¼¹è¯é˜Ÿåˆ— ---
        this.ammoQueue = this.marbleQueue.map(item => {
            const hasMulticast = item.collected.includes('multicast'); 
            // [ä¿®å¤ç‚¹]ï¼šè¿™é‡ŒåŸæ¥å†™çš„æ˜¯ item.defï¼Œæ”¹ä¸º item
            // å› ä¸º marbleQueue é‡Œçš„å…ƒç´ æœ¬èº«å°±æ˜¯ MarbleDefinition å®šä¹‰
            return this.compileCollectionToRecipe(item, item.collected, hasMulticast);
        });

        // --- [æ ¸å¿ƒä¿®å¤ 2]ï¼šçŠ¶æ€é‡ç½® ---
        this.resetMultiplier(); 
        this.burstQueue = []; 
        this.pendingShots = []; 
        
        // --- [æ ¸å¿ƒä¿®å¤ 3]ï¼šæ›´æ–°æŠ€èƒ½ä¸ UI ---
        if (this.ui) {
            this.ui.updateSkillPoints(this.skillPoints);
            this.ui.updateSkillBar(this.skillPoints);
        }

        // --- [æ ¸å¿ƒä¿®å¤ 4]ï¼šç«‹å³æ¸²æŸ“å·¦ä¾§é…æ–¹åˆ—è¡¨ ---
        // ä¿®å¤åï¼Œä»£ç ä¸å†æŠ¥é”™ï¼Œè¿™ä¸€è¡Œå°†è¢«æ­£ç¡®æ‰§è¡Œï¼ŒHUD ä¼šç«‹å³å‡ºç°
        this.renderRecipeHUD(); 
    }
    // åœ¨ Game ç±»ä¸­
    activateSkill(skill) {
        if (this.phase !== 'combat' || this.isEnemyTurn || this.skillPoints < skill.cost) return;

        // 1. æ‰£é™¤æ¶ˆè€—
        this.skillPoints -= skill.cost;
        this.ui.updateSkillPoints(this.skillPoints);
        this.ui.updateSkillBar(this.skillPoints);
        
        audio.playPowerup(5); 
        showToast(`é‡‹æ”¾: ${skill.name}!`);

        const p = skill.params;
        
        // [æ ¸å¿ƒä¿®æ”¹] ä½¿ç”¨ methodId è¿›è¡Œé€»è¾‘åˆ†å‘
        const method = skill.methodId;

        if (method === 'repulsion') {
            // ... (é‡åŠ›åè½¬é€»è¾‘ä¿æŒä¸å˜) ...
            const pushDistance = this.enemyHeight * p.pushRows;
            let pushedCount = 0;
            this.enemies.forEach(e => {
                if (e.active) {
                    e.dropTargetY = Math.max(80, e.dropTargetY - pushDistance); 
                    e.pos.y = e.dropTargetY; 
                    e.bumpOffsetY = p.visualShake;
                    pushedCount++;
                    this.createParticle(e.pos.x, e.pos.y + e.height/2, p.particleColor, 'mist');
                }
            });
            this.createShockwave(this.width/2, this.height/2, p.shockwaveColor);
            if(pushedCount > 0) audio.playEffect('split');
            document.getElementById('game-container').classList.add('shake-hard');
            setTimeout(() => document.getElementById('game-container').classList.remove('shake-hard'), 200);
        } 
        else if (method === 'chain_lightning_all') {
            // === [æ–°å¢] å…¨å±é—ªç”µé“¾é€»è¾‘ ===
            const dmg = p.baseDmg + (this.round * p.roundMult);
            
            // è§†è§‰ï¼šå…¨å±å¾®é—ª
            const flash = document.createElement('div');
            flash.className = 'absolute inset-0 z-50 pointer-events-none transition-opacity duration-200';
            flash.style.backgroundColor = p.flashColor;
            document.body.appendChild(flash);
            setTimeout(() => { flash.style.opacity = '0'; setTimeout(() => flash.remove(), 200); }, 50);
            document.getElementById('game-container').classList.add('shake-hard');
            setTimeout(() => document.getElementById('game-container').classList.remove('shake-hard'), 200);
            // å€’åºéå†ï¼ˆé˜²æ­¢æ•°ç»„å˜åŠ¨å½±å“ï¼‰
            // ç­–ç•¥ï¼šå¯¹æ¯ä¸ªæ•Œäººä»å¤©é™ä¸‹ä¸€é“é—ªç”µï¼Œå¹¶ä»¥æ­¤ä¸ºèµ·ç‚¹å°è¯•è§¦å‘è¿é”
            for (let i = this.enemies.length - 1; i >= 0; i--) {
                const e = this.enemies[i];
                if (e.active) {
                    // 1. è§†è§‰ï¼šå¤©é›· (ä»å±å¹•é¡¶ç«¯æ‰“åˆ°æ•Œäººå¤´é¡¶)
                    const startX = e.pos.x + (Math.random() - 0.5) * 50;
                    this.lightningBolts.push(new LightningBolt(startX, 0, e.pos.x, e.pos.y));
                    
                    // 2. é€ æˆä¸»ä¼¤å®³
                    const killed = e.takeDamage(dmg);
                    this.recordDamage(dmg);
                    this.createFloatingText(e.pos.x, e.pos.y, `-${dmg}`, '#c084fc');
                    
                    // 3. æ–½åŠ æ„Ÿç”µæ•ˆæœ (æ¸©åº¦)
                    e.applyTemp(CONFIG.balance.lightningTempIncrease || 3); 

                    // 4. [å…³é”®] è§¦å‘è¿é”
                    // æˆ‘ä»¬è°ƒç”¨å·²æœ‰çš„ triggerLightningChainï¼ŒæŠŠå½“å‰æ•Œäºº e ä½œä¸ºæºå¤´
                    // ä¼ é€’ [e] ä½œä¸ºå†å²è®°å½•ï¼Œé˜²æ­¢é—ªç”µç¬é—´å¼¹å›ç»™è‡ªå·±
                    // è¿é”ä¼¤å®³é€šå¸¸æ¯”ä¸»ä¼¤å®³ä½ä¸€ç‚¹ï¼Œè¿™é‡Œè®¾å®šä¸º 100% æˆ– 80% çš†å¯ï¼Œæš‚æ—¶ç”¨ 100%
                    this.triggerLightningChain(e, dmg, [e]);

                    if (killed) this.addScore(e.maxHp);
                }
            }
            audio.playLightning();

        } 
        else if (method === 'enhance_ammo') {
            // === [ä¿®æ”¹] å¼ºåŒ–å¼¹è¯é€»è¾‘ï¼ˆæ”¯æŒå…‰å±æ€§å’Œæ•£å°„ï¼‰ ===
            if (this.ammoQueue.length > 0) {
                const nextAmmo = this.ammoQueue[0];
                
                // 1. éå†å¹¶åº”ç”¨ buffs (åŒ…å« scatter)
                for (const [key, val] of Object.entries(p.buffs)) {
                    // å¦‚æœæ˜¯ damage, scatter, bounce ç­‰æ•°å€¼å±æ€§ï¼Œç›´æ¥ç´¯åŠ 
                    if (typeof nextAmmo[key] === 'number' || nextAmmo[key] === undefined) {
                        nextAmmo[key] = (nextAmmo[key] || 0) + val;
                    }
                }

                // 2. å¤„ç† [å…‰å±æ€§] å¼€å…³
                if (p.forceLaser) {
                    // æ¿€æ´»æ¿€å…‰é€»è¾‘æ ‡å¿—
                    nextAmmo.isLaser = true; 
                    // ç¡®ä¿æ¿€å…‰å±‚æ•°è‡³å°‘ä¸º 1 (å¦‚æœ buffs é‡Œæ²¡é… laser)
                    if (!nextAmmo.laser || nextAmmo.laser <= 0) {
                        nextAmmo.laser = 1;
                    }
                }

                // 3. å¤„ç† [çˆ†ç ´å±æ€§] å¼€å…³
                if (p.forceExplosive) nextAmmo.explosive = true;
                
                // 4. è§†è§‰åé¦ˆ
                this.createExplosion(this.width/2, this.height - 80, p.explosionColor);
                this.updateAmmoUI(); 
                this.createFloatingText(this.width/2, this.height - 120, p.floatText, p.explosionColor);
            } else {
                // è¿”è¿˜ SP
                this.skillPoints += skill.cost;
                this.ui.updateSkillPoints(this.skillPoints);
                this.ui.updateSkillBar(this.skillPoints);
                showToast("ç„¡å½ˆè—¥å¯å¼·åŒ–");
            }
        }
    }
    /**
     * @method spawnEnemyRow
     * @description ç”ŸæˆæŒ‡å®šæ•°é‡çš„æ•Œäººè¡Œã€‚
     * @param {number} [count=1] - **é‡è¦å‚æ•°** è¦ç”Ÿæˆçš„æ•Œäººè¡Œæ•°ã€‚
     */
    spawnEnemyRow(count = 1) { for(let i=0; i<count; i++) { this.spawnEnemyRowAt(80 - (i * this.enemyHeight)); } }
    
    /**
     * @method triggerCloneSpawn
     * @description è§¦å‘åˆ†èº«ç”Ÿæˆçš„é€šç”¨é€»è¾‘
     */
    triggerCloneSpawn(sourceEnemy) {
        const w = this.enemyWidth;
        const cloneHp = Math.max(1, Math.floor(sourceEnemy.maxHp * 0.2));
        
        // å¯»æ‰¾è½ç‚¹
        const validCols = [];
        for(let r = 0; r < 3; r++) {
             for(let c = 0; c < CONFIG.gameplay.enemyCols; c++) {
                 const tx = c * w + w/2;
                 const ty = 80 + r * this.enemyHeight;
                 if (!this.isAreaOccupied(tx, ty, w * 0.9, this.enemyHeight * 0.9)) {
                     validCols.push({x: tx, y: ty});
                 }
             }
        }

        if (validCols.length > 0) {
            const pos = validCols[Math.floor(Math.random() * validCols.length)];
            // å‘å°„å­¢å­
            audio.playEffect('split');
            this.spores.push(new CloneSpore(sourceEnemy.pos.x, sourceEnemy.pos.y, pos.x, pos.y, () => {
                const clone = new Enemy(pos.x, pos.y, w, this.enemyHeight, cloneHp, cloneHp);
                clone.affixes = []; // åˆ†èº«æ²¡æœ‰è¯ç¼€
                this.enemies.push(clone);
                this.createFloatingText(pos.x, pos.y, "SPAWN", "#a855f7");
            }));
        }
    }

    /**
     * @method damageEnemy
     * @description å¯¹æ•Œäººé€ æˆä¼¤å®³å¹¶å¤„ç†å…ƒç´ æ•ˆæœã€‚
     * @param {Enemy} enemy - **é‡è¦å‚æ•°** ç›®æ ‡æ•Œäººã€‚
     * @param {Projectile} projectile - **é‡è¦å‚æ•°** é€ æˆä¼¤å®³çš„å¼¹ä¸¸ã€‚
     */
    damageEnemy(enemy, projectile) {
        if (!enemy || !enemy.active) return; 
        // --- [ä¿®å¾©]ï¼šå¦‚æœæ˜¯å…‰çƒ/å½é€ å­å½ˆï¼Œè£œé½Š chainHistory é˜²æ­¢å ±éŒ¯ ---
        if (!projectile.chainHistory) projectile.chainHistory = [];

        const config = projectile.config;
        const dmg = projectile.isCopy ? config.damage * 0.5 : config.damage;
        
        // --- 1. è§†è§‰ç‰¹æ•ˆç”Ÿæˆé€»è¾‘ ---
        const hitX = projectile.pos.x;
        const hitY = projectile.pos.y;
        const afx = CONFIG.balance.affixes; // è·å–é…ç½®å¼•ç”¨
        
        // æ ¹æ®å­å¼¹å±æ€§å†³å®šæ‰“å‡»ç‰¹æ•ˆ
        // æ ¹æ®å­å¼¹å±æ€§å†³å®šæ‰“å‡»ç‰¹æ•ˆ
        if (config.cryo > 0) {
            // === â„ï¸ å†°éœœæ‰“å‡» (Frost Impact) ===
            
            // 2. å†°åˆºçˆ†å‘ (Ice Spikes)
            // æ•°é‡éšå±‚æ•°å¢åŠ 
            const shardCount = 1 + Math.floor(config.cryo /3); 
            for(let i=0; i<shardCount; i++) {
                // é¢œè‰²ï¼šéšæœºåœ¨ é’è‰² å’Œ ç™½è‰² ä¹‹é—´è·³åŠ¨
                const color = Math.random() > 0.5 ? '#cffafe' : '#ffffff';
                const shard = new Particle(hitX, hitY, color, 'shard');
                this.particles.push(shard);
            }

            // 3. æ»ç•™å¯’é›¾ (Lingering Mist)
            // åœ¨å‡»ä¸­ç‚¹ç”Ÿæˆä¸€å›¢æ…¢æ…¢æ‰©æ•£çš„é›¾æ°”
            const mistCount = 3 + Math.floor(config.cryo / 2);
            for(let i=0; i<mistCount; i++) {
                // éšæœºåˆ†å¸ƒåœ¨å‡»ä¸­ç‚¹å‘¨å›´
                const mx = hitX + (Math.random()-0.5) * 20;
                const my = hitY + (Math.random()-0.5) * 20;
                // é¢œè‰²ä¼  null å³å¯ï¼ŒMist æ¨¡å¼å†…éƒ¨å¤„ç†äº†é¢œè‰²
                const mist = new Particle(mx, my, null, 'mist');
                // åˆå§‹ç»™ä¸€ä¸ªå‘å¤–çš„æ‰©æ•£é€Ÿåº¦
                mist.vel = new Vec2((mx - hitX)*0.05, (my - hitY)*0.05);
                this.particles.push(mist);
            }

        } else if (config.pyro > 0) {
            // ç«ç„°ï¼šç”Ÿæˆæ©™è‰²ç«æ˜Ÿå’Œä¸Šå‡çƒŸé›¾
            for(let i=0; i<5; i++) this.createParticle(hitX, hitY, '#fdba74', 'spark');
            for(let i=0; i<3; i++) this.createParticle(hitX, hitY, '#7c2d12', 'smoke');
        } else if (config.lightning > 0) {
            // é—ªç”µï¼šç”Ÿæˆç´«è‰²å¿«é€Ÿç«èŠ±
            for(let i=0; i<8; i++) this.createParticle(hitX, hitY, '#d8b4fe', 'spark');
        } else if (config.pierce > 0) {
            // ç©¿é€ï¼šçº¢è‰²é”åˆ©ç¢ç‰‡
            for(let i=0; i<5; i++) this.createParticle(hitX, hitY, '#fca5a5', 'spark');
        } else {
            // æ™®é€šï¼šç”ŸæˆåŸºç¡€ç²’å­
            const color = config.damage > 5 ? '#d8b4fe' : '#e2e8f0';
            for(let i=0; i<4; i++) this.createParticle(hitX, hitY, color, 'normal');
        }
        // --- ï¼šåˆ¤æ–­ä¼¤å®³ç±»å‹ ---
        let hitType = 'normal';
        if (config.cryo > 0) hitType = 'cryo';
        else if (config.pyro > 0) hitType = 'pyro';
        else if (config.lightning > 0) hitType = 'lightning';
        else if (config.pierce > 0) hitType = 'pierce';
        // --- 2. ä¼¤å®³ä¸çŠ¶æ€é€»è¾‘ (ä¿æŒåŸæœ‰é€»è¾‘) ---
        if (config.cryo > 0) enemy.applyTemp(-CONFIG.balance.cryoAmount * config.cryo); 
        if (config.pyro > 0) enemy.applyTemp(CONFIG.balance.pyroAmount * config.pyro); 
        if (config.lightning > 0) {
             // 1. å°è¯•è§¦å‘é—ªç”µé“¾ï¼Œå¹¶è·å–ç»“æœ
             const isChainTriggered = this.triggerLightningChain(enemy, dmg, projectile.chainHistory); 
             
             // 2. åªæœ‰åœ¨æˆåŠŸè§¦å‘é—ªç”µé“¾æ—¶ï¼Œæ‰æå‡å½“å‰æ•Œäººçš„æ¸©åº¦
             if (isChainTriggered) {
                 enemy.applyTemp(config.lightning); 
             }
             
             projectile.chainHistory.push(enemy); 
        }

        const killed = enemy.takeDamage(dmg); 
        this.recordDamage(dmg);
        audio.playEnemyHit(hitType);
        // å…‹éš†è¯ç¼€é€»è¾‘: å¦‚æœæ•Œäººè¢«ä¼¤å®³ä¸”æœ‰ 'clone' è¯ç¼€ï¼Œæœ‰æ¦‚ç‡ç”Ÿæˆå…‹éš†
        
        if (!killed && enemy.affixes.includes('clone') && Math.random() < afx.cloneChanceHit) {
             // ... (å¤åˆ¶ä½ åŸæ¥çš„ clone ç”Ÿæˆä»£ç ) ...
             const cloneHp = Math.max(1, Math.floor(enemy.maxHp * 0.2));
             const w = this.enemyWidth;
             // ... å¯»æ‰¾ä½ç½® ...
             // ç®€å†™ï¼šå®é™…è¯·ä¿ç•™åŸæ¥çš„å®Œæ•´é€»è¾‘
             const validCols = [];
             for(let r = 0; r < 3; r++) { for(let c = 0; c < CONFIG.enemyCols; c++) { validCols.push({x: c*w+w/2, y: 80+r*50}); }} // ç®€å•ç¤ºæ„
             if (validCols.length > 0) {
                 const pos = validCols[Math.floor(Math.random() * validCols.length)];
                 this.spores.push(new CloneSpore(enemy.pos.x, enemy.pos.y, pos.x, pos.y, () => {
                    const clone = new Enemy(pos.x, pos.y, w, this.enemyHeight, cloneHp, cloneHp);
                    clone.affixes = []; 
                    this.enemies.push(clone);
                }));
             }
        }

        if (killed) { 
            this.addScore(enemy.maxHp); 
            // ç‡ƒçƒ§æ‰©æ•£é€»è¾‘ (ä¿ç•™)
            if (enemy.temp >= 100) {
                this.fireWaves.push(new FireWave(enemy.pos.x, enemy.pos.y));
                game.createFloatingText(enemy.pos.x, enemy.pos.y - 20, "ğŸ”¥SPREAD!", "#f97316");
                audio.playExplosion();
                this.enemies.forEach(other => {
                    if (other.active && other !== enemy && enemy.pos.dist(other.pos) < CONFIG.gameplay.fireSpreadRadius) {
                        other.applyTemp(CONFIG.gameplay.fireSpreadTempIncrease);
                        other.takeDamage(enemy.maxHp*CONFIG.gameplay.fireSpreadDamagePercent);
                    }
                });
            }
            const activeCount = this.enemies.filter(e => e.active).length;
            if(activeCount === 0) this.clearProjectiles(); 
            if (enemy.type === 'boss') {
                setTimeout(() => {
                    this.stateBeforeRelic = this.phase; 
                    this.openRelicSelection(); 
                }, 500);
            }
        }
        
        // çˆ†ç‚¸é€»è¾‘ (ä¿ç•™å¹¶å¢å¼ºè§†è§‰)
       if (config.explosive) {
            // --- 1. è§£æçˆ†ç‚¸ä¸»é¢˜ (Visual Theme Resolver) ---
            // é»˜è®¤ä¸»é¢˜ (ç‰©ç†çˆ†ç‚¸)
            let theme = {
                waveColor: '#ef4444',       // å†²å‡»æ³¢é¢œè‰² (çº¢)
                particleColor: '#f87171',   // ç²’å­é¢œè‰² (æµ…çº¢)
                particleMode: 'spark',      // ç²’å­æ¨¡å¼
                sound: 'explosion'          // (é¢„ç•™)
            };

            // å…ƒç´ è¦†ç›–é€»è¾‘ (ä¼˜å…ˆçº§ï¼šç« > å†° > ç”µ > æ¯’/å…¶ä»–)
            if (config.pyro > 0) {
                theme.waveColor = '#f97316';      // æ©™è‰²å†²å‡»æ³¢
                theme.particleColor = '#fdba74';  // æ©™é»„ç«æ˜Ÿ
                theme.particleMode = 'spark';     // ç«æ˜Ÿå››æº…
            } else if (config.cryo > 0) {
                theme.waveColor = '#06b6d4';      // é’è‰²å†²å‡»æ³¢ (å¯’æ°”)
                theme.particleColor = '#a5f3fc';  // å†°è“ç¢ç‰‡
                theme.particleMode = 'shard';     // å†°æ¸£é£æº…
            } else if (config.lightning > 0) {
                theme.waveColor = '#c084fc';      // ç´«è‰²å†²å‡»æ³¢ (ç”µç£è„‰å†²)
                theme.particleColor = '#d8b4fe';  // ç´«è‰²ç”µå¼§
                theme.particleMode = 'spark';     
            } else if (config.isMatryoshka) {
                theme.waveColor = '#d946ef';      // ç²‰è‰²å†²å‡»æ³¢ (é­”åŠ›)
                theme.particleColor = '#f5d0fe';
                theme.particleMode = 'normal';
            }

            // --- 2. æ’­æ”¾è§†è§‰ç‰¹æ•ˆ ---
            // ç”Ÿæˆå¸¦æœ‰å±æ€§é¢œè‰²çš„ Shockwave
            this.createShockwave(projectile.pos.x, projectile.pos.y, theme.waveColor); 
            
            // ç”Ÿæˆå¯¹åº”çš„çˆ†ç‚¸ç²’å­ç¾¤
            const particleCount = 12; // çˆ†ç‚¸äº§ç”Ÿçš„ç²’å­æ•°é‡
            for(let i=0; i < particleCount; i++) { 
                this.createParticle(projectile.pos.x, projectile.pos.y, theme.particleColor, theme.particleMode); 
            }

            // å¦‚æœæ˜¯ç«ç„°çˆ†ç‚¸ï¼Œé¢å¤–åŠ ä¸€ç‚¹é»‘çƒŸï¼Œå¢åŠ è´¨æ„Ÿ
            if (config.pyro > 0) {
                for(let i=0; i<5; i++) {
                    this.createParticle(projectile.pos.x, projectile.pos.y, 'rgba(0,0,0,0.5)', 'smoke');
                }
            }
            
            // æ’­æ”¾éŸ³æ•ˆ
            audio.playExplosion();

            // --- 3. é€ æˆèŒƒå›´ä¼¤å®³ä¸æ•ˆæœ ---
            this.enemies.forEach(other => {
                // æ’é™¤è‡ªèº« & è·ç¦»æ£€æµ‹ (çˆ†ç‚¸åŠå¾„ 100)
                if (other !== enemy && other.active && projectile.pos.dist(other.pos) < 100) { 
                    
                    // é€ æˆ AOE ä¼¤å®³ (å‡åŠ)
                    const aoeDmg = dmg * 0.5;
                    const k = other.takeDamage(aoeDmg); 
                    this.recordDamage(aoeDmg); 
                    if (k) this.addScore(other.maxHp); 
                    
                    // --- 4. å…³é”®ï¼šAOE ä¹Ÿè¦æ–½åŠ å…ƒç´ æ•ˆæœ ---
                    // è¿™æ ·çˆ†ç‚¸èŒƒå›´å†…çš„æ•Œäººä¹Ÿä¼šè¢«å†°å†»/ç‚¹ç‡ƒï¼Œç¬¦åˆç›´è§‰
                    if (config.cryo > 0) {
                        // èŒƒå›´å†°å†»æ•ˆæœç¨å¼± (0.5å€)
                        other.applyTemp(-CONFIG.balance.cryoAmount * config.cryo * 0.5);
                        // è§†è§‰åé¦ˆï¼šç»™è¢«æ³¢åŠçš„æ•Œäººä¹Ÿå†’ä¸€ç‚¹å†·æ°”
                        if (Math.random() < 0.3) this.createParticle(other.pos.x, other.pos.y, '#a5f3fc', 'smoke');
                    }
                    if (config.pyro > 0) {
                        other.applyTemp(CONFIG.balance.pyroAmount * config.pyro * 0.5);
                    }
                    if (config.lightning > 0) {
                        other.applyTemp(10 * config.lightning * 0.5);
                        // é—ªç”µé“¾é€šå¸¸åªç”±ç›´æ¥å‡»ä¸­è§¦å‘ï¼Œè¿™é‡Œä¸è§¦å‘é“¾å¼ï¼ŒåªåŠ æ¸©åº¦/æ˜“ä¼¤
                    }
                }
            });
        }
    }

    // ... (Rest of Game Controller Methods: advanceWave, updateCombat, etc. same as before) ...

    /**
     * @method advanceWave
     * @description æ¨è¿›åˆ°ä¸‹ä¸€æ³¢æ•Œäººã€‚
     */
    advanceWave() { 
        this.resolveTemperatureAndAdvance(); // ç»“ç®—æ¸©åº¦æ•ˆæœ
        // æ ¹æ®åœºä¸Šæ•Œäººè¡Œæ•°å†³å®šç”Ÿæˆå¤šå°‘è¡Œæ–°æ•Œäºº
        const rows = new Set(this.enemies.filter(e=>e.active).map(e => Math.floor(e.pos.y))); 
        let spawnCount = 1; 
        if (rows.size < 3) spawnCount = 2; // å¦‚æœæ•Œäººè¡Œæ•°å°‘äº3ï¼Œåˆ™ç”Ÿæˆ2è¡Œ
        this.spawnEnemyRow(spawnCount); 
        
        this.round++; // å›åˆæ•°å¢åŠ 
        this.prevRoundDamage = this.roundDamage; // è®°å½•ä¸Šä¸€å›åˆä¼¤å®³
        this.roundDamage = 0; // é‡ç½®æœ¬å›åˆä¼¤å®³
        document.getElementById('round-num').innerText = this.round; 
        showToast(`Round ${this.round}`); 
    }
    /**
     * @method recordDamage
     * @description è®°å½•æœ¬å›åˆé€ æˆçš„ä¼¤å®³ã€‚
     * @param {number} amount - **é‡è¦å‚æ•°** ä¼¤å®³é‡ã€‚
     */
    recordDamage(amount) { 
        this.roundDamage += amount; 
    }
    /**
     * @method addScore
     * @description å¢åŠ åˆ†æ•°å¹¶æé«˜åˆ†æ•°ä¹˜æ•°ã€‚
     * @param {number} amount - **é‡è¦å‚æ•°** åŸºç¡€åˆ†æ•°ã€‚
     */
    addScore(amount) { 
        this.score += Math.floor(amount * this.scoreMultiplier); 
        document.getElementById('score-num').innerText = this.score; 
        this.scoreMultiplier = parseFloat((this.scoreMultiplier + 0.2).toFixed(1)); // ä¹˜æ•°å¢åŠ  0.2
        this.updateMultiplierUI(); 
    }
    /**
     * @method resetMultiplier
     * @description é‡ç½®åˆ†æ•°ä¹˜æ•°ã€‚
     */
    resetMultiplier() { 
        this.scoreMultiplier = 1.0; 
        this.updateMultiplierUI(); 
        document.getElementById('multiplier-display').classList.remove('opacity-100'); 
        document.getElementById('multiplier-display').classList.add('opacity-0'); 
    }
    /**
     * @method updateMultiplierUI
     * @description æ›´æ–°åˆ†æ•°ä¹˜æ•° UIã€‚
     */
    updateMultiplierUI() { 
        const el = document.getElementById('multiplier-val'); 
        el.innerText = `x${this.scoreMultiplier.toFixed(1)}`; 
        const container = document.getElementById('multiplier-display'); 
        container.classList.remove('opacity-0'); 
        container.classList.add('opacity-100'); 
        el.classList.remove('pop-anim'); 
        void el.offsetWidth; 
        el.classList.add('pop-anim'); 
    }
    

    /**
     * @method updateUI
     * @description æ›´æ–° UI ç•Œé¢æ˜¾ç¤ºï¼Œå¼ºåˆ¶ç®¡ç†å„é˜¶æ®µå…ƒç´ çš„æ˜¾éš
     */
    updateUI() {
        // 1. åŸºç¡€ï¼šéšè—æ‰€æœ‰é˜¶æ®µçš„ä¸»å®¹å™¨ (.ui-overlay)
        document.querySelectorAll('.ui-overlay').forEach(el => { 
            el.style.display = 'none'; 
            el.classList.add('hidden-phase'); 
            el.classList.remove('active-phase'); 
        });

        // 2. æ˜¾ç¤ºå½“å‰é˜¶æ®µçš„ä¸»å®¹å™¨
        const activeEl = document.getElementById(`phase-${this.phase}`); 
        if(activeEl) { 
            activeEl.style.display = 'flex'; 
            // å¾®å°å»¶è¿Ÿä»¥è§¦å‘ CSS transition (å¦‚æœæœ‰)
            setTimeout(() => { 
                activeEl.classList.remove('hidden-phase'); 
                activeEl.classList.add('active-phase'); 
            }, 10); 
        }

        // 1. åº•éƒ¨é¢æ¿ (.bottom-panel) åªåœ¨æ”¶é›†é˜¶æ®µ (gathering) æ˜¾ç¤º
        const bottomPanel = document.querySelector('.bottom-panel');
        if (bottomPanel) {
            if (this.phase === 'gathering') {
                bottomPanel.style.display = 'flex';
            } else {
                bottomPanel.style.display = 'none'; // æˆ˜æ–—é˜¶æ®µéšè—åº•éƒ¨é¢æ¿
            }
        }

        // A. æŠ€èƒ½æ  (Skill Bar) - ä»…åœ¨æˆ˜æ–—ä¸”éæ•Œäººå›åˆæ˜¾ç¤º
        const skillBar = document.getElementById('skill-bar');
        if (skillBar) {
            // åªæœ‰åœ¨ combat é˜¶æ®µæ‰æ˜¾ç¤ºï¼Œå…¶ä»–é˜¶æ®µå¼ºåˆ¶éšè—
            skillBar.style.display = (this.phase === 'combat') ? 'flex' : 'none';
        }

        // B. è¿å‡»å€ç‡æ˜¾ç¤º (Multiplier)
        const multiplierEl = document.getElementById('multiplier-display');
        if (multiplierEl) {
            multiplierEl.style.opacity = (this.phase === 'combat') ? '1' : '0';
        }

        // C. æŠ€èƒ½ç‚¹é¢æ¿ (SP Panel)
        // é€»è¾‘ï¼šåœ¨ gathering å’Œ combat æ˜¾ç¤ºï¼Œåœ¨é€‰æ‹©é˜¶æ®µéšè—
        const spPanel = document.getElementById('sp-panel');
        if (spPanel) {
            if (this.phase === 'gathering' || this.phase === 'combat') {
                spPanel.style.opacity = '1';
                spPanel.style.pointerEvents = 'auto'; // å…è®¸äº¤äº’ï¼ˆæŸ¥çœ‹æç¤ºç­‰ï¼‰
            } else {
                spPanel.style.opacity = '0';
                spPanel.style.pointerEvents = 'none';
            }
        }
        
        // D. æˆ˜æ–— HUD (å³ä¾§å°å¡ç‰‡)
        // å†æ¬¡ç¡®ä¿å®ƒåœ¨éæˆ˜æ–—é˜¶æ®µéšè— (è™½ç„¶ renderRecipeHUD ä¹Ÿä¼šå¤„ç†)
        const combatHud = document.getElementById('recipe-hud-container');
        if (combatHud && this.phase !== 'combat') {
            combatHud.classList.add('hidden');
        }

        // E. ç¡®ä¿ HTML ç»“æ„ä¸­çš„å¼¹è¯æ§½ (.ammo-stage) ä¸ä¼šæ³„éœ²
        // å¦‚æœä½ çš„ current/next å¼¹è¯æ§½æ˜¯ç‹¬ç«‹å…ƒç´ ä¸”æœ‰ IDï¼Œå¯ä»¥åœ¨è¿™é‡ŒåŠ ç±»ä¼¼çš„éšè—é€»è¾‘
        // ä¾‹å¦‚ï¼š
        /*
        const ammoSlots = document.getElementById('ammo-ui-container');
        if (ammoSlots) ammoSlots.style.display = (this.phase === 'combat') ? 'block' : 'none';
        */
    }
    //  è¨ˆç®—æ³¢æµªçš„å‹•æ…‹é€Ÿåº¦
    // [ä¿®æ­£] è®¡ç®—æ³¢æµªçš„åŠ¨æ€é€Ÿåº¦
    calculateWaveSpeed() {
        const maxSpeed = 25 * this.timeScale;
        const scanSpeed = 3 * this.timeScale;
        const clearSpeed = 12 * this.timeScale; //  æ¸…åœºæ—¶çš„å±•ç¤ºé€Ÿåº¦ (é€‚ä¸­)

        // 1. å¦‚æœæœ‰é˜»å°¼ (åˆšåˆšè§¦å‘äº†äº‹ä»¶)ï¼Œå¼ºåˆ¶æ…¢é€Ÿ
        if (this.waveMomentumTimer > 0) {
            return scanSpeed;
        }

        // 2. æ³¢æµªå·²ç»è·‘å‡ºå±å¹•ä¸Šæ–¹ï¼ŒåŠ é€Ÿé”€æ¯
        if (this.enemyWaveY < -50) return maxSpeed;

        // 3. ç»Ÿè®¡æ´»ç€çš„æ•Œäººæ•°é‡
        const activeEnemyCount = this.enemies.filter(e => e.active).length;

        // [æ ¸å¿ƒä¿®å¤] å¦‚æœåœºä¸Šæ²¡æœ‰æ•Œäºº (æ¸…åœºçŠ¶æ€)ï¼Œä¸è¦ç”¨ maxSpeedï¼Œ
        // è€Œæ˜¯ç”¨ clearSpeedï¼Œè®©ç©å®¶èƒ½çœ‹æ¸…æ³¢æµªæ‰«è¿‡ç©ºåœºï¼Œäº§ç”Ÿ"å®‰å…¨ç¡®è®¤"çš„è§†è§‰åé¦ˆã€‚
        if (activeEnemyCount === 0) {
            return clearSpeed;
        }

        let nearestDist = Infinity;
        const defenseLineY = this.height - 100;
        
        // åˆšå¼€å§‹è¿˜æ²¡è¿›å…¥é˜²çº¿åŒºåŸŸæ—¶ï¼Œå¿«é€Ÿè¿›åœº
        if (this.enemyWaveY > defenseLineY) return maxSpeed;

        let hasEnemyAbove = false;
        this.enemies.forEach(e => {
            if (!e.active || e.hasActedThisTurn) return;
            
            const enemyBottom = e.pos.y + e.height/2;
            // åªæ£€æµ‹æ³¢æµªä¸Šæ–¹çš„æ•Œäºº
            if (enemyBottom <= this.enemyWaveY + 50) { 
                const dist = this.enemyWaveY - enemyBottom;
                if (dist >= -20 && dist < nearestDist) {
                    nearestDist = dist;
                    hasEnemyAbove = true;
                }
            }
        });

        if (!hasEnemyAbove) {
            return maxSpeed; // åªæœ‰åœ¨æœ‰æ•Œäººä½†éƒ½ä¸åœ¨æ³¢æµªä¸Šæ–¹æ—¶ï¼Œæ‰å…¨é€Ÿè¿½èµ¶
        } else {
            const slowDownRange = 150; 
            const stopRange = 10;      
            if (nearestDist > slowDownRange) return maxSpeed;
            else if (nearestDist < stopRange) return scanSpeed;
            else {
                const t = nearestDist / slowDownRange;
                return scanSpeed + (maxSpeed - scanSpeed) * (t * t); 
            }
        }
    }
    /**
     * @method switchPhase
     * @description åˆ‡æ¢æ¸¸æˆé˜¶æ®µã€‚
     * @param {string} newPhase - **é‡è¦å‚æ•°** æ–°é˜¶æ®µåç§° ('selection', 'gathering', 'combat', 'gameover')ã€‚
     */
    switchPhase(newPhase) {
        this.phase = newPhase;
        this.updateUI(); // æ›´æ–° UI ç•Œé¢
        const titleContainer = document.getElementById('phase-title-container');
        const titleText = document.getElementById('phase-title');
        const subText = document.getElementById('phase-sub');
        titleContainer.classList.remove('minimized'); // æ˜¾ç¤ºé˜¶æ®µæ ‡é¢˜

        // æ ¹æ®é˜¶æ®µè®¾ç½®æ ‡é¢˜æ–‡æœ¬
        let text = "å‘½é‹æŠ‰æ‹©"; let sub = "é¸æ“‡ä½ çš„å‘½é‹";
        if (newPhase === 'gathering') { text = "ç ”ç£¨éšæ®µ"; sub = "æ”¶é›†é­”åŠ›"; }
        else if (newPhase === 'combat') { text = "æˆ°é¬¥éšæ®µ"; sub = "æŠµç¦¦é­”åƒ"; }
        titleText.innerText = text; subText.innerText = sub;
        
        // 1.2ç§’åéšè—é˜¶æ®µæ ‡é¢˜
        setTimeout(() => { titleContainer.classList.add('minimized'); }, 1200);
    }
    /**
     * æ˜¾ç¤ºé—ç‰©é€‰æ‹©ç•Œé¢
     */
    /**
     * æ˜¾ç¤ºé—ç‰©é€‰æ‹©ç•Œé¢ (æ”¯æŒç¨€æœ‰åº¦æƒé‡ + é˜²é‡å¤)
     */
    showRelicSelection() {
        // 1. è®°å½•ä¹‹å‰çš„çŠ¶æ€ (ç”¨äºå…³é—­æ—¶æ¢å¤)
        this.stateBeforeRelic = this.phase; 

        // --- é…ç½®æƒé‡ ---
        const RARITY_WEIGHTS = CONFIG.balance.relicRarityWright

        // 2. å‡†å¤‡é—ç‰©æ± 
        // è¿‡æ»¤æ‰ç©å®¶å·²ç»æ‹¥æœ‰çš„é—ç‰© (this.ownedRelics)
        let pool = RELIC_DB.filter(r => !this.ownedRelics.includes(r.id));
        
        // å¦‚æœæ± å­ç©ºäº†ï¼ˆå…¨æ”¶é›†äº†ï¼‰ï¼Œå°±ç»™ä¸€äº›ä¿åº•çš„æˆ–è€…æ˜¯ç©ºçš„
        if (pool.length === 0) {
            showToast("å·²æ”¶é›†æ‰€æœ‰é—ç‰©ï¼");
            this.closeRelicSelection(); // æˆ–è€…ç»™ä¸ªåˆ†æ•°å¥–åŠ±
            return;
        }

        const choices = [];
        
        // 3. æŠ½å– 3 ä¸ªé—ç‰© (åŠ æƒéšæœº & ä¸æ”¾å›)
        for(let i=0; i<CONFIG.gameplay.relicChoiceNum; i++) {
            if(pool.length === 0) break;

            // A. è®¡ç®—å½“å‰ä¸´æ—¶æ± å­çš„æ€»æƒé‡
            let totalWeight = 0;
            pool.forEach(r => {
                totalWeight += (RARITY_WEIGHTS[r.rarity] || 10); // é»˜è®¤æƒé‡10
            });

            // B. ç”Ÿæˆéšæœºæ•° [0, totalWeight)
            let randomVal = Math.random() * totalWeight;
            let selectedIdx = -1;

            // C. éå†å¯»æ‰¾å‘½ä¸­çš„é—ç‰©
            for (let j = 0; j < pool.length; j++) {
                const weight = RARITY_WEIGHTS[pool[j].rarity] || 10;
                randomVal -= weight;
                if (randomVal <= 0) {
                    selectedIdx = j;
                    break;
                }
            }

            // D. å…œåº• (é˜²æ­¢æµ®ç‚¹æ•°è¯¯å·®å¯¼è‡´æ²¡é€‰ä¸­ï¼Œé»˜è®¤é€‰ç¬¬ä¸€ä¸ª)
            if (selectedIdx === -1) selectedIdx = 0;

            // E. åŠ å…¥ç»“æœ å¹¶ ä»ä¸´æ—¶æ± ä¸­ç§»é™¤ (é˜²æ­¢åŒä¸€æ¬¡é€‰å¡å‡ºç°ä¸¤ä¸ªä¸€æ ·çš„)
            choices.push(pool[selectedIdx]);
            pool.splice(selectedIdx, 1);
        }

        // 4. ç”Ÿæˆ HTML (ä¿æŒåŸæœ‰é€»è¾‘)
        const container = document.getElementById('relic-container');
        container.innerHTML = '';
        
        choices.forEach(relic => {
            const el = document.createElement('div');
            // åŠ ä¸Š rarity ç±»åä»¥ä¾¿ CSS æ˜¾ç¤ºä¸åŒè¾¹æ¡†é¢œè‰²
            el.className = `relic-card ${relic.rarity || 'common'}`; 
            el.innerHTML = `
                <div class="relic-icon">${relic.icon}</div>
                <div class="relic-name">${relic.name}</div>
                <div class="relic-desc">${relic.desc}</div>
            `;
            el.onclick = (e) => { 
                e.stopPropagation(); 
                this.selectRelic(relic);
            };
            container.appendChild(el);
        });

        // 5. æ˜¾ç¤ºç•Œé¢
        const overlay = document.getElementById('phase-relic');
        overlay.style.display = 'flex';
        overlay.classList.remove('hidden-phase');
        overlay.classList.add('active-phase');
    }

    /**
     * ç©å®¶é€‰æ‹©é—ç‰©
     */
    selectRelic(relic) {
        this.ownedRelics.push(relic.id);
        showToast(`ç²å¾—éºç‰©: ${relic.name}`);
        //  å¤„ç†æ–°é—ç‰©æ•ˆæœ
        if (relic.effect === 'pink_peg_up') {
            this.pinkPegCount += 3; // å åŠ å¢åŠ 
        } 
        else if (relic.effect === 'combat_wall') {
            this.hasCombatWall = true;
        }
        else if (relic.effect === 'unlock_slot') {
            if (!this.unlockedSlots.includes(relic.slotType)) {
                this.unlockedSlots.push(relic.slotType);
            }
            // è§„åˆ™ï¼šè§£é”ä»»æ„ä¸€ç§ï¼Œç‰¹æ®Šæ§½å‡ºç°æ•°é‡ä» 0 -> 1
            if (this.slotCount === 0) this.slotCount = 1;
        }
        else if (relic.effect === 'slot_count_up') {
            this.slotCount += 1;
        } else if (relic.effect === 'row_count_up') {
            this.currentRows += 2;
        }
        //  æ”¯æŒå–®å€‹å­—ä¸²æˆ–æ•¸çµ„çš„è§£é–é‚è¼¯
        if (relic.unlocks) {
            const keys = Array.isArray(relic.unlocks) ? relic.unlocks : [relic.unlocks];
            const boost = relic.boost || 10;
            
            keys.forEach(key => {
                const current = this.unlockedWeights[key] || 0;
                // å¦‚æœæ˜¯ç¬¬ä¸€æ¬¡è§£é–ï¼Œè¨­ç‚º boostï¼›å¦‚æœæ˜¯é‡è¤‡ç²å–ï¼Œå¢åŠ æ¬Šé‡
                this.unlockedWeights[key] = current === 0 ? boost : current + Math.floor(boost * 1.5);
                
                // åŠ å…¥ä¿åº•åˆ—è¡¨
                this.guaranteedNextRound.push(key);
            });
            
            showToast(`å·²è§£é–ç›¸é—œå±¬æ€§!`);
        }


        this.closeRelicSelection();
    }

    /**
     * è·³è¿‡é€‰æ‹©
     */
    skipRelic() {
        this.addScore(500);
        showToast("ç²å¾— 500 åˆ†");
        this.closeRelicSelection();
    }

    /**
     * å…³é—­ç•Œé¢å¹¶æ¢å¤
     */
    closeRelicSelection() {
        const overlay = document.getElementById('phase-relic');
        overlay.style.display = 'none';
        overlay.classList.remove('active-phase');
        overlay.classList.add('hidden-phase');
        
        // [æ ¸å¿ƒä¿®å¤] æ ¹æ®æ‰“å¼€å‰çš„çŠ¶æ€å†³å®šå»å‘
        if (this.stateBeforeRelic === 'gathering') {
            // æƒ…å†µ A: åœ¨æ”¶é›†é˜¶æ®µ(æ‰“ä¸­é—ç‰©æ§½)æ‰“å¼€çš„
            // ä¸éœ€è¦è·³è½¬é˜¶æ®µï¼Œåªéœ€è¦å°è¯•ç»“ç®—å½“å‰å›åˆ
            // (å› ä¸ºåœ¨ updateGathering é‡Œï¼Œçƒå·²ç»è¢«ç§»é™¤å¹¶ activeBalls-- äº†ï¼Œè¿™é‡Œæ£€æŸ¥æ˜¯å¦éœ€è¦å‘å°„)
            this.attemptCompleteGatheringTurn();
        } else {
            // æƒ…å†µ B: åœ¨å›åˆç»“æŸ(æ‰“å®ŒBOSS/å›ºå®šå›åˆäº‹ä»¶)æ‰“å¼€çš„
            // æ­£å¸¸è¿›å…¥ä¸‹ä¸€è½®çš„é€‰å¼¹ç é˜¶æ®µ
            this.initSelectionPhase(); 
        }
    }
    /**
     * åˆå§‹åŒ–å¼¹ç é€‰æ‹©é˜¶æ®µ
     */
    initSelectionPhase() {
        this.switchPhase('selection');
        this.generateMarbleOptions(); // ç”Ÿæˆå¼¹ç é€‰é¡¹
        this.selectedMarbles = []; // é‡ç½®å·²é€‰æ‹©å¼¹ç 
        document.getElementById('selected-count').innerText = '0'; 
        document.getElementById('confirm-selection-btn').disabled = true; 
        document.getElementById('recipe-hud-container').classList.add('hidden');
    }
    /**
     * @method generateMarbleOptions
     * @description ç”Ÿæˆå¼¹ç é€‰é¡¹ (5ä¸ª) ä¾›ç©å®¶é€‰æ‹©ã€‚
     * @returns {Array<MarbleDefinition>} åŒ…å«äº”ä¸ªéšæœºå¼¹ç å®šä¹‰çš„æ•°ç»„ã€‚
     */
    // åœ¨ Game é¡ä¸­

    generateMarbleOptions() { 
        const container = document.getElementById('marble-selection-grid'); 
        container.innerHTML = ''; 
        this.marblesPool = []; 
        
        // å®šç¾©å±¬æ€§åˆ°å½ˆç å®šç¾©çš„æ˜ å°„
        const typeMapping = {
            laser: () => new MarbleDefinition('laser'),
            white: () => new MarbleDefinition('white'),
            redStripe: () => new MarbleDefinition('redStripe'),
            rainbow: () => new MarbleDefinition('rainbow'),
            matryoshka: () => new MarbleDefinition('matryoshka'),
            // å‰©ä¸‹çš„éƒ½æ˜¯ colored é¡å‹ï¼Œä½† subtype ä¸åŒ
            bounce: () => new MarbleDefinition('colored', 'bounce'),
            pierce: () => new MarbleDefinition('colored', 'pierce'),
            scatter: () => new MarbleDefinition('colored', 'scatter'),
            damage: () => new MarbleDefinition('colored', 'damage'),
            cryo: () => new MarbleDefinition('colored', 'cryo'),
            pyro: () => new MarbleDefinition('colored', 'pyro')
        };

        for(let i=0; i < CONFIG.gameplay.selectionCount; i++) {
            let m;
            
            // 1. ä¿åº•æ©Ÿåˆ¶
            if (this.guaranteedNextRound.length > 0) {
                const key = this.guaranteedNextRound.shift();
                if (typeMapping[key]) m = typeMapping[key]();
            } 
            
            // 2. åŠ æ¬Šéš¨æ©Ÿæ©Ÿåˆ¶
            if (!m) {
                // è¨ˆç®—ç¸½æ¬Šé‡
                let total = 0;
                const keys = Object.keys(this.unlockedWeights);
                keys.forEach(k => total += this.unlockedWeights[k]);
                
                let r = Math.random() * total;
                for (const key of keys) {
                    r -= this.unlockedWeights[key];
                    if (r <= 0) {
                        if (typeMapping[key]) m = typeMapping[key]();
                        break;
                    }
                }
            }
            
            // å…œåº•é˜²æ­¢å‡ºéŒ¯
            if (!m) m = new MarbleDefinition('white');
            
            this.marblesPool.push(m); 
            
            // ... (å‰µå»º UI å¡ç‰‡ä»£ç¢¼ä¿æŒä¸è®Š) ...
            const card = document.createElement('div'); 
            card.className = 'select-card'; 
            card.onclick = () => this.toggleMarbleSelection(i, card); 
            const icon = document.createElement('div'); 
            icon.className = 'select-icon flex-shrink-0'; 
            icon.style.background = m.getColor(); 
            const name = document.createElement('div'); 
            name.className = 'text-xs font-bold text-center text-slate-200 mt-2'; 
            name.innerText = m.getName(); 
            card.append(icon, name); 
            container.appendChild(card); 
        } 
    }
    /**
     * @method toggleMarbleSelection
     * @description åˆ‡æ¢æŒ‡å®šç´¢å¼•å¼¹ç çš„é€‰ä¸­çŠ¶æ€ã€‚
     * @param {number} idx - **é‡è¦å‚æ•°** å¼¹ç åœ¨ marblesPool ä¸­çš„ç´¢å¼•ã€‚
     * @param {HTMLElement} cardEl - **é‡è¦å‚æ•°** å¼¹ç å¯¹åº”çš„ UI å…ƒç´ ã€‚
     */
    toggleMarbleSelection(idx, cardEl) { 
        if (this.selectedMarbles.includes(idx)) {
            // å–æ¶ˆé€‰æ‹©
            this.selectedMarbles = this.selectedMarbles.filter(i => i !== idx); 
            cardEl.classList.remove('selected'); 
        } else { 
            // é€‰æ‹© (æœ€å¤š 3 ä¸ª)
            if (this.selectedMarbles.length < 3) { 
                this.selectedMarbles.push(idx); 
                cardEl.classList.add('selected'); 
            } 
        } 
        const count = this.selectedMarbles.length; 
        document.getElementById('selected-count').innerText = count; 
        document.getElementById('confirm-selection-btn').disabled = count !== 3; // åªæœ‰é€‰æ»¡ 3 ä¸ªæ‰èƒ½ç¡®è®¤
    }
    /**
     * @method confirmSelection
     * @description ç¡®è®¤ç©å®¶é€‰æ‹©çš„å¼¹ç ï¼Œå¹¶è¿›å…¥æ”¶é›†é˜¶æ®µã€‚
     */
    confirmSelection() { 
        if (this.selectedMarbles.length !== 3) return; 
        this.marbleQueue = this.selectedMarbles.map(i => this.marblesPool[i]); // å°†é€‰ä¸­çš„å¼¹ç æ”¾å…¥é˜Ÿåˆ—
        this.startGatheringPhase(); 
    }

    /**
     * @method startGatheringPhase
     * @description å¼€å§‹æ”¶é›†é˜¶æ®µï¼Œåˆå§‹åŒ–å¼¹ç å°å’Œé˜Ÿåˆ—ã€‚
     */
    // åœ¨ Game ç±»ä¸­
    startGatheringPhase() {
        this.switchPhase('gathering');
        requestAnimationFrame(() => {
            this.updateUICache();
        });
        if (this.pegs.length === 0) {
            this.initPachinko(); 
        }
        
        // --- æ–°å¢ï¼šåˆå§‹åŒ–æŒä¹…é˜ˆå€¼å˜é‡ ---
        this.persistentThreshold = CONFIG.gameplay.initTriggerThreshold; 
        // -----------------------------
        this.ui.updateSkillPoints(this.skillPoints);
        this.ammoQueue = []; 
        this.dropBalls = []; 
        this.activeMarbleIndex = 0; 
        this.updateHitProgress(0, this.persistentThreshold); 
        this.updateGatheringQueueUI(); 
        this.renderRecipeHUD(); 
        this.updateMulticastDisplay(0);
        this.renderRecipeHUD();
    }
    /**
     * @method initRecipeHUD
     * @description åˆå§‹åŒ–é…æ–¹ HUD (éšè—)ã€‚
     */
    initRecipeHUD() { 
        this.renderRecipeHUD(); 
        const container = document.getElementById('recipe-hud-container'); 
        container.classList.add('hidden'); 
    }
    /**
     * @method toggleHud
     * @description åˆ‡æ¢ HUD å±•å¼€/æŠ˜å çŠ¶æ€ã€‚
     */
    toggleHud() { 
        this.hudExpanded = !this.hudExpanded; 
        this.renderRecipeHUD(); 
    }
    /**
     * @method renderRecipeHUD
     * @description æ¸²æŸ“é…æ–¹ HUD (ä¸¥æ ¼å•ä¾‹æ¸²æŸ“)
     */
    renderRecipeHUD() {
        // è·å–ä¸¤ä¸ªå®¹å™¨
        const gatheringHud = document.getElementById('gathering-hud-mount'); 
        const combatHud = document.getElementById('recipe-hud-container');
        
        // --- æˆ˜æ–—é˜¶æ®µ ---
        if (this.phase === 'combat') { 
            // 1. ç¡®ä¿æ”¶é›†é˜¶æ®µçš„å®¹å™¨ä¸ºç©º (å°½ç®¡ updateUI å·²ç»éšè—äº†å®ƒçš„çˆ¶çº§ï¼Œæ¸…ç©ºæ›´ä¿é™©)
            if (gatheringHud) gatheringHud.innerHTML = '';

            // 2. æ¸²æŸ“æˆ˜æ–—æ‚¬æµ® HUD
            if (combatHud) {
                combatHud.classList.remove('hidden'); 
                combatHud.classList.add('recipe-hud-floating'); 
                combatHud.innerHTML = '';
                
                const previewLimit = 4;
                this.ammoQueue.slice(0, previewLimit).forEach((recipe, idx) => {
                    const isCurrent = (idx === 0);
                    const card = document.createElement('div');
                    card.className = `recipe-card ${isCurrent ? 'current' : 'queue'} mb-1 transition-all duration-300`;
                    
                    // --- æ¸²æŸ“ Header ---
                    const header = document.createElement('div');
                    header.className = 'flex justify-between items-center border-b border-white/10 pb-1 mb-1';
                    let nameStr = 'æ™®é€šé­”è—¥';
                    if (recipe.explosive) nameStr = 'çˆ†ç ´é­”è—¥';
                    else if (recipe.isLaser) nameStr = 'å…‰æŸé­”è—¥';
                    else if (recipe.isMatryoshka) nameStr = 'å¥—å¨ƒé­”è—¥';
                    header.innerHTML = `<span class="font-bold text-amber-400 text-[11px]">${nameStr}</span><span class="text-[10px] text-slate-300 bg-slate-700/50 px-1 rounded">DMG ${recipe.damage || 0}</span>`;
                    
                    // --- æ¸²æŸ“ Grid ---
                    const grid = document.createElement('div');
                    grid.className = 'grid grid-cols-4 gap-0.5 text-[9px] leading-tight';
                    // ... (å¤åˆ¶ä½ åŸæœ‰çš„ stats éå†é€»è¾‘) ...
                    const stats = [
                        { k: 'bounce', i: 'â¤´ï¸' }, { k: 'pierce', i: 'â†—ï¸' },
                        { k: 'scatter', i: 'ğŸ”±' }, { k: 'multicast', i: 'ğŸ”—' }, // 
                        { k: 'cryo', i: 'â„ï¸' }, { k: 'pyro', i: 'ğŸ”¥' },
                        { k: 'lightning', i: 'âš¡' }, { k: 'laser', i: 'ğŸ”¦' }
                    ];
                    let hasStats = false;
                    stats.forEach(s => {
                        const val = recipe[s.k];
                        if (val > 0) {
                            hasStats = true;
                            const tag = document.createElement('div');
                            tag.innerHTML = `${s.i}<span class="text-white ml-px">${val}</span>`;
                            grid.appendChild(tag);
                        }
                    });
                    if (!hasStats) grid.innerHTML = '<span class="col-span-4 text-slate-500 italic text-center">åŸºç¡€å±æ€§</span>';

                    card.appendChild(header);
                    card.appendChild(grid);
                    if (isCurrent) {
                        const indicator = document.createElement('div');
                        indicator.className = 'absolute -left-2 top-1/2 -translate-y-1/2 w-1 h-8 bg-amber-400 rounded-full shadow-[0_0_8px_#fbbf24]';
                        card.appendChild(indicator);
                    }
                    combatHud.appendChild(card);
                });
            }
        } 
        else { 
            // --- æ”¶é›†é˜¶æ®µ ---
            
            // 1. éšè—æˆ˜æ–— HUD
            if (combatHud) {
                combatHud.classList.add('hidden'); 
                combatHud.classList.remove('recipe-hud-floating'); 
                combatHud.innerHTML = '';
            }

            // 2. æ¸²æŸ“æ”¶é›†é˜¶æ®µæ¨ªå‘æ»šåŠ¨æ¡
            if (gatheringHud && this.phase === 'gathering') {
                gatheringHud.innerHTML = ''; 
                this.marbleQueue.forEach((item, idx) => { 
                    const isActive = idx === this.activeMarbleIndex; 
                    this.renderRecipeCard(gatheringHud, item, isActive, isActive ? 'current' : 'queue'); 
                }); 
            }
        }
    }
    /**
     * @method renderRecipeCard
     * @description æ¸²æŸ“å•ä¸ªé…æ–¹/å¼¹ç å¡ç‰‡ã€‚
     * @param {HTMLElement} container - **é‡è¦å‚æ•°** å®¹å™¨å…ƒç´ ã€‚
     * @param {object} item - **é‡è¦å‚æ•°** å¼¹ç å®šä¹‰æˆ–é…æ–¹å¯¹è±¡ã€‚
     * @param {boolean} isActive - æ˜¯å¦ä¸ºå½“å‰æ¿€æ´»é¡¹ã€‚
     * @param {string} statusClass - çŠ¶æ€ CSS ç±»åã€‚
     */
    renderRecipeCard(container, item, isActive, statusClass) {
        const el = document.createElement('div'); 
        el.className = `recipe-card ${statusClass}`; 
        
        const head = document.createElement('div'); 
        // [ä¼˜åŒ–]ï¼š
        // 1. mb-0.5 (2px) æ›¿ä»£ mb-1 (4px)
        // 2. pb-0.5 (2px) æ›¿ä»£ pb-1 (4px)
        // 3. text-[10px] ç¨å¾®å‡å°æ ‡é¢˜å­—å·ï¼Œä½¿å…¶æ›´ç²¾è‡´
        head.className = 'flex items-center justify-between mb-0.5 border-b border-slate-600/50 pb-0.5'; 
        
        const name = document.createElement('span'); 
        name.innerText = item.getName ? item.getName() : (item.name || 'å…‰çƒ');
        name.className = 'font-bold text-amber-100 mr-2 text-[11px]'; // æ ‡é¢˜å­—å· 11px
        head.appendChild(name); 
        
        const mats = document.createElement('div'); 
        mats.className = 'mats-grid'; // ç¡®ä¿ä½¿ç”¨äº†æ–°çš„ grid ç±»

        const counts = {}; 
        if (item.collected) { 
            item.collected.forEach(type => { 
                counts[type] = (counts[type] || 0) + 1; 
            }); 
        }

        const colors = { 
            'bounce': { c: CONFIG.colors.matBounce, l: 'â¤´ï¸', n: 'å½ˆ' }, 
            'pierce': { c: CONFIG.colors.matPierce, l: 'â†—ï¸', n: 'ç©¿' }, 
            'scatter': { c: CONFIG.colors.matScatter, l: 'ğŸ”±', n: 'æ•£' }, 
            'damage': { c: CONFIG.colors.matDamage, l: 'âš”ï¸', n: 'å¼·' }, 
            'cryo': { c: CONFIG.colors.matCryo, l: 'â„ï¸', n: 'å†·' }, 
            'pyro': { c: CONFIG.colors.matPyro, l: 'ğŸ”¥', n: 'ç†±' }, 
            'lightning': { c: CONFIG.colors.matLightning, l: 'âš¡', n: 'é›·' },
            'laser': { c: CONFIG.colors.laser, l: 'ğŸ”¦', n: 'å…‰' }
        };

        Object.keys(counts).forEach(type => { 
            const info = colors[type]; 
            if(!info) return; 
            const row = document.createElement('div'); 
            row.className = 'mat-row text-slate-300'; 
            // å›¾æ ‡å’Œæ–‡å­—ä¹‹é—´åªç•™æå°çš„é—´è·
            row.innerHTML = `<span style="color:${info.c}; font-size:0.8em;">${info.l}</span> <span class="ml-0.5">${info.n}${counts[type]}</span>`; 
            mats.appendChild(row); 
        });
        
        if (item.lightning > 0) {
             const lightningBadge = document.createElement('div');
             lightningBadge.className = 'mat-row text-purple-300 font-bold';
             lightningBadge.innerHTML = `<span style="font-size:0.8em;">âš¡</span> <span class="ml-0.5">åæ‡‰: ${item.lightning}</span>`;
             mats.appendChild(lightningBadge);
        }
        
        if (Object.keys(counts).length === 0) { 
            mats.className = 'text-slate-500 text-[9px] mt-0.5'; // æ— ææ–™æ—¶ä¹Ÿç´§å‡‘ç‚¹
            mats.innerHTML = '<span>ç„¡ææ–™</span>'; 
        } 
        console.log("item.finalHits",item.finalHits)
        if (item.multicast > 0) {
            const badge = document.createElement('div');
            // æ ·å¼ï¼šç»å¯¹å®šä½åœ¨å¡ç‰‡å³ä¸Šè§’æˆ–é†’ç›®ä½ç½®
            badge.className = 'absolute -top-2 -right-2 bg-slate-900 border border-slate-500 text-white text-[10px] font-bold px-1.5 py-0.5 rounded-full shadow-md z-10';
            
            // æ ¹æ®è¿å‡»æ•°å˜è‰²
            if (item.finalHits >= 20) {
                badge.style.borderColor = '#d8b4fe';
                badge.style.color = '#d8b4fe';
                badge.style.boxShadow = '0 0 5px #d8b4fe';
            } else if (item.finalHits >= 10) {
                badge.style.borderColor = '#facc15';
                badge.style.color = '#facc15';
            }
            
            badge.innerText = `x${1+item.multicast}`;
            el.appendChild(badge); // å°†å¾½ç« æ·»åŠ åˆ°å¡ç‰‡ä¸­
            
            // ç¡®ä¿çˆ¶å…ƒç´  el æœ‰ relative å®šä½ï¼Œä»¥ä¾¿ badge ç»å¯¹å®šä½
            el.style.position = 'relative';
            // ç¡®ä¿ overflow ä¸æ˜¯ hiddenï¼Œå¦åˆ™å¾½ç« ä¼šè¢«åˆ‡æ‰
            el.style.overflow = 'visible'; 
        }

        el.append(head, mats); 
        container.appendChild(el);
    }
    /**
     * åˆå§‹åŒ–å¼¹ç å° (Pachinko) çš„é’‰å­å’Œç‰¹æ®Šæ§½ä½
     */
    /**
     * @method initPachinko
     * @description åˆå§‹åŒ–å¼¹ç å°ï¼ˆPachinkoï¼‰çš„é’‰å­å’Œç‰¹æ®Šæ§½ä½ã€‚
     */
// åœ¨ Game é¡ä¸­

    initPachinko() {
        const previousPegs = this.pegs || []; 
        const shouldInherit = previousPegs.length > 0;
        this.pegs = []; 
        this.specialSlots = []; 
        
        const rows = this.currentRows;  
        
        // --- [æ ¸å¿ƒä¿®æ”¹å¼€å§‹]ï¼šå®½é«˜è‡ªé€‚åº”çš„æ­£æ–¹å½¢ç½‘æ ¼è®¡ç®— ---
        
        // 1. è®¡ç®—åŸºå‡†å•å…ƒæ ¼å¤§å°
        // åŸºäºå±å¹•å®½åº¦è®¡ç®—ï¼Œ(cols + 1) æ˜¯ä¸ºäº†å·¦å³ç•™å‡ºåŠä¸ªæ ¼å­çš„è¾¹ç¼˜ç¼“å†²
        // è¿™æ ·æ— è®ºå±å¹•å˜å®½å˜çª„ï¼Œæ ¼å­éƒ½ä¼šç­‰æ¯”ç¼©æ”¾
        const unitSize = this.width / (CONFIG.gameplay.cols + 1);
        
        // 2. å¼ºåˆ¶æ¨ªç«–é—´è·ä¸€è‡´ (æ­£æ–¹å½¢å¸ƒå±€åŸºç¡€)
        const spacingX = unitSize;
        const spacingY = unitSize*0.866; 
        // æ³¨ï¼šå¦‚æœä½ æƒ³è¦å¸•é’å“¥é‚£ç§"ç´§å‡‘çš„ç­‰è¾¹ä¸‰è§’å½¢"å¸ƒå±€ï¼ŒæŠŠä¸Šé¢è¿™è¡Œæ”¹æˆï¼š
        // const spacingY = unitSize * 0.866; 

        // 3. åŠ¨æ€è®¡ç®—èµ·å§‹ X åç§»é‡ï¼Œè®©æ•´ä¸ªé˜µåˆ—åœ¨å±å¹•å±…ä¸­
        // å¶æ•°è¡Œæœ‰ CONFIG.gameplay.cols ä¸ªé’‰å­ï¼Œæ€»å®½åº¦æ˜¯ (cols - 1) * spacingX
        const gridTotalWidth = (CONFIG.gameplay.cols - 1) * spacingX;
        const baseOffsetX = (this.width - gridTotalWidth) / 2;

        // 4. èµ·å§‹ Y åæ ‡ (ä¿æŒå›ºå®šæˆ–æŒ‰éœ€è°ƒæ•´)
        const startY = 120; 
        
        // --- [æ ¸å¿ƒä¿®æ”¹ç»“æŸ] ---

        let grid = []; 
        let pegIndex = 0;
        let maxPegY = 120; 
        for (let r = 0; r < rows; r++) { 
            // å¥‡æ•°è¡Œå°‘ä¸€ä¸ªé’‰å­ (é”™ä½)
            const isOddRow = r % 2 !== 0;
            const cols = isOddRow ? CONFIG.gameplay.cols - 1 : CONFIG.gameplay.cols; 
            
            // å¦‚æœæ˜¯å¥‡æ•°è¡Œï¼Œå‘å³åç§»åŠä¸ªé—´è·
            const rowShift = isOddRow ? (spacingX * 0.5) : 0;
            
            let rowPegs = []; 
            for (let c = 0; c < cols; c++) { 
                // X = åŸºç¡€å±…ä¸­åç§» + åˆ—é—´è· + é”™ä½åç§»
                let x = baseOffsetX + (c * spacingX) + rowShift; 
                let y = startY + r * spacingY; 
                if (y > maxPegY) maxPegY = y;
                // --- ä»¥ä¸‹ä¸ºç»§æ‰¿é€»è¾‘ (ä¿æŒä¸å˜) ---
                let type = 'normal'; 
                
                if (shouldInherit && previousPegs[pegIndex]) {
                    const prevType = previousPegs[pegIndex].type;
                    if (prevType !== 'pink') {
                         const weight = this.unlockedWeights[prevType] || 0;
                         if (prevType === 'laser' || prevType === 'bounce' || weight > 0) {
                             if (Math.random() < 0.99) type = prevType;
                             else type = this.getRandomPegType();
                         } else {
                             type = this.getRandomPegType();
                         }
                    } else {
                        type = this.getRandomPegType(); 
                    }
                } else { 
                    type = this.getRandomPegType(); 
                }
                
                let p = new Peg(x, y, type); 
                this.pegs.push(p); 
                rowPegs.push(p); 
                pegIndex++; 
            } 
            grid.push(rowPegs); 
        }
        this.boardBottomY = maxPegY;
        // --- ç”Ÿæˆç²‰è‰²é’‰å­ (ä¿æŒä¸å˜) ---
        const pinkCount = this.pinkPegCount; 
        for(let i=0; i<pinkCount; i++) { 
            if(this.pegs.length > 0) { 
                const idx = Math.floor(Math.random() * this.pegs.length); 
                this.pegs[idx].type = 'pink'; 
            } 
        }

        // --- ç”Ÿæˆç‰¹æ®Šæ§½ä½ (ä¿æŒä¸å˜) ---
        if (this.unlockedSlots.length > 0 && this.slotCount > 0) {
            const slotTypes = this.unlockedSlots;
            
            // å®‰å…¨æœºåˆ¶ï¼šé˜²æ­¢è¿æ°”æå·®æ—¶æ­»å¾ªç¯
            let attempts = 0;
            const maxAttempts = 100; 

            // æ ¸å¿ƒä¿®å¤ï¼šåªè¦æ•°é‡ä¸å¤Ÿï¼Œå°±ç»§ç»­å°è¯•ç”Ÿæˆ
            while (this.specialSlots.length < this.slotCount && attempts < maxAttempts) {
                attempts++;

                // 1. éšæœºé€‰æ‹©è¡Œ
                let r = Math.floor(Math.random() * (CONFIG.gameplay.spSlotsEndRow - CONFIG.gameplay.spSlotsStartRow + 1)) + CONFIG.gameplay.spSlotsStartRow;
                let rowPegs = grid[r];
                
                // è¡Œæ— æ•ˆåˆ™é‡è¯•
                if (!rowPegs || rowPegs.length < 2) continue; 
                
                // 2. éšæœºé€‰æ‹©åˆ—
                let c = Math.floor(Math.random() * (rowPegs.length - 1)); 
                let p1 = rowPegs[c]; 
                let p2 = rowPegs[c+1]; 
                
                let cx = (p1.pos.x + p2.pos.x) / 2; 
                let cy = p1.pos.y; 
                
                // ä½¿ç”¨ä¹‹å‰è®¡ç®—å¥½çš„ spacingXï¼Œå¦‚æœä½œç”¨åŸŸè®¿é—®ä¸åˆ°ï¼Œå¯ç”¨ this.width / (CONFIG.gameplay.cols + 1) ä»£æ›¿
                // è¿™é‡Œå‡è®¾ä½ åº”ç”¨äº†ä¸Šä¸€æ¡å›ç­”çš„ä»£ç ï¼ŒspacingX æ˜¯å¯ç”¨çš„
                let w = spacingX * 0.8; 
                
                // 3. æ£€æŸ¥é‡å 
                const isOverlapping = this.specialSlots.some(s => Math.abs(s.x - cx) < 20 && Math.abs(s.y - cy) < 20);

                if (!isOverlapping) { 
                    // ç¡®å®šç±»å‹
                    let slotType = slotTypes[Math.floor(Math.random() * slotTypes.length)]; 
                    
                    // é—ç‰©æ§½ç‹¬ç«‹åˆ¤å®š (æ¯å±€æœ€å¤šä¸€ä¸ª)
                    if (Math.random() < CONFIG.gameplay.relicChance && !this.specialSlots.some(s => s.type === 'relic')) {
                        slotType = 'relic';
                    }
                    
                    // æˆåŠŸåŠ å…¥
                    this.specialSlots.push(new SpecialSlot(cx, cy, w, slotType)); 
                } 
                // å¦‚æœ isOverlapping ä¸º trueï¼Œwhile å¾ªç¯ä¼šç»§ç»­ä¸‹ä¸€æ¬¡å°è¯•ï¼Œä¸ä¼šç›´æ¥æ”¾å¼ƒ
            }
        }
    }

    getRandomPegType() { 
    // å®šä¹‰æ‰€æœ‰å¯èƒ½çš„é’‰å­ç±»å‹ï¼ˆåŒ…å«æ™®é€šé’‰å­ï¼‰
    const pegTypes = ['bounce', 'pierce', 'scatter', 'damage', 'cryo', 'pyro', 'lightning'];
    
    // 1. è·å– normal çš„åŸºç¡€æƒé‡
    // æˆ‘ä»¬æ‰‹åŠ¨ä» unlockedWeights ä¸­å– white ä½œä¸ºæ™®é€šé’‰å­çš„æƒé‡åŸºå‡†ï¼ˆé»˜è®¤ 100ï¼‰
    const normalWeight = this.unlockedWeights['white'] || 100; 

    // 2. è®¡ç®—å½“å‰æ‰€æœ‰â€œå·²è§£é”â€ç±»å‹çš„æ€»æƒé‡
    let totalWeight = normalWeight;
    pegTypes.forEach(t => {
        totalWeight += (this.unlockedWeights[t] || 0);
    });
    
    // 3. ç”Ÿæˆ 0 åˆ° totalWeight ä¹‹é—´çš„éšæœºæ•°
    let r = Math.random() * totalWeight;
    
    // 4. åŒºé—´åˆ¤å®šï¼šé¦–å…ˆåˆ¤å®šæ˜¯å¦è½åœ¨ normal åŒºé—´
    if (r < normalWeight) return 'normal';
    r -= normalWeight;
    
    // 5. ä¾æ¬¡åˆ¤å®šè½åœ¨å“ªä¸ªç‰¹æ®Šå±æ€§åŒºé—´
    for (const t of pegTypes) {
        const w = this.unlockedWeights[t] || 0;
        if (w > 0) {
            if (r < w) return t; // è½åœ¨å½“å‰å±æ€§çš„æƒé‡åŒºé—´å†…
            r -= w;
        }
    }
    
    return 'normal'; // å…œåº•è¿”å›
}


    /**
     * å¼€å§‹æˆ˜æ–—é˜¶æ®µ
     */
    /**
     * @method startCombatPhase
     * @description å¼€å§‹æˆ˜æ–—é˜¶æ®µï¼Œåˆå§‹åŒ–æ•Œäººå’ŒUIã€‚
     */
    startCombatPhase() { 
        console.log("è¿›å…¥æˆ˜æ–—é˜¶æ®µ...");
        
        this.energyOrbs = [];
        this.switchPhase('combat'); 
        
        // --- [æ ¸å¿ƒä¿®å¤ 1]ï¼šä¿®å¤å±æ€§è®¿é—®é”™è¯¯ ---
        if (this.marbleQueue && this.marbleQueue.length > 0) {
            this.ammoQueue = this.marbleQueue.map(item => {
                const hasMulticast = item.collected.includes('multicast'); 
                // [ä¿®å¤ç‚¹]ï¼šè¿™é‡ŒåŸæ¥å†™çš„æ˜¯ item.defï¼Œæ”¹ä¸º item
                // å› ä¸º marbleQueue é‡Œçš„å…ƒç´ æœ¬èº«å°±æ˜¯ MarbleDefinition å®šä¹‰å¯¹è±¡
                return this.compileCollectionToRecipe(item, item.collected, hasMulticast);
            });
        } else {
            this.ammoQueue = [];
        }

        // --- [æ ¸å¿ƒä¿®å¤ 2]ï¼šUI æ¸²æŸ“ ---
        // ä¿®å¤åï¼Œä¸Šé¢çš„ä»£ç ä¸å†æŠ¥é”™ï¼Œè¿™ä¸€è¡Œå°†è¢«æ­£ç¡®æ‰§è¡Œï¼ŒHUD ä¼šåœ¨è¿›å…¥æˆ˜æ–—æ—¶ç«‹å³å‡ºç°
        this.renderRecipeHUD(); 

        this.resetMultiplier(); 
        this.burstQueue = []; 
        this.pendingShots = []; 
        
        if (this.ui) {
            this.ui.updateSkillPoints(this.skillPoints);
            this.ui.updateSkillBar(this.skillPoints);
        }
    }
    /**
     * æ¸…é™¤æ‰€æœ‰å¼¹ä¸¸å’Œçˆ†å‘é˜Ÿåˆ—
     */
    /**
     * @method clearProjectiles
     * @description æ¸…é™¤æ‰€æœ‰ç°å­˜çš„æŠ•å°„ç‰©ã€‚
     */
    clearProjectiles() { 
        this.projectiles = []; 
        this.burstQueue = []; 
        this.spores = []; // æ›å ´æ™‚æ¸…ç†æ‰é‚„åœ¨é£›çš„å­¢å­
        this.fireWaves = []; // æ¸…ç†ç«ç„°æ³¢
    }
    createParticle(x, y, color, mode = 'normal') {
        this.particles.push(new Particle(x, y, color, mode));
    }
    /**
     * è·å–å½“å‰çš„è§†è§‰åç§»é‡
     */
        /**
     * @method getTiltOffset
     * @description è·å–å½“å‰çš„è§†è§‰åç§»é‡ (ç”¨äºä¿®æ­£é¼ æ ‡ç‚¹å‡»åæ ‡)
     */
    getTiltOffset() {
        if (this.phase === 'combat') {
            const tilt = this.boardTilt.current;
            // [ä¿®æ­£]ï¼šè¿™é‡Œå¿…é¡»ä¸ updateCombat ä¸­"å®ä½“å±‚"çš„ç³»æ•° (-25, -20) ä¿æŒä¸€è‡´
            // è¿™æ ·ç‚¹å‡»æ‰ä¼šå‡†ç¡®è½åœ¨è§†è§‰ä¸Šåç§»äº†çš„æ•Œäººèº«ä¸Š
            return new Vec2(tilt.x * -25, tilt.y * -20); 
        }
        return new Vec2(0, 0);
    }

        /**
     * @method handleInputStart
     * @description å¤„ç†è¾“å…¥å¼€å§‹ (é¼ æ ‡æŒ‰ä¸‹/è§¦æ‘¸å¼€å§‹) - [ä¿®æ”¹ç‰ˆï¼šç›´å°„æ¨¡å¼]
     */
    handleInputStart(pos) {
        audio.resume();
        const offset = this.getTiltOffset();
        const logicPos = pos.sub(offset); 
        
        this.lastMousePos = logicPos;

        if (this.phase === 'combat') {
             const hitEnemy = this.checkEnemyHover(pos);
             if (hitEnemy) return; 
             if (this.ui.isOpen) {
                 this.ui.closeDrawer();
                 return;
             }
             if (this.ammoQueue.length > 0 && this.projectiles.length === 0 && this.burstQueue.length === 0) {
                this.isDragging = true; 
                this.dragStart = new Vec2(this.width / 2, this.height - 80); 
                this.dragCurrent = logicPos; 
                this.ui.closeDrawer();
            }
        }
        else if (this.phase === 'gathering') {
            if (this.dropBalls.length > 0 || this.energyOrbs.length > 0) {
                showToast("å……èƒ½ä¸­...");
                return;
            }
            
            // ---  åˆ¤æ–­ç‚¹å‡»åŒºåŸŸ ---
            if (pos.y < this.height * 0.4) {
                // ä¸Šæ–¹åŒºåŸŸï¼šå‘å°„å¼¹ç 
                if (this.activeMarbleIndex >= this.marbleQueue.length) return;
                const marbleDef = this.marbleQueue[this.activeMarbleIndex];
                
                // ä½¿ç”¨ä¹‹å‰ä¿®å¤è¿‡çš„æŒä¹…åŒ–é˜ˆå€¼é€»è¾‘
                this.currentSession = {
                    collected: [], multicast: 0, activeBalls: 1, currentHits: 0,
                    nextTriggerThreshold: this.persistentThreshold, // ç¡®ä¿è¿™é‡Œç”¨äº† persistentThreshold
                    totalHits: 0, multicastAdded: [], isFinished: false
                };
                if (marbleDef.type === 'laser') {
                    this.currentSession.collected.push('laser');
                } else if (marbleDef.type === 'colored' && marbleDef.subtype) {
                    this.currentSession.collected.push(marbleDef.subtype);
                }
                this.updateHitProgress(0, this.persistentThreshold);
                this.dropBalls.push(new DropBall(pos.x, 30, marbleDef, this.currentSession));
                this.updateGatheringQueueUI();
                audio.playShoot();
                this.updateMulticastDisplay(0);
            } else {
                // ---  ä¸‹æ–¹åŒºåŸŸï¼šè¿›å…¥â€œæŠ“å–å€¾æ–œâ€æ¨¡å¼ï¼Œæš‚ä¸æŠ¥é”™ ---
                this.isTiltingGrip = true;
                this.gripStartPos = pos;
                // è¿™é‡Œä¸æ˜¾ç¤º toastï¼Œç­‰åˆ°æ¾å¼€æ—¶å¦‚æœæ²¡åŠ¨æ‰æ˜¾ç¤º
            }
        } 
    }
    //  æ£€æµ‹æ˜¯å¦æœ‰æ•Œäººè¢«æ‚¬æµ®/ç‚¹å‡»
    checkEnemyHover(pos) {
        // åªæœ‰æˆ˜æ–—é˜¶æ®µä¸”éæ•Œäººå›åˆæ‰å…è®¸æŸ¥çœ‹
        if (this.phase !== 'combat' || this.isEnemyTurn) return null;

        let hit = null;
        // é€†åºéå†ï¼Œä¼˜å…ˆæ£€æµ‹ä¸Šå±‚(è§†è§‰ä¸Š)çš„æ•Œäºº
        for(let i = this.enemies.length - 1; i >= 0; i--) {
            const e = this.enemies[i];
            if (!e.active) continue;
            
            // ç®€å•çš„çŸ©å½¢ç¢°æ’æ£€æµ‹
            const halfW = e.width / 2;
            const halfH = e.height / 2;
            if (pos.x >= e.pos.x - halfW && pos.x <= e.pos.x + halfW &&
                pos.y >= e.pos.y - halfH && pos.y <= e.pos.y + halfH) {
                hit = e;
                break;
            }
        }

        if (hit) {
            this.ui.showEnemyInfo(hit);
            // ç»™æ•ŒäººåŠ ä¸€ä¸ªé«˜äº®æ¡† (å¯é€‰ï¼Œå¤ç”¨ä½ ä¹‹å‰çš„ scanFeedbackTimer)
            // hit.scanFeedbackTimer = 0.5; // å¾®å¾®é—ªäº®
        } else {
            // å¦‚æœæ˜¯åœ¨PCç«¯é¼ æ ‡ç§»åŠ¨ï¼Œç§»å¼€å³å…³é—­ï¼›ç§»åŠ¨ç«¯éœ€è¦æ‰‹åŠ¨ç‚¹å…³é—­æŒ‰é’®æˆ–ç‚¹ç©ºåœ°
            // ä¸ºäº†ä½“éªŒç»Ÿä¸€ï¼Œè¿™é‡Œè®¾å®šï¼šå¦‚æœæ­£åœ¨Hoveråˆ«çš„ï¼Œå°±åˆ‡è¿‡å»ï¼›å¦‚æœç§»åˆ°ç©ºåœ°ï¼Œæš‚æ—¶ä¸è‡ªåŠ¨å…³é—­(é˜²æ­¢è¯¯è§¦)ï¼Œ
            // æˆ–è€…ï¼šç§»åˆ°ç©ºåœ°å°±å…³é—­ã€‚è¿™é‡Œé‡‡ç”¨â€œç§»åˆ°ç©ºåœ°ä¸è‡ªåŠ¨å…³é—­ï¼Œä¾é ç‚¹å‡»å…³é—­æˆ–æ‹–æ‹½å…³é—­â€ï¼Œä½“éªŒè¾ƒç¨³ã€‚
            // ä½†å¦‚æœæƒ³è¦é¼ æ ‡ç§»å¼€å°±æ¶ˆå¤±ï¼š
            // this.ui.closeDrawer(); 
        }
        return hit;
    }
    /**
     * @method handleInputEnd
     * @description å¤„ç†è¾“å…¥ç»“æŸ (æ¾æ‰‹å‘å°„) - [ä¿®æ”¹ç‰ˆï¼šç›´å°„æ¨¡å¼]
     */
    // --- Game ç±» ---
    handleInputEnd() {
    if (this.isDragging) {
        // ... (æˆ˜æ–—å‘å°„é€»è¾‘ä¿æŒä¸å˜) ...
        this.isDragging = false;
        const cannonPos = new Vec2(this.width / 2, this.height - 80);
        const targetPos = this.lastMousePos;
        const aimVector = targetPos.sub(cannonPos);
        if (aimVector.y < -20) { 
            this.resetMultiplier();
            this.fireNextShot(aimVector.norm().mult(12)); 
        }
    }
    
    // ---  æ”¶é›†é˜¶æ®µæŠ“å–ç»“æŸé€»è¾‘ ---
    if (this.isTiltingGrip) {
        // è®¡ç®—ç”±äºæŠ“å–äº§ç”Ÿçš„ä½ç§»è·ç¦»
        const dist = this.lastMousePos.dist(this.gripStartPos);
        
        // å¦‚æœç§»åŠ¨è·ç¦»å¾ˆçŸ­ (< 10px)ï¼Œè¯´æ˜æ˜¯ä¸€æ¬¡ç‚¹å‡»ï¼Œè€Œä¸æ˜¯æ‹–æ‹½
        if (dist < 10) {
            showToast("è«‹åœ¨ä¸Šæ–¹å€åŸŸé»æ“Š");
        }
        
        // ç»“æŸæŠ“å–
        this.isTiltingGrip = false;
        
        // å¯é€‰ï¼šæ¾æ‰‹åè®©æ¿å­å›æ­£
        if (!this.boardTilt.enabled) {
            this.boardTilt.target = {x: 0, y: 0};
        }
    }
}

    /**
     * å¤„ç†è¾“å…¥ç§»åŠ¨ (é¼ æ ‡ç§»åŠ¨/è§¦æ‘¸ç§»åŠ¨)
     * @param {Vec2} pos - **é‡è¦å‚æ•°** å½“å‰è¾“å…¥ä½ç½®
     * @param {Event} e - äº‹ä»¶å¯¹è±¡
     */
    /**
     * @method handleInputMove
     * @description å¤„ç†è¾“å…¥ç§»åŠ¨ (é¼ æ ‡ç§»åŠ¨/è§¦æ‘¸ç§»åŠ¨)ã€‚
     * @param {Vec2} pos - **é‡è¦å‚æ•°** å½“å‰è¾“å…¥ä½ç½®ã€‚
     * @param {Event} e - äº‹ä»¶å¯¹è±¡ã€‚
     */

    handleInputMove(pos, e) {
        const offset = this.getTiltOffset();
        const logicPos = pos.sub(offset);
        this.lastMousePos = logicPos;
        
        // æˆ˜æ–—æ‹–æ‹½ç„å‡†
        if (this.isDragging) { 
            this.dragCurrent = logicPos; 
            e.preventDefault(); 
            return;
        } 
        
        //  æ”¶é›†é˜¶æ®µ - æ‰‹åŠ¨æ‹–æ‹½å€¾æ–œ
        if (this.phase === 'gathering' && this.isTiltingGrip && !this.boardTilt.enabled) {
            e.preventDefault();
            // è®¡ç®—æ‹–æ‹½åç§»é‡ï¼Œæ¨¡æ‹Ÿå€¾æ–œ
            const deltaX = pos.x - this.gripStartPos.x;
            const deltaY = pos.y - this.gripStartPos.y;
            
            // çµæ•åº¦ç³»æ•°
            const sensitivity = 0.005; 
            
            // å°†åç§»é‡å åŠ åˆ°ç›®æ ‡å€¾æ–œå€¼ä¸Š
            this.boardTilt.target.x = Math.max(-1, Math.min(1, deltaX * sensitivity));
            this.boardTilt.target.y = Math.max(-1, Math.min(1, deltaY * sensitivity));
            return;
        }

        // [ä¿ç•™] æ”¶é›†é˜¶æ®µ - é¼ æ ‡æ‚¬åœå€¾æ–œ (PCç«¯ä½“éªŒä¼˜åŒ–)
        // å¦‚æœæ²¡æœ‰åœ¨æŠ“å–ï¼Œä¸”æ²¡æœ‰é™€èºä»ªï¼Œé¼ æ ‡ä½ç½®ä¹Ÿä¼šäº§ç”Ÿè½»å¾®å€¾æ–œ
        if ((this.phase === 'gathering' || this.phase === 'combat') && !this.isTiltingGrip && !this.boardTilt.enabled) {
            const centerX = this.width / 2;
            const centerY = this.height / 2;
            // æ‚¬åœçš„å¹…åº¦è¦å°ä¸€ç‚¹ï¼Œé˜²æ­¢å¤ªæ™•
            this.boardTilt.target.x = ((pos.x - centerX) / centerX) * 0.3;
            this.boardTilt.target.y = ((pos.y - centerY) / centerY) * 0.3;
        }

        // æˆ˜æ–—é˜¶æ®µæ‚¬æµ®æ£€æµ‹
        if (this.phase === 'combat' && !this.ui.isOpen) {
             this.checkEnemyHover(logicPos);
        }
    }
    
    /**
     * @method triggerLightningChain
     * @description è§¦å‘è¿é”é—ªç”µæ•ˆæœ (ä¿®å¤å•ä½“æŠ¥é”™ç‰ˆ)
     * @returns {boolean} æ˜¯å¦æˆåŠŸè§¦å‘äº†é—ªç”µé“¾
     */
    triggerLightningChain(sourceEnemy, dmg, history) {
        // [ä¿®å¤1] å®‰å…¨æ£€æŸ¥
        if (!sourceEnemy || !sourceEnemy.pos) return false; // <--- ä¿®æ”¹ï¼šè¿”å› false

        // [ä¿®å¤2] å®¹é”™å¤„ç†
        history = history || [];

        // æŸ¥æ‰¾æœªè¢«å‡»ä¸­ä¸”åœ¨èŒƒå›´å†…çš„æœ€è¿‘æ•Œäºº
        let targets = this.enemies.filter(e => 
            e.active &&             
            e !== sourceEnemy &&    
            !history.includes(e)    
        ); 

        // [ä¿®å¤3] å¦‚æœæ²¡æœ‰æœ‰æ•ˆç›®æ ‡
        if (targets.length === 0) return false; // <--- ä¿®æ”¹ï¼šè¿”å› false

        let closest = null; 
        let minDist = 150; // è¿é”èŒƒå›´
        
        // å¯»æ‰¾æœ€è¿‘é‚»å±…
        targets.forEach(t => { 
            let d = sourceEnemy.pos.dist(t.pos); 
            if(d < minDist) { 
                minDist = d; 
                closest = t; 
            } 
        });

        // åªæœ‰æ‰¾åˆ°ç›®æ ‡æ‰ç»§ç»­é€’å½’
        if (closest) { 
            let p = 0.15; // åŸºç¡€è¿é”æ¦‚ç‡
            if (closest.temp < 0) p = Math.min(1.0, 0.15 + Math.abs(closest.temp) * 0.0085); 
            
            if (Math.random() < p) { 
                // è§†è§‰æ•ˆæœ
                this.lightningBolts.push(new LightningBolt(sourceEnemy.pos.x, sourceEnemy.pos.y, closest.pos.x, closest.pos.y)); 
                audio.playLightning(); 
                
                // ä¼¤å®³ä¸çŠ¶æ€
                closest.applyTemp(CONFIG.balance.lightningTempIncrease); 
                const killed = closest.takeDamage(dmg); 
                this.recordDamage(dmg); 
                if(killed) this.addScore(closest.maxHp); 
                
                // é€’å½’
                history.push(closest); 
                this.triggerLightningChain(closest, dmg, history); 
                
                return true; // <--- æ–°å¢ï¼šæˆåŠŸè§¦å‘ï¼Œè¿”å› true
            } 
        }
        return false; // <--- æ–°å¢ï¼šæœªè§¦å‘æˆ–æ— ç›®æ ‡ï¼Œè¿”å› false
    }

    /**
    /**
     * @method fireNextShot
     * @description å‘å°„ä¸‹ä¸€å‘å¼¹ä¸¸ (å¤„ç†å¤šé‡å°„å‡»)ã€‚
     * @param {Vec2} vel - **é‡è¦å‚æ•°** åˆå§‹é€Ÿåº¦å‘é‡ã€‚
     */
    fireNextShot(vel) { 
        if (this.ammoQueue.length === 0) return;

        // ... (å¥—å¨ƒæå–é€»è¾‘ä¿æŒä¸å˜) ...
        const pullNext = () => {
            if (this.ammoQueue.length === 0) return null;
            let r = this.ammoQueue.shift();
            if (r.isMatryoshka) {
                const nextR = pullNext();
                if (nextR) r.nestedPayload = nextR;
            }
            return r;
        };
        const finalRecipe = pullNext();
        if (!finalRecipe) return;

        // --- æ–°å¢ï¼šè§¦å‘UIåŠ¨ç”» ---
        const currentSlot = document.getElementById('current-ammo-render');
        if (currentSlot) {
            // 1. æ’­æ”¾é£å‡ºåŠ¨ç”»
            currentSlot.classList.add('shoot-anim');
            
            // 2. å»¶è¿Ÿæ›´æ–° UI (ç­‰å¾…åŠ¨ç”»æ’­æ”¾ä¸€éƒ¨åˆ†ï¼Œåˆ¶é€ è§†è§‰è¿è´¯æ€§)
            // å®é™…å­å¼¹å·²ç»ç”Ÿæˆï¼Œä½†UIæ»åä¸€ç‚¹ç‚¹æ›´æ–°ï¼Œè®©ç©å®¶çœ‹åˆ°"å‘å°„"çš„è¿‡ç¨‹
            setTimeout(() => {
                this.updateAmmoUI();
                
                // 3. ä¸ºæ–°ä¸Šè†›çš„å­å¼¹æ·»åŠ "æ»‘å…¥"åŠ¨ç”»
                const newCurrent = document.getElementById('current-ammo-render');
                if (newCurrent) {
                    newCurrent.classList.add('slide-in-anim');
                    setTimeout(() => newCurrent.classList.remove('slide-in-anim'), 400);
                }
            }, 150); 
        } else {
            this.updateAmmoUI();
        }
        
        this.renderRecipeHUD(); 
        
        // åŸºç¡€å°„å‡»
        this.burstQueue.push({ delay: 0, vel: vel, recipe: finalRecipe }); 
        
        // å¤šé‡å°„å‡»
        if (finalRecipe.multicast > 0) { 
            for(let i=1; i<=finalRecipe.multicast; i++) { 
                this.burstQueue.push({ delay: i * 20, vel: vel, recipe: finalRecipe }); 
            } 
        } 
    }
    /**
    /**
     * @method spawnBullet
     * @description ç”Ÿæˆå¼¹ä¸¸ (å¤„ç†æ•£å°„)ã€‚
     * @param {number} x - **é‡è¦å‚æ•°** åˆå§‹ä½ç½® Xã€‚
     * @param {number} y - **é‡è¦å‚æ•°** åˆå§‹ä½ç½® Yã€‚
     * @param {Vec2} vel - **é‡è¦å‚æ•°** åˆå§‹é€Ÿåº¦å‘é‡ã€‚
     * @param {object} recipe - **é‡è¦å‚æ•°** å¼¹è¯é…æ–¹ã€‚
     */
    spawnBullet(x, y, vel, recipe) { 
        // [å…³é”®] å¦‚æœæ˜¯æ¿€å…‰ï¼Œå‘å°„å…‰æŸåç›´æ¥ returnï¼Œä¸ç”Ÿæˆ Projectile
        if (recipe.isLaser) {
            this.fireLaser(x, y, vel, recipe);
            
            // å¤„ç†æ•£å°„æ¿€å…‰ (å¦‚æœæ¿€å…‰å¸¦æœ‰æ•£å°„å±æ€§ï¼Œæ¯”å¦‚åƒäº†é»„è‰²é’‰å­)
            if (recipe.scatter > 0) {
                 for (let i = 1; i <= recipe.scatter; i++) { 
                    const sign = i % 2 === 0 ? -1 : 1; 
                    const multiplier = Math.ceil(i / 2); 
                    const angleOffset = 0.2 * multiplier * sign; 
                    const newVel = vel.rotate(angleOffset); 
                    // é€’å½’è°ƒç”¨ fireLaser æˆ– spawnBullet
                    // æ³¨æ„ï¼šæ•£å°„å‡ºçš„æ¿€å…‰ä¼¤å®³é€šå¸¸å‡åŠæˆ–è€…ä¿æŒ
                    const copyRecipe = { ...recipe, scatter: 0 }; 
                    this.fireLaser(x, y, newVel, copyRecipe);
                } 
            }
            return; // <--- ç¡®ä¿è¿™é‡Œæœ‰ returnï¼Œå°±ä¸ä¼šç”Ÿæˆä¸‹é¢çš„ Projectile å®ä½“çƒäº†
        }

        this.projectiles.push(new Projectile(x, y, vel, recipe)); 
        if (recipe.isLaser) {
            this.fireLaser(x, y, vel, recipe);
            return;
        }
        // æ•£å°„ (Scatter)
        if (recipe.scatter > 0) { 
            for (let i = 1; i <= recipe.scatter; i++) { 
                const sign = i % 2 === 0 ? -1 : 1; 
                const multiplier = Math.ceil(i / 2); 
                const angleOffset = 0.2 * multiplier * sign; // æ•£å°„è§’åº¦åç§»
                const newVel = vel.rotate(angleOffset); 
                const copyRecipe = { ...recipe, scatter: 0, chainPayload: null }; // æ•£å°„å¼¹ä¸¸ä¸å¸¦æ•£å°„å’Œè¿é”
                this.projectiles.push(new Projectile(x, y, newVel, copyRecipe, true)); 
            } 
        } 
    }

// åœ¨ Game ç±»ä¸­æ›´æ–°æ­¤æ–¹æ³•
    fireLaser(startX, startY, vel, recipe) {
        // --- 1. å‚æ•°è®¡ç®— ---
        
        // [å°„ç¨‹] åŸºç¡€ 500 + æ¯å±‚ç©¿é€ 250 (å†³å®šå…‰çº¿èƒ½è·‘å¤šè¿œ)
        let maxLen = 500 + (recipe.pierce * 250); 
        
        // [ç²—ç»†] åŸºç¡€ 3px + æ¯å±‚æ¿€å…‰ 4px + çˆ†ç ´åŠ æˆ (å†³å®šå…‰çº¿è§†è§‰å®½åº¦)
        let width = 3 + (recipe.laser * 4) + (recipe.explosive ? 10 : 0);
        
        // [åå¼¹] ç›´æ¥è¯»å–é…æ–¹ä¸­çš„ bounce å€¼ (å†³å®šæŠ˜å°„æ¬¡æ•°)
        let bounces = recipe.bounce; 

        // [é¢œè‰²] ä¼˜å…ˆçº§ï¼šçˆ†ç ´ > å…ƒç´  > é»˜è®¤è“
        let color = '#0ea5e9'; 
        if (recipe.pyro > 0) color = '#f97316';
        else if (recipe.cryo > 0) color = '#06b6d4';
        else if (recipe.lightning > 0) color = '#d8b4fe';
        else if (recipe.explosive) color = '#ef4444';

        // --- 2. å°„çº¿æ£€æµ‹ (Raycasting Logic) ---
        let points = [new Vec2(startX, startY)]; 
        let currPos = new Vec2(startX, startY);
        let currDir = vel.norm(); 
        let remainLen = maxLen;
        
        // å¾ªç¯æ¡ä»¶ï¼šåªè¦è¿˜æœ‰å‰©ä½™é•¿åº¦ (remainLen > 0) å°±ç»§ç»­
        // å†…éƒ¨ä¼šåˆ¤æ–­æ˜¯å¦æ’å¢™/æ¬¡æ•°è€—å°½æ¥ break
        while (remainLen > 0) {
            // A. å¯»æ‰¾æœ€è¿‘çš„åå°„é¢ (å¢™å£ æˆ– æŠ¤ç›¾æ•Œäºº)
            let hitResult = this.castRayToReflectors(currPos, currDir, remainLen);
            
            // B. ç»“ç®—è¿™ä¸€æ®µè·¯å¾„ (ç§»åŠ¨å…‰æ ‡)
            let segmentLen = hitResult.dist;
            let nextPos = currPos.add(currDir.mult(segmentLen));
            
            // C. ä¼¤å®³è·¯å¾„ä¸Šçš„æ™®é€šæ•Œäºº (ç©¿é€æ‰€æœ‰)
            this.processLaserPenetration(currPos, nextPos, recipe);

            // è®°å½•è·¯å¾„ç‚¹ç”¨äºç»˜åˆ¶
            points.push(nextPos);
            
            // æ‰£é™¤é•¿åº¦
            remainLen -= segmentLen;
            currPos = nextPos;

            // D. å¤„ç†æ’å‡»ç»“æœ
            if (hitResult.hitType === 'none') {
                // æ²¡æ’åˆ°ä»»ä½•åå°„é¢ï¼Œå…‰çº¿åœ¨ç©ºæ°”ä¸­è€—å°½é•¿åº¦ï¼Œç»“æŸ
                break; 
            } else {
                // æ’åˆ°äº†åå°„é¢ï¼æ£€æŸ¥æ˜¯å¦æœ‰å‰©ä½™åå¼¹æ¬¡æ•°
                if (bounces <= 0) {
                    // æ¬¡æ•°è€—å°½ï¼Œå…‰çº¿åœ¨è¿™é‡Œç»ˆæ­¢ (è™½æœ‰é•¿åº¦ä½†æ— æ³•æŠ˜å°„)
                    // å¯ä»¥åœ¨æœ«ç«¯åŠ ä¸ªå°ç«èŠ±è¡¨ç¤ºèƒ½é‡è€—å°½
                    this.createParticle(nextPos.x, nextPos.y, color, 'spark');
                    break;
                }

                // æ¶ˆè€—ä¸€æ¬¡åå¼¹æ¬¡æ•°
                bounces--;
                
                // è§¦å‘æ’å‡»åé¦ˆ
                if (hitResult.hitType === 'wall') {
                    audio.playHit('bounce');
                    this.createParticle(nextPos.x, nextPos.y, color, 'spark');
                } else if (hitResult.hitType === 'shield') {
                    // å‡»ä¸­æŠ¤ç›¾æ•Œäºº
                    this.damageEnemy(hitResult.enemy, { config: recipe, pos: nextPos, isCopy: false }); 
                    audio.playHit('bounce'); // å¬èµ·æ¥åƒæ‰“é“
                    this.createParticle(nextPos.x, nextPos.y, '#3b82f6', 'spark');
                }

                // è®¡ç®—åå°„å‘é‡ (é•œé¢åå°„)
                if (hitResult.normal === 'x') currDir.x *= -1;
                else currDir.y *= -1;
            }
        }

        // --- 3. ç”Ÿæˆè§†è§‰ä¸éŸ³æ•ˆ ---
        this.particles.push(new LaserBeam(points, width, color));
        
        // éŸ³æ•ˆï¼šè¶Šç²—è¶Šä½æ²‰
        audio.playTone(Math.max(100, 800 - width * 20), 'sawtooth', 0.15, 0.2 + width * 0.01); 
    }

    // è¾…åŠ©ï¼šå¯»æ‰¾æœ€è¿‘çš„åå°„é¢ï¼ˆå¢™å£æˆ–å¸¦ç›¾æ•Œäººï¼‰
    castRayToReflectors(start, dir, maxDist) {
        let closest = { dist: maxDist, hitType: 'none', normal: null, enemy: null };

        // 1. æ£€æµ‹å¢™å£
        // å·¦å¢™ (x=radius)
        if (dir.x < 0) {
            let d = (CONFIG.physics.bulletRadius - start.x) / dir.x;
            if (d > 0 && d < closest.dist) closest = { dist: d, hitType: 'wall', normal: 'x' };
        }
        // å³å¢™ (x=width-radius)
        if (dir.x > 0) {
            let d = (this.width - CONFIG.physics.bulletRadius - start.x) / dir.x;
            if (d > 0 && d < closest.dist) closest = { dist: d, hitType: 'wall', normal: 'x' };
        }
        // é¡¶å¢™ (y=radius)
        if (dir.y < 0) {
            let d = (CONFIG.physics.bulletRadius - start.y) / dir.y;
            if (d > 0 && d < closest.dist) closest = { dist: d, hitType: 'wall', normal: 'y' };
        }
        // åº•å¢™ (y=height-radius) - åªæœ‰åœ¨æœ‰ CombatWall é—ç‰©æ—¶æ‰åå¼¹
        if (this.hasCombatWall && dir.y > 0) {
            let d = (this.height - CONFIG.physics.bulletRadius - start.y) / dir.y;
            if (d > 0 && d < closest.dist) closest = { dist: d, hitType: 'wall', normal: 'y' };
        }

        // 2. æ£€æµ‹å¸¦ç›¾æ•Œäºº (è§†ä¸ºåå°„é¢)
        this.enemies.forEach(e => {
            if (!e.active || !e.affixes.includes('shield')) return;
            
            // ç®€å•çš„ AABB å°„çº¿æ£€æµ‹
            // æ‰©å±•ä¸€ä¸‹è¾¹ç•Œä½œä¸ºç¢°æ’ç®±
            const halfW = e.width / 2 + 5;
            const halfH = e.height / 2 + 5;
            
            // ä¸ºäº†ç®€åŒ–ï¼Œæˆ‘ä»¬æŠŠæ•Œäººçœ‹ä½œä¸€ä¸ªåœ†æˆ–è€…ç®€å•çš„çŸ©å½¢
            // è¿™é‡Œä½¿ç”¨ç®€åŒ–çš„çŸ©å½¢æ±‚äº¤ (Slab method çš„ç®€åŒ–ç‰ˆ)
            // å®é™…ä¸Šï¼Œä¸ºäº†æ¸¸æˆæ‰‹æ„Ÿï¼Œæˆ‘ä»¬å¯ä»¥éå†æ‰€æœ‰æ•Œäººçš„è¾¹ç•Œçº¿
            // ä½†æœ€ç®€å•çš„æ–¹æ³•æ˜¯ï¼šæ£€æµ‹å°„çº¿æ˜¯å¦ç©¿è¿‡æ•Œäººä¸­å¿ƒé™„è¿‘
            
            // ä½¿ç”¨çº¿æ®µä¸çŸ©å½¢ç›¸äº¤æ£€æµ‹
            const t = this.getLineRectIntersection(start, dir, e.pos.x - halfW, e.pos.y - halfH, e.width, e.height);
            if (t !== null && t > 0 && t < closest.dist) {
                // ç¡®å®šæ³•çº¿ (ç®€åŒ–ï¼šçœ‹å‡»ä¸­ç‚¹çš„ç›¸å¯¹ä½ç½®)
                const hitX = start.x + dir.x * t;
                const hitY = start.y + dir.y * t;
                const dx = Math.abs(hitX - e.pos.x);
                const dy = Math.abs(hitY - e.pos.y);
                // å¦‚æœ x åå·®æ¯” y åå·®å¤§ï¼Œè¯´æ˜æ’çš„æ˜¯å·¦å³ä¾§ (Normal X)ï¼Œå¦åˆ™æ˜¯ä¸Šä¸‹ä¾§
                // éœ€å½’ä¸€åŒ–æ¯”è¾ƒ (å®½é«˜æ¯”)
                const nx = dx / halfW;
                const ny = dy / halfH;
                
                closest = { 
                    dist: t, 
                    hitType: 'shield', 
                    normal: nx > ny ? 'x' : 'y',
                    enemy: e 
                };
            }
        });

        return closest;
    }

    // è¾…åŠ©ï¼šå¤„ç†çº¿æ®µä¸Šçš„æ™®é€šç©¿é€
    processLaserPenetration(p1, p2, recipe) {
        // æ„å»ºçº¿æ®µåŒ…å›´ç›’ç”¨äºå¿«é€Ÿå‰”é™¤
        const minX = Math.min(p1.x, p2.x) - 20;
        const maxX = Math.max(p1.x, p2.x) + 20;
        const minY = Math.min(p1.y, p2.y) - 20;
        const maxY = Math.max(p1.y, p2.y) + 20;

        this.enemies.forEach(e => {
            if (!e.active) return;
            // å¦‚æœæ˜¯æŠ¤ç›¾æ€ªï¼Œä¹‹å‰åœ¨åå°„é€»è¾‘é‡Œå·²ç»å¤„ç†è¿‡äº†ï¼Œè¿™é‡Œè·³è¿‡ï¼Ÿ
            // ä¸ï¼Œåå°„é€»è¾‘åªå¤„ç†äº†â€œæœ€è¿‘â€çš„ä¸€ä¸ªã€‚
            // æ¿€å…‰åŸç†æ˜¯ï¼šå®ƒä¼šç©¿é€æ‰€æœ‰æ™®é€šæ€ªï¼Œç›´åˆ°é‡åˆ°åå°„é¢ã€‚
            // æ‰€ä»¥è¿™é‡Œè¦æ’é™¤æ‰é‚£ä¸ªå……å½“åå°„é¢çš„æŠ¤ç›¾æ€ªï¼ˆå¦‚æœè¿™æŸå…‰æ­£å¥½ç»ˆç»“äºå®ƒï¼‰ã€‚
            // ç®€å•å¤„ç†ï¼šå…¨éƒ¨æ£€æµ‹ä¸€éï¼Œä¼¤å®³é¢‘ç‡ä¸é«˜ã€‚
            
            if (e.pos.x < minX || e.pos.x > maxX || e.pos.y < minY || e.pos.y > maxY) return;

            // ç‚¹åˆ°çº¿æ®µè·ç¦»å…¬å¼
            const l2 = p1.dist(p2) * p1.dist(p2);
            if (l2 == 0) return;
            let t = ((e.pos.x - p1.x) * (p2.x - p1.x) + (e.pos.y - p1.y) * (p2.y - p1.y)) / l2;
            t = Math.max(0, Math.min(1, t));
            const projX = p1.x + t * (p2.x - p1.x);
            const projY = p1.y + t * (p2.y - p1.y);
            const dist = Math.sqrt(Math.pow(e.pos.x - projX, 2) + Math.pow(e.pos.y - projY, 2));

            // åˆ¤å®šåŠå¾„ï¼šæ•ŒäººåŠå¾„ + æ¿€å…‰ç²—ç»†
            const hitRadius = Math.min(e.width, e.height) / 2 + (recipe.explosive ? 15 : 5);

            if (dist < hitRadius) {
                // é€ æˆä¼¤å®³
                // ä¸ºäº†é¿å…å¤šé‡åˆ¤å®šé—®é¢˜ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨è¿™é‡Œç›´æ¥ä¼¤å®³
                // ä¼ªé€ ä¸€ä¸ª projectile å¯¹è±¡ä¼ ç»™ damageEnemy
                this.damageEnemy(e, { config: recipe, pos: new Vec2(projX, projY), isCopy: false });
                
                // è§†è§‰ï¼šå—å‡»ç‚¹ç‰¹æ•ˆ
                if (Math.random() < 0.3) this.createParticle(projX, projY, '#fff', 'spark');
            }
        });
    }

    // è¾…åŠ©ï¼šå°„çº¿ä¸çŸ©å½¢ç›¸äº¤ (Slab Method) è¿”å›è·ç¦» t
    getLineRectIntersection(start, dir, rx, ry, rw, rh) {
        let tmin = -Infinity;
        let tmax = Infinity;

        if (dir.x !== 0) {
            let tx1 = (rx - start.x) / dir.x;
            let tx2 = (rx + rw - start.x) / dir.x;
            tmin = Math.max(tmin, Math.min(tx1, tx2));
            tmax = Math.min(tmax, Math.max(tx1, tx2));
        } else if (start.x < rx || start.x > rx + rw) {
            return null;
        }

        if (dir.y !== 0) {
            let ty1 = (ry - start.y) / dir.y;
            let ty2 = (ry + rh - start.y) / dir.y;
            tmin = Math.max(tmin, Math.min(ty1, ty2));
            tmax = Math.min(tmax, Math.max(ty1, ty2));
        } else if (start.y < ry || start.y > ry + rh) {
            return null;
        }

        if (tmax >= tmin && tmin >= 0) return tmin;
        return null;
    }
    /**
     * @method createExplosion
     * @description åˆ›å»ºçˆ†ç‚¸ç‰¹æ•ˆ (ç²’å­ç¾¤)ã€‚
     * @param {number} x - **é‡è¦å‚æ•°** ä½ç½® Xã€‚
     * @param {number} y - **é‡è¦å‚æ•°** ä½ç½® Yã€‚
     * @param {string} color - é¢œè‰²ã€‚
     */
    createExplosion(x, y, color) { 
        for(let i=0; i<10; i++) { 
            this.particles.push(new Particle(x, y, color || '#f87171')); 
        } 
    }

    /**
     * @method createShockwave
     * @description åˆ›å»ºå†²å‡»æ³¢ç‰¹æ•ˆã€‚
     * @param {number} x - **é‡è¦å‚æ•°** ä½ç½® Xã€‚
     * @param {number} y - **é‡è¦å‚æ•°** ä½ç½® Yã€‚
     */
    createShockwave(x, y, color = null) { 
        console.log("add shockwaves")
        this.shockwaves.push(new Shockwave(x, y, color)); 
    }

    updateUICache() {
        const gaugeEl = document.getElementById('hero-gauge-container');
        if (gaugeEl) {
            const rect = gaugeEl.getBoundingClientRect();
            // ç¼“å­˜ä¸­å¿ƒåæ ‡
            this.uiCache = {
                x: rect.left + rect.width / 2,
                y: rect.top + rect.height / 2,
                // ç¼“å­˜ DOM å¼•ç”¨ï¼Œé¿å…é‡å¤æŸ¥è¯¢
                el: gaugeEl,
                pulseLayer: document.getElementById('gauge-pulse-layer'),
                gaugeShell: document.getElementById('gauge-shell')
            };
        } else {
            // å…œåº•åæ ‡
            this.uiCache = { x: this.width / 2, y: this.height - 100, el: null };
        }
    }
    // ---  createHitFeedback ---
    createHitFeedback(x, y, velocity, type = 'normal') {
        // 1. è·å–ç›®æ ‡åæ ‡
        if (!this.uiCache) this.updateUICache();
        
        let targetX = this.uiCache.x;
        let targetY = this.uiCache.y;

        // [æ ¸å¿ƒä¿®å¤]ï¼šå…œåº•æ£€æµ‹
        // å¦‚æœç¼“å­˜åæ ‡æ˜¯ 0 (è¯´æ˜ä¸Šæ¬¡è·å–æ—¶ UI å¯èƒ½è¢«éšè—äº†)ï¼Œå¼ºåˆ¶é‡ç®—
        if (targetX === 0 && targetY === 0) {
            this.updateUICache();
            targetX = this.uiCache.x;
            targetY = this.uiCache.y;
            
            // å¦‚æœè¿˜æ˜¯ 0 (æç½•è§)ï¼Œå°±æ‰‹åŠ¨æŒ‡å®šä¸€ä¸ªå¤§æ¦‚ä½ç½® (å±å¹•ä¸­ä¸‹æ–¹)
            if (targetX === 0) {
                targetX = this.width / 2;
                targetY = this.height - 100;
            }
        }

        // --- ä»¥ä¸‹ä¿æŒä¹‹å‰çš„ä¼˜åŒ–é€»è¾‘ä¸å˜ ---
        
        let color = '#fbbf24'; 
        if (type === 'cryo') color = '#67e8f9';
        else if (type === 'pyro') color = '#f97316';
        else if (type === 'lightning') color = '#d8b4fe';
        else if (type === 'bounce') color = '#4ade80';

        const initVel = velocity ? velocity : new Vec2((Math.random()-0.5)*5, -5);

        this.energyOrbs.push(new EnergyOrb(x, y, targetX, targetY, color, initVel, () => {
            if(this.currentSession) { 
                this.currentSession.currentHits++;
                this.currentSession.totalHits++; 
                
                // éŸ³æ•ˆ
                const progress = Math.min(1, this.currentSession.currentHits / this.currentSession.nextTriggerThreshold);
                if (this.currentSession.currentHits < this.currentSession.nextTriggerThreshold) {
                    if (Math.random() < 0.5) audio.playTone(500 * (1.0 + progress * 0.5), 'triangle', 0.05, 0.2); 
                }

                // æ›´æ–° UI
                this.updateHitProgress(this.currentSession.currentHits, this.currentSession.nextTriggerThreshold); 
                
                const pulseLayer = this.uiCache.pulseLayer; // ä½¿ç”¨ç¼“å­˜ DOM
                if (pulseLayer) {
                    pulseLayer.style.setProperty('--pulse-color', color);
                    if (!pulseLayer.classList.contains('pulse-active')) {
                        pulseLayer.classList.add('pulse-active');
                        setTimeout(() => pulseLayer.classList.remove('pulse-active'), 700);
                    }
                }

                // éœ‡åŠ¨èŠ‚æµ
                const now = Date.now();
                if (this.uiCache.el && (!this.lastUiShakeTime || now - this.lastUiShakeTime > 100)) {
                    this.lastUiShakeTime = now;
                    const el = this.uiCache.el;
                    el.classList.remove('gauge-shake');
                    void el.offsetWidth; 
                    el.classList.add('gauge-shake');
                }
                
                // ç²’å­
                for(let i=0; i<3; i++) {
                    const p = new Particle(targetX, targetY, color, 'spark');
                    p.vel = new Vec2((Math.random()-0.5)*3, (Math.random()-0.5)*3);
                    this.particles.push(p);
                }

                if (this.currentSession.currentHits >= this.currentSession.nextTriggerThreshold) {
                    this.triggerLevelUpEvent(targetX, targetY); 
                } 
            }
            this.attemptCompleteGatheringTurn();
        }));
    }

    triggerLevelUpEvent(uiX, uiY) {
    this.currentSession.currentHits = 0;
    this.currentSession.multicast++; 
    this.updateMulticastDisplay(1);
    
    // 1. éŸ³æ•ˆçˆ†ç™¼
    audio.playPowerup(this.currentSession.multicast); 
    
    // 2. UI å®¹å™¨è¿›å…¥â€œæ»¡èƒ½é‡â€çŠ¶æ€åŠ¨ç”»
    const gaugeShell = this.uiCache ? this.uiCache.gaugeShell : document.getElementById('gauge-shell');
    if (gaugeShell) {
        // æ·»åŠ é’ˆå¯¹åœ†è§’ä¼˜åŒ–çš„å‘å…‰ç±»
        gaugeShell.classList.add('gauge-full');
        
        // 0.8ç§’åç§»é™¤
        setTimeout(() => gaugeShell.classList.remove('gauge-full'), 800);
    }
    // 3. å¼ºåŠ›å†²å‡»æ³¢
    this.createShockwave(uiX, uiY, '#facc15');
    
    // 4. ç”Ÿæˆå¤§é‡ç²’å­
    for(let i=0; i<20; i++) {
        const px = uiX + (Math.random()-0.5) * 80;
        const py = uiY + (Math.random()-0.5) * 30;
        this.createParticle(px, py, '#fcd34d', 'spark');
    }

    this.createFloatingText(uiX, uiY - 50, "LEVEL UP!", "#fff");
    this.updateHitProgress(0, this.currentSession.nextTriggerThreshold);
}

    // åœ¨ Game ç±»ä¸­
    compileCollectionToRecipe(marbleDef, collectedTypes, hasMulticast) {
        const recipe = { 
            damage: 2, 
            bounce: 0, pierce: 0, scatter: 0, 
            explosive: marbleDef.type === 'redStripe', 
            isMatryoshka: marbleDef.type === 'matryoshka', 
            isLaser: marbleDef.type === 'laser', // é»˜è®¤ä¸º falseï¼Œç”± collected å†³å®š
            nestedPayload: null, chainPayload: null, 
            multicast: hasMulticast ? 2 : 0, 
            cryo: 0, pyro: 0, lightning: 0, laser: marbleDef.type === 'laser' ? 1 : 0 
        };


        // --- 2. æ”¶é›†å±æ€§ (Collected Stats) ---
        collectedTypes.forEach(t => { 
            // æ”¶é›†åˆ°å¼¹æ€§é’‰å­ -> å¢åŠ åå¼¹æ¬¡æ•°
            if (t === 'bounce') recipe.bounce += 1; 
            if (t === 'pierce') recipe.pierce += 1; 
            if (t === 'scatter') recipe.scatter += 1; 
            if (t === 'damage') recipe.damage += 2; 
            if (t === 'cryo') recipe.cryo += 1; 
            if (t === 'pyro') recipe.pyro += 1;       
            if (t === 'lightning') recipe.lightning += 1;      
            // æ”¶é›†åˆ°æ¿€å…‰é’‰å­ -> å¢åŠ æ¿€å…‰å±‚æ•°
            if (t === 'laser') {
                recipe.laser += 1; 
            }
        });
        if (recipe.laser > 0) {
            recipe.isLaser = true;
        }
        return recipe;
    }
    /**
    /**
     * @method updateGatheringQueueUI
     * @description æ›´æ–°æ”¶é›†é˜¶æ®µçš„å¼¹ç é˜Ÿåˆ—UIã€‚
     */
    updateGatheringQueueUI() { 
        const q = document.getElementById('gathering-queue'); 
        q.innerHTML = ''; 
        for(let i = this.activeMarbleIndex; i < this.marbleQueue.length; i++) { 
            const m = this.marbleQueue[i]; 
            const d = document.createElement('div'); 
            d.className = 'queue-dot flex-shrink-0'; 
            d.style.background = m.type === 'rainbow' ? CONFIG.colors.marbleRainbow : m.getColor(); 
            q.appendChild(d); 
        } 
    }
    /**
    /**
     * @method updateHitProgress
     * @description æ›´æ–°å‘½ä¸­è¿›åº¦æ¡UIã€‚
     * @param {number} val - **é‡è¦å‚æ•°** å½“å‰å‘½ä¸­æ¬¡æ•°ã€‚
     * @param {number} target - **é‡è¦å‚æ•°** ç›®æ ‡å‘½ä¸­æ¬¡æ•°ã€‚
     */
    updateHitProgress(val, target) { 
        // æ›´æ–°æ•°å­—
        document.getElementById('hit-text').innerText = `${val}/${target}`; 
        
        // è®¡ç®—ç™¾åˆ†æ¯”
        const pct = target > 0 ? Math.min(100, (val/target)*100) : 0; 
        const bar = document.getElementById('hit-bar');
        
        if(bar) {
            // æ›´æ–°å®½åº¦
            bar.style.width = `${pct}%`;
            
            // çŠ¶æ€åˆ‡æ¢ï¼šæ»¡èƒ½é‡ vs æ™®é€š
            if (pct >= 99) {
                bar.classList.add('bar-full');
            } else {
                bar.classList.remove('bar-full');
            }
        }
    }
    /**
     * @method updateAmmoUI
     * @description æ›´æ–°æˆ˜æ–—é˜¶æ®µçš„åŒæ§½ä½å¼¹è¯UI (Current & Next)
     */
    updateAmmoUI() {
        const currentContainer = document.getElementById('current-ammo-render');
        const nextContainer = document.getElementById('next-ammo-render');
        const statsContainer = document.getElementById('current-bullet-stats');
        
        if (!currentContainer || !nextContainer) return;

        // æ¸…ç©ºå½“å‰å†…å®¹
        currentContainer.innerHTML = '';
        nextContainer.innerHTML = '';

        // 1. æ¸²æŸ“å½“å‰å¼¹è¯ (Queue[0])
        if (this.ammoQueue.length > 0) {
            const currentRecipe = this.ammoQueue[0];
            this.renderAmmoIcon(currentContainer, currentRecipe, true);
            
            // æ›´æ–°åº•éƒ¨å±æ€§æ–‡æœ¬
            let html = '';
            if (currentRecipe.damage > 2) html += `<span class="text-purple-300">âš”ï¸${currentRecipe.damage}</span>`;
            else html += `<span class="text-slate-400">âš”ï¸${currentRecipe.damage}</span>`;
            
            if (currentRecipe.bounce) html += `<span class="text-green-300">â¤´ï¸${currentRecipe.bounce}</span>`;
            if (currentRecipe.pierce) html += `<span class="text-red-300">â†—ï¸${currentRecipe.pierce}</span>`;
            if (currentRecipe.scatter) html += `<span class="text-yellow-300">ğŸ”±${currentRecipe.scatter}</span>`;
            if (currentRecipe.multicast) html += `<span class="text-orange-400">âš¡${currentRecipe.multicast}</span>`;
            if (currentRecipe.cryo) html += `<span class="text-cyan-300">â„ï¸${currentRecipe.cryo}</span>`;
            if (currentRecipe.pyro) html += `<span class="text-orange-500">ğŸ”¥${currentRecipe.pyro}</span>`;
            if (currentRecipe.lightning) html += `<span class="text-purple-400">âš¡${currentRecipe.lightning}</span>`;
            
            if(html === '') html = '<span class="text-slate-500">åŸºç¡€å¼¹è¯</span>';
            statsContainer.innerHTML = html;
            
            // ç§»é™¤å‘å°„åŠ¨ç”»ç±»ï¼ˆå¦‚æœæ˜¯é‡æ–°æ¸²æŸ“ï¼‰
            currentContainer.classList.remove('shoot-anim');
        } else {
            currentContainer.innerHTML = '<span class="text-slate-600 text-xs">EMPTY</span>';
            statsContainer.innerHTML = '<span class="text-slate-600">-- å¼¹è¯è€—å°½ --</span>';
        }

        // 2. æ¸²æŸ“ä¸‹ä¸€å‘å¼¹è¯ (Queue[1])
        if (this.ammoQueue.length > 1) {
            const nextRecipe = this.ammoQueue[1];
            this.renderAmmoIcon(nextContainer, nextRecipe, false);
        } else {
            nextContainer.innerHTML = '<span class="text-slate-700 text-xs">--</span>';
        }
    }

    /**
     * è¾…åŠ©æ–¹æ³•ï¼šåœ¨UIä¸­ç»˜åˆ¶ä¸€ä¸ªçº¯CSSçš„å­å¼¹å›¾æ ‡
     */
    renderAmmoIcon(container, recipe, isCurrent) {
        const size = isCurrent ? 24 : 16;
        const div = document.createElement('div');
        
        // åŸºç¡€çƒä½“
        div.style.width = `${size}px`;
        div.style.height = `${size}px`;
        div.style.borderRadius = '50%';
        
        // é¢œè‰²é€»è¾‘ (ä¸ Projectile ä¸€è‡´)
        let bg = '#e2e8f0';
        let shadow = 'none';


        //  å…‰çƒçš„ UI æ ·å¼ (é«˜ä¼˜å…ˆçº§)
        if (recipe.isLaser) { 
            // æ ¸å¿ƒç™½ï¼Œå¤–å‘å…‰è“ï¼Œæ¨¡æ‹Ÿâ€œå…‰çƒâ€è´¨æ„Ÿ
            bg = '#ffffff'; 
            // åŠ¨æ€é˜´å½±ï¼šæ¿€å…‰å±‚æ•°è¶Šå¤šï¼Œé˜´å½±æ‰©æ•£è¶Šå¤§
            const glowSize = 10 + (recipe.laser || 0) * 2;
            shadow = `0 0 ${glowSize}px ${CONFIG.colors.laser}, inset 0 0 5px ${CONFIG.colors.laser}`;
        }else if (recipe.explosive) { bg = '#fca5a5'; shadow = '0 0 10px #ef4444'; }
        else if (recipe.pyro) { bg = '#fdba74'; shadow = '0 0 8px #f97316'; }
        else if (recipe.cryo) { bg = '#cffafe'; shadow = '0 0 8px #06b6d4'; }
        else if (recipe.lightning) { bg = '#e9d5ff'; shadow = '0 0 8px #c084fc'; }
        else if (recipe.pierce) { bg = '#fecaca'; }
        else if (recipe.bounce) { bg = '#bbf7d0'; }
        
        div.style.background = bg;
        div.style.boxShadow = shadow;
        div.style.position = 'relative';

        if (recipe.isLaser) {
             div.style.border = '2px solid #fff'; // åŠ ä¸ªç™½åœˆ
        }
        // ç®€å•å›¾æ ‡è£…é¥°
        if (recipe.scatter) {
            div.style.border = '2px solid #facc15'; // é»„æ¡†
        }
        if (recipe.multicast) {
            const badge = document.createElement('div');
            badge.innerText = `+${recipe.multicast}`;
            badge.className = 'absolute -top-2 -right-2 text-[10px] bg-orange-500 text-white rounded-full px-1 font-bold leading-tight';
            container.appendChild(badge);
        }
        
        container.appendChild(div);
    }
    //  å¤„ç†å•ä¸ªæ•Œäººçš„å›åˆé€»è¾‘ (å½“æ³¢æ‰«åˆ°å®ƒæ—¶è°ƒç”¨)
    processSingleEnemyTurn(e) {
        if (!e.active || e.hasActedThisTurn) return;
        
        e.hasActedThisTurn = true; 
        
        //  åªè¦è§¸ç™¼äº†çµç®—ï¼Œå¼·è¿«æƒææ³¢åœ¨æ¥ä¸‹ä¾†çš„ 45 å¹€å…§ä¿æŒæ…¢é€Ÿ
        // é€™æ¨£å³ä½¿æ•µäººè¢«ç‡’æ­»æ¶ˆå¤±äº†ï¼Œæ³¢æµªä¹Ÿæœƒæ…¢æ…¢æƒéå±é«”ä½ç½®ï¼Œå±•ç¾"æ“Šæ®ºç¢ºèª"çš„æ„Ÿè¦º
        this.waveMomentumTimer = 45; 

        // --- 1. æº«åº¦çµç®—é‚è¼¯ ---
        if (e.temp < 0) {
            // ... (å†°å‡é‚è¼¯ä¿æŒä¸è®Š)
             const freezeChance = Math.min(Math.abs(e.temp) / 100, 1.0)/2;
             if (Math.random() < freezeChance && e.temp<=-50) { 
                 e.isFrozenCurrentTurn = true;
                 this.createExplosion(e.pos.x, e.pos.y, '#06b6d4');
                 audio.playEffect('freeze');
             }else{
                 e.isFrozenCurrentTurn = false;
             }
             e.temp = Math.ceil(e.temp / 2);
        }

        if (e.temp > 0) {
            if (e.temp < 100) {
                 e.temp = Math.max(0, e.temp - 5);
            } else {
                const dot = 5 + (e.temp - 100);
                e.takeDamage(dot); // <--- æ•µäººå¯èƒ½åœ¨é€™è£¡æ­»äº¡ (active = false)
                
                // è§¸ç™¼ç‡ƒç‡’ç‰¹æ•ˆ
                e.playBurnTickEffect(this, Math.floor(dot));
                
                const decay = Math.floor(e.temp / 20);
                e.temp = Math.max(0, e.temp - decay);
            }
        }

        // --- 2. è¡Œå‹•é‚è¼¯ ---
        // åªæœ‰æ´»è‘—çš„æ•µäººæ‰ç§»å‹•
        if (e.active && e.isFrozenCurrentTurn == false) {
            e.performTurnActionAndMove(this);
        }
    }
    /**
     * @method startEnemyTurnLogic
     * @description å¯åŠ¨æ•Œäººå›åˆï¼šé”å®šçŠ¶æ€ã€æ˜¾ç¤ºUIæç¤ºã€å¹¶è®¡ç®—æ‰€æœ‰æ•Œäººçš„ç§»åŠ¨ä¸æŠ€èƒ½
     */
    startEnemyTurnLogic() {
        this.isEnemyTurn = true;
        this.enemyTurnTimer = 0;

        // åˆå§‹åŒ–æ‰«ææ³¢
        this.enemyWaveActive = true;
        this.enemyWaveY = this.height + 50; // ä»å±å¹•æœ€ä¸‹æ–¹å¼€å§‹
        this.waveSpeed = 8 * this.timeScale; // æ ¹æ®å€é€Ÿè°ƒæ•´æ‰«æé€Ÿåº¦

        // é‡ç½®æ‰€æœ‰æ•Œäººçš„è¡ŒåŠ¨æ ‡è®°
        this.enemies.forEach(e => {
            e.hasActedThisTurn = false;
            e.isFrozenCurrentTurn = false; // é‡ç½®ä¸Šä¸€è½®çš„å†°å†»çŠ¶æ€
        });

        // UI æç¤º
        const msgEl = document.getElementById('combat-message');
        if (msgEl) {
            msgEl.innerHTML = '<span class="text-yellow-400 font-bold text-xl drop-shadow-md">âš ï¸ ENEMY TURN</span>';
            msgEl.classList.remove('opacity-0');
            msgEl.classList.add('pop-anim'); 
        }
    }


      /**
     * @method finalizeRound
     * @description [ä¿®æ”¹ç‰ˆ] å›åˆç»“ç®—ï¼ŒåŒ…å«åŠ£åŠ¿è¡¥å¿æœºåˆ¶(è‡ªåŠ¨æé€Ÿ)
     */
    finalizeRound() {
        // 1. ç»Ÿè®¡å½“å‰å­˜æ´»æ•Œäººæ•°æ®
        const activeEnemies = this.enemies.filter(e => e.active);
        // ä½¿ç”¨ Set ç»Ÿè®¡æœ‰å¤šå°‘ä¸ªä¸åŒçš„ Y åæ ‡ï¼ˆå³æœ‰å¤šå°‘è¡Œï¼‰
        // Math.round å¤„ç†æµ®ç‚¹è¯¯å·®ï¼Œ/50 æ˜¯è¡Œé«˜ï¼Œç¡®ä¿å½’ç±»å‡†ç¡®
        const uniqueRows = new Set(activeEnemies.map(e => Math.round(e.pos.y / this.enemyHeight)));
        
        // 2. è§¦å‘æ¡ä»¶åˆ¤å®šï¼šè¡Œæ•° <= 1 æˆ– æ€»æ•° <= 5
        if (uniqueRows.size <= 1 || activeEnemies.length <= 5) {
            let buffCount = 0;
            activeEnemies.forEach(e => {
                if (!e.affixes.includes('haste')) {
                    e.affixes.push('haste');
                    buffCount++;
                    // [è§†è§‰] è·å¾—Buffçš„ç‰¹æ•ˆ
                    this.createParticle(e.pos.x, e.pos.y, '#facc15', 'spark');
                }
            });
            
            if (buffCount > 0) {
                showToast("âš ï¸ æ•µè»ç‹‚æš´ (HASTE APPLIED) âš ï¸");
                audio.playPowerup(); // æ’­æ”¾è­¦ç¤ºéŸ³
            }
        }

        // --- ä»¥ä¸‹ä¿æŒåŸæœ‰çš„å›åˆç»“ç®—é€»è¾‘ ---
        
        // ç”Ÿæˆæ–°æ•Œäºº
        const rowCountCurrent = uniqueRows.size;
        let spawnCount = 1;
        if (rowCountCurrent < 4) spawnCount = 3; // ç¨å¾®æ¿€è¿›ä¸€ç‚¹çš„ç”Ÿæˆ
        this.spawnEnemyRow(spawnCount);

        // é‡ç½®å€ç‡
        if (this.nextRoundHpMultiplier > 1) {
            showToast("å¼·æ•µä¾†è¥²ï¼HP x" + this.nextRoundHpMultiplier);
            this.nextRoundHpMultiplier = 1;
        }

        // æ›´æ–°å›åˆæ•°
        this.round++;
        this.prevRoundDamage = this.roundDamage;
        this.roundDamage = 0;
        document.getElementById('round-num').innerText = this.round;
        showToast(`Round ${this.round}`);

        // æ£€æŸ¥å¤±è´¥
        if (this.checkDefeat()) {
            this.gameOver = true;
            return;
        }

        document.getElementById('combat-message').innerHTML = '';
        this.initPachinko();

        // é—ç‰©äº‹ä»¶æ£€æŸ¥
        if (this.round % CONFIG.gameplay.relicRoundInterval == 0) {
            showToast("âœ¨ å‘½é‹çš„é¥‹è´ˆ âœ¨");
            this.phase = 'relic_event';
            setTimeout(() => { this.showRelicSelection(); }, 500);
            return;
        }
        
        this.isEnemyTurn = false;
        if (this.ammoQueue.length === 0) {
            this.initSelectionPhase();
        }
    }

    /**
     * @method checkDefeat
     * @description æ£€æŸ¥æ˜¯å¦å¤±è´¥ (æ˜¯å¦æœ‰æ•Œäººè¶Šè¿‡å¤±è´¥çº¿)ã€‚
     * @returns {boolean} æ˜¯å¦å¤±è´¥ã€‚
     */
        /**
     * @method checkDefeat
     * @description æ£€æŸ¥æ˜¯å¦å¤±è´¥ (åŒ…å«è§†å·®åç§»è®¡ç®—)ã€‚
     * @returns {boolean} æ˜¯å¦å¤±è´¥ã€‚
     */
        /**
     * @method checkDefeat
     * @description æ£€æŸ¥æ˜¯å¦å¤±è´¥ (åŒ…å«è§†å·®åç§»è®¡ç®—)ã€‚
     */
    checkDefeat() { 
        // [ä¿®æ­£]ï¼šä½¿ç”¨å®ä½“å±‚ Y è½´ç³»æ•° (-20)
        const viewShiftY = this.boardTilt.current.y * -20;

        for(let e of this.enemies) { 
            // åˆ¤æ–­ï¼š(æ•Œäººé€»è¾‘ä½ç½® + è§†è§‰åç§») æ˜¯å¦è¶…è¿‡ é˜²çº¿
            if (e.active && (e.pos.y + viewShiftY) > this.defeatLineY) {
                return true; 
            }
        } 
        return false; 
    }

 /**
     * æ›´æ–°æˆ˜æ–—é˜¶æ®µçš„é€»è¾‘å’Œç»˜åˆ¶
     */
    /**
     * @method updateCombat
     * @description æˆ˜æ–—é˜¶æ®µçš„æ¸¸æˆé€»è¾‘æ›´æ–°ã€‚
     * @param {number} timeScale - **é‡è¦å‚æ•°** æ—¶é—´ç¼©æ”¾å› å­ã€‚
     */
        /**
     * @method updateCombat
     * @description æˆ˜æ–—é˜¶æ®µçš„æ¸¸æˆé€»è¾‘æ›´æ–° (ä¿®å¤è§†å·®ä¸é˜²çº¿æ˜¾ç¤º)ã€‚
     * @param {number} timeScale - **é‡è¦å‚æ•°** æ—¶é—´ç¼©æ”¾å› å­ã€‚
     */
        /**
     * @method updateCombat
     * @description æˆ˜æ–—é˜¶æ®µçš„æ¸¸æˆé€»è¾‘æ›´æ–° (åˆ†å±‚è§†å·®ç‰ˆ)ã€‚
     */
        /**
     * @method updateCombat
     * @description æˆ˜æ–—é˜¶æ®µçš„æ¸¸æˆé€»è¾‘æ›´æ–° (å«å¯è§†åŒ–å¢™å£ä¸åˆ†å±‚è§†å·®)ã€‚
     */
    updateCombat(timeScale) {
        const tilt = this.boardTilt.current;
        const container = document.getElementById('game-container');
        if (container) {
            container.style.perspective = "1200px";
            const rotateX = tilt.y * -8;
            const rotateY = tilt.x * 8;
            const translateZ = -20;
            container.style.transform = `rotateX(${rotateX}deg) rotateY(${rotateY}deg) translateZ(${translateZ}px)`;
        }

        // === 1. è®¡ç®—è§†å·®å‚æ•° ===
        // èƒŒæ™¯å±‚ (åœ°æ¿)ï¼šæ­£å‘ç§»åŠ¨
        const bgShiftX = tilt.x * 20;
        const bgShiftY = tilt.y * 15;

        // å®ä½“å±‚ (æ•Œäºº/UI/å¢™å£)ï¼šåå‘ç§»åŠ¨
        const entityShiftX = tilt.x * -15;
        const entityShiftY = tilt.y * -10;

        // åº”ç”¨ CSS åˆ° DOM UI
        // const skillBar = document.getElementById('skill-bar');
        // const hud = document.getElementById('recipe-hud-container');
        // const uiTransform = `translate3d(${entityShiftX}px, ${entityShiftY}px, 0)`;
        // if (skillBar) skillBar.style.transform = uiTransform;
        // if (hud) hud.style.transform = uiTransform;

        // --- é€»è¾‘æ›´æ–° ---
        for (let i = this.burstQueue.length - 1; i >= 0; i--) { 
            const shot = this.burstQueue[i]; 
            shot.delay -= timeScale; 
            if (shot.delay <= 0) { 
                this.spawnBullet(this.width/2, this.height-80, shot.vel, shot.recipe); 
                audio.playShoot(); 
                this.burstQueue.splice(i, 1); 
            } 
        }
        if (this.waveMomentumTimer > 0) this.waveMomentumTimer -= timeScale;

        // ==========================================
        //  LAYER 0: å›ºå®š UI å±‚ (é˜²çº¿)
        // ==========================================
        this.ctx.save();
        this.ctx.strokeStyle = 'rgba(239, 68, 68, 0.5)';
        this.ctx.lineWidth = 2;
        this.ctx.setLineDash([10, 10]);
        this.ctx.beginPath();
        this.ctx.moveTo(0, this.defeatLineY);
        this.ctx.lineTo(this.width, this.defeatLineY);
        this.ctx.stroke();
        this.ctx.fillStyle = 'rgba(239, 68, 68, 0.7)';
        this.ctx.font = 'bold 10px monospace';
        this.ctx.fillText("âš ï¸ DEFENSE LINE", 10, this.defeatLineY - 6);
        const dangerGrad = this.ctx.createLinearGradient(0, this.defeatLineY, 0, this.height);
        dangerGrad.addColorStop(0, 'rgba(239, 68, 68, 0.1)');
        dangerGrad.addColorStop(1, 'rgba(239, 68, 68, 0.3)');
        this.ctx.fillStyle = dangerGrad;
        this.ctx.fillRect(0, this.defeatLineY, this.width, this.height - this.defeatLineY);
        this.ctx.restore();


        // ==========================================
        //  LAYER 1: èƒŒæ™¯å±‚ (ç½‘æ ¼ & æ‰«ææ³¢)
        // ==========================================
        this.ctx.save();
        this.ctx.translate(bgShiftX, bgShiftY); 

            // A. ç»˜åˆ¶èƒŒæ™¯ç½‘æ ¼
            this.ctx.save();
            this.ctx.strokeStyle = 'rgba(71, 85, 105, 0.15)';
            this.ctx.lineWidth = 1;
            this.ctx.beginPath();
            const gridOffsetX = bgShiftX * 1.5;
            const gridOffsetY = bgShiftY * 1.5;
            for (let x = -50; x < this.width + 50; x += 40) {
                this.ctx.moveTo(x, -50); this.ctx.lineTo(x, this.height + 50);
            }
            for (let y = -50; y < this.height + 50; y += 40) {
                this.ctx.moveTo(-50, y); this.ctx.lineTo(this.width + 50, y);
            }
            this.ctx.stroke();
            this.ctx.restore();

            // B. ç»˜åˆ¶æ‰«ææ³¢
            if (this.isEnemyTurn && this.enemyWaveActive) {
                const currentSpeed = this.calculateWaveSpeed();
                this.enemyWaveY -= currentSpeed;

                this.ctx.save();
                this.ctx.globalCompositeOperation = 'lighter';
                
                const trailHeight = 220; 
                const gridGrad = this.ctx.createLinearGradient(0, this.enemyWaveY, 0, this.enemyWaveY + trailHeight);
                gridGrad.addColorStop(0, 'rgba(251, 191, 36, 0.5)'); 
                gridGrad.addColorStop(0.3, 'rgba(217, 119, 6, 0.2)'); 
                gridGrad.addColorStop(1, 'rgba(180, 83, 9, 0)');     
                this.ctx.strokeStyle = gridGrad;
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                const cols = 8;
                for(let i=0; i<=cols; i++) {
                    const x = (this.width / cols) * i;
                    this.ctx.moveTo(x, this.enemyWaveY);
                    this.ctx.lineTo(x, this.enemyWaveY + trailHeight);
                }
                const gridSize = 40;
                const startGridY = Math.floor(this.enemyWaveY / gridSize) * gridSize;
                for(let y = startGridY; y < this.enemyWaveY + trailHeight; y += gridSize) {
                    if(y > this.enemyWaveY) { 
                        this.ctx.moveTo(0, y);
                        this.ctx.lineTo(this.width, y);
                    }
                }
                this.ctx.stroke();

                const time = Date.now() / 50; 
                this.ctx.beginPath();
                this.ctx.strokeStyle = '#ffffff'; 
                this.ctx.lineWidth = 3;
                this.ctx.shadowColor = '#fef08a'; 
                this.ctx.shadowBlur = 15;
                for (let x = 0; x <= this.width; x += 10) {
                    const offset = Math.sin(x * 0.1 + time) * 2 + (Math.random() - 0.5) * 6;
                    const y = this.enemyWaveY + offset;
                    if (x === 0) this.ctx.moveTo(x, y);
                    else this.ctx.lineTo(x, y);
                }
                this.ctx.stroke();
                
                this.ctx.fillStyle = '#fef3c7'; 
                for(let i=0; i<5; i++) {
                    const lx = Math.random() * this.width;
                    const ly = this.enemyWaveY + (Math.random() - 0.5) * 30;
                    const lw = Math.random() * 50 + 10;
                    this.ctx.fillRect(lx, ly, lw, 1);
                }
                this.ctx.restore();

                const triggerLine = this.enemyWaveY; 
                this.enemies.forEach(e => {
                    if (!e.active) return;
                    if (e.pos.y + e.height/2 >= triggerLine && !e.hasActedThisTurn) {
                        e.playScanFeedback();
                        this.processSingleEnemyTurn(e);
                    }
                });
                if (this.enemyWaveY < -50) {
                    this.enemyWaveActive = false;
                    this.enemyTurnTimer = 0;
                }
            }
        this.ctx.restore(); 


        // ==========================================
        //  LAYER 2: å®ä½“å±‚ (å¢™å£ / æ•Œäºº / å­å¼¹)
        // ==========================================
        this.ctx.save();
        this.ctx.translate(entityShiftX, entityShiftY); 

            // --- [æ–°å¢]ï¼šç»˜åˆ¶å¯è§†åŒ–çš„è¾¹ç•Œå¢™å£ ---
            this.ctx.save();
            // å·¦å¢™ (åŠé€æ˜æ¸å˜)
            const wallGradLeft = this.ctx.createLinearGradient(0, 0, 20, 0);
            wallGradLeft.addColorStop(0, 'rgba(148, 163, 184, 0.2)');
            wallGradLeft.addColorStop(1, 'rgba(148, 163, 184, 0)');
            this.ctx.fillStyle = wallGradLeft;
            this.ctx.fillRect(0, -100, 20, this.height + 100);
            
            // å³å¢™ (åŠé€æ˜æ¸å˜)
            const wallGradRight = this.ctx.createLinearGradient(this.width, 0, this.width - 20, 0);
            wallGradRight.addColorStop(0, 'rgba(148, 163, 184, 0.2)');
            wallGradRight.addColorStop(1, 'rgba(148, 163, 184, 0)');
            this.ctx.fillStyle = wallGradRight;
            this.ctx.fillRect(this.width - 20, -100, 20, this.height + 100);

            // å¢™å£å‘å…‰è¾¹æ¡† (æ˜ç¡®åå¼¹çº¿)
            this.ctx.strokeStyle = 'rgba(148, 163, 184, 0.4)'; // Slate-400
            this.ctx.lineWidth = 2;
            this.ctx.shadowColor = '#94a3b8';
            this.ctx.shadowBlur = 10;
            this.ctx.beginPath();
            // å·¦è¾¹çº¿
            this.ctx.moveTo(1, -100); this.ctx.lineTo(1, this.height);
            // å³è¾¹çº¿
            this.ctx.moveTo(this.width - 1, -100); this.ctx.lineTo(this.width - 1, this.height);
            // é¡¶éƒ¨çº¿ (å°é¡¶)
            this.ctx.moveTo(0, 1); this.ctx.lineTo(this.width, 1);
            this.ctx.stroke();
            this.ctx.restore();
            // ------------------------------------

            // C. ç»˜åˆ¶æ¸¸æˆå®ä½“
            let activeEnemies = 0; 
            let anyEnemyMoving = false;
            this.enemies.forEach(e => {
                if (e.active) {
                    e.update(this.timeScale);
                    e.draw(this.ctx);
                    activeEnemies++;
                    if (Math.abs(e.pos.y - e.dropTargetY) > 1) anyEnemyMoving = true;
                }
            });

            if (this.checkDefeat()) this.gameOver = true;

            // æ›´æ–°å’Œç»˜åˆ¶å¼¹ä¸¸
            for (let i = this.projectiles.length - 1; i >= 0; i--) { 
                const p = this.projectiles[i]; 
                if(p) { 
                    p.update(this.width, this.height, this.enemies, (spawnInfo) => { this.spawnBullet(spawnInfo.x, spawnInfo.y, spawnInfo.vel, spawnInfo.config); }, timeScale); 
                    p.draw(this.ctx); 
                    if (p.destroyed) this.projectiles.splice(i, 1); 
                } 
            }

            // æ›´æ–°å’Œç»˜åˆ¶ FireWaves
            for (let i = this.fireWaves.length - 1; i >= 0; i--) {
                const fw = this.fireWaves[i];
                fw.update(timeScale);
                fw.draw(this.ctx);
                if (fw.life <= 0) this.fireWaves.splice(i, 1);
            }

            // æ›´æ–°å’Œç»˜åˆ¶ç‰¹æ•ˆ
            for(let i=this.particles.length-1; i>=0; i--) { let p = this.particles[i]; if(p) { p.update(timeScale); p.draw(this.ctx); if(p.life <= 0) this.particles.splice(i,1); } } 
            for(let i=this.shockwaves.length-1; i>=0; i--) { let s = this.shockwaves[i]; if(s) { s.update(timeScale); s.draw(this.ctx); if(s.alpha <= 0) this.shockwaves.splice(i,1); } } 
            for(let i=this.lightningBolts.length-1; i>=0; i--) { let b = this.lightningBolts[i]; b.update(timeScale); b.draw(this.ctx); if(b.life <= 0) this.lightningBolts.splice(i,1); } 
            for(let i=this.spores.length-1; i>=0; i--) { let s = this.spores[i]; if(s) { s.update(timeScale); s.draw(this.ctx); if(!s.active) this.spores.splice(i,1); } }

            // æ‹–æ‹½ç„å‡†çº¿
            if (this.isDragging && this.projectiles.length === 0 && this.ammoQueue.length > 0 && this.burstQueue.length === 0) {
                const start = new Vec2(this.width / 2, this.height - 80);
                let force = this.lastMousePos.sub(start);
                
                if (force.y < -20) {
                    const maxLen = 800; 
                    const radius = CONFIG.physics.bulletRadius;
                    let dir = force.norm(); 
                    
                    this.ctx.save();
                    this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    this.ctx.lineWidth = 2;
                    this.ctx.setLineDash([6, 6]);
                    this.ctx.beginPath();
                    this.ctx.moveTo(start.x, start.y);

                    let distToX = Infinity;
                    let distToY = Infinity;
                    if (dir.x > 0) distToX = (this.width - radius - start.x) / dir.x;
                    else if (dir.x < 0) distToX = (radius - start.x) / dir.x;
                    if (dir.y < 0) distToY = (radius - start.y) / dir.y;

                    let hitDist = Math.min(distToX, distToY);
                    if (hitDist < maxLen) {
                        const hitPoint = start.add(dir.mult(hitDist));
                        this.ctx.lineTo(hitPoint.x, hitPoint.y);
                        const remainLen = maxLen - hitDist;
                        let reflectDir = new Vec2(dir.x, dir.y);
                        if (distToX < distToY) reflectDir.x *= -1; 
                        else reflectDir.y *= -1; 
                        const endPoint = hitPoint.add(reflectDir.mult(remainLen));
                        this.ctx.lineTo(endPoint.x, endPoint.y);
                        this.ctx.stroke();
                        this.ctx.beginPath();
                        this.ctx.setLineDash([]);
                        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                        this.ctx.arc(endPoint.x, endPoint.y, 3, 0, Math.PI * 2);
                        this.ctx.fill();
                    } else {
                        const end = start.add(dir.mult(maxLen));
                        this.ctx.lineTo(end.x, end.y);
                        this.ctx.stroke();
                    }
                    this.ctx.restore();

                    this.ctx.save();
                    this.ctx.translate(start.x, start.y);
                    this.ctx.rotate(Math.atan2(force.y, force.x));
                    this.ctx.fillStyle = '#6366f1';
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, 15, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.fillStyle = '#818cf8';
                    this.ctx.fillRect(10, -6, 12, 12); 
                    this.ctx.restore();
                }
            } else if (this.projectiles.length === 0) {
                const start = new Vec2(this.width / 2, this.height - 80);
                this.ctx.save();
                this.ctx.translate(start.x, start.y);
                this.ctx.rotate(-Math.PI / 2); 
                this.ctx.fillStyle = '#475569';
                this.ctx.beginPath();
                this.ctx.arc(0, 0, 12, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.fillRect(8, -4, 8, 8);
                this.ctx.restore();
            }

        

        this.ctx.restore(); // ç»“æŸå®ä½“å±‚


        // --- UI Overlays ---
        if (this.gameOver) { 
            document.getElementById('combat-message').innerHTML = '<span class="text-red-400 font-bold text-4xl">é˜²ç·šå¤±å®ˆ</span><br><span class="text-sm pointer-events-none">é»æ“Šé‡è¯•</span>'; 
            if (this.isDragging) location.reload(); 
            return; 
        }

        if (activeEnemies === 0) {
            const hasLeftoverAmmo = this.ammoQueue.length > 0;
            if (hasLeftoverAmmo) {
                const leftoverCount = this.ammoQueue.length;
                const scoreMult = Math.pow(CONFIG.balance.unusedAmmoScoreMult, leftoverCount);
                this.score *= scoreMult;
                document.getElementById('score-num').innerText = this.score; 
                this.nextRoundHpMultiplier = CONFIG.balance.nextRoundDifficultyMult;
                showToast(`å®Œç¾æ¸…å ´! åˆ†æ•¸ x${scoreMult} | ä¸‹è¼ªé›£åº¦ UP!`);
                audio.playPowerup();
                this.ammoQueue = []; 
                this.updateAmmoUI();
                this.renderRecipeHUD();
                this.clearProjectiles();
            }
        }

        const playerTurnFinished = this.ammoQueue.length === 0 && 
                                   this.projectiles.length === 0 && 
                                   this.burstQueue.length === 0;

        if (playerTurnFinished && !this.gameOver) {
            if (!this.isEnemyTurn) {
                this.startEnemyTurnLogic();
            } else {
                if (this.enemyWaveActive) return;
                if (anyEnemyMoving) {
                    this.enemyTurnTimer = 0; 
                    return;
                }
                this.enemyTurnTimer += this.timeScale;
                if (this.enemyTurnTimer > 80) { 
                    this.finalizeRound(); 
                    return;
                }
            }
            return;
        }

        if (this.ammoQueue.length === 0 && this.projectiles.length === 0 && this.burstQueue.length === 0 && !this.gameOver) { 
            document.getElementById('combat-message').innerHTML = '<div class="bg-black/50 p-4 rounded-xl backdrop-blur-md border border-blue-500/50 pointer-events-none"><span class="text-blue-300 font-bold text-xl block mb-2">å½ˆè—¥è€—ç›¡</span><span class="text-sm text-slate-300">é»æ“Šæ”¶é›†æ–°å½ˆè—¥</span></div>'; 
        } else { 
            if (!this.gameOver) document.getElementById('combat-message').innerHTML = ''; 
        }
        // --- ä¿®æ”¹å¼€å§‹ï¼šè°ƒæ•´å±‚çº§ï¼Œå…ˆç”»è½¨é“ï¼Œå†ç”»ç‚®å° ---
        this.ctx.save();
        // åº”ç”¨ä¸å®ä½“å±‚ç›¸åŒçš„è§†å·®åç§»
        this.ctx.translate(entityShiftX, entityShiftY);

        const startPos = new Vec2(this.width / 2, this.height - 80);
        this.ctx.fillStyle = 'rgba(15, 23, 42, 0.8)'; // æ·±è‰²åŠé€æ˜åº• (Slate-900 80%)
        this.ctx.beginPath();
        this.ctx.arc(startPos.x, startPos.y, 22, 0, Math.PI * 2); // åŠå¾„æ¯”å­å¼¹ç¨å¤§
        this.ctx.fill();
        let nextAmmo = this.ammoQueue.length > 0 ? this.ammoQueue[0] : null;

        if (nextAmmo) {
            const params = Projectile.calculateVisualParams(nextAmmo, false);
            let previewRotation = 0;
            let deformation = {x: 1, y: 1};
            
            if (this.isDragging) {
                const force = this.dragStart.sub(this.dragCurrent);
                if (force.mag() > 10) {
                    previewRotation = Math.atan2(force.y, force.x) + Math.PI / 2;
                    deformation = {x: 1.15, y: 0.85}; 
                }
            }

            // [ä¿®æ”¹ç‚¹ 1] å…ˆç»˜åˆ¶è½¨é“ (Orbitals) -> è¿™æ ·å®ƒå°±åœ¨ç‚®å°ä¸‹é¢
            this.drawLauncherOrbitals(this.ctx, startPos.x, startPos.y, nextAmmo);

            // [ä¿®æ”¹ç‚¹ 2] åç»˜åˆ¶ç‚®å°æ ¸å¿ƒ (Visuals) -> è¿™æ ·å®ƒå°±åœ¨ä¸Šé¢
            Projectile.drawVisuals(this.ctx, startPos.x, startPos.y, params.radius, nextAmmo, previewRotation, params.intensity, deformation);

        } else {
            // ç©ºä»“çŠ¶æ€
            this.ctx.fillStyle = '#1e293b';
            this.ctx.beginPath();
            this.ctx.arc(startPos.x, startPos.y, 10, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.strokeStyle = '#475569';
            this.ctx.stroke();
        }
        this.ctx.restore();
        
    }


    /**
     * @method attemptCompleteGatheringTurn
     * @description å°è¯•å®Œæˆæ”¶é›†å›åˆã€‚ä¿®å¤äº†æœ€åä¸€ä¸ªèƒ½é‡çƒå¯¼è‡´æ— æ³•ç»“ç®—çš„BUGã€‚
     */
    attemptCompleteGatheringTurn() {
        // è§£å†³æ–¹æ³•ï¼šåªè®¡ç®— active ä¸º true çš„èƒ½é‡çƒã€‚
        const activeOrbsCount = this.energyOrbs.filter(orb => orb.active).length;

        // 1. åŸºç¡€æ£€æŸ¥ï¼šå¦‚æœè¿˜æœ‰ä¸œè¥¿åœ¨åŠ¨ï¼Œç»å¯¹ä¸èƒ½ç»“ç®—
        if (this.dropBalls.length > 0 || activeOrbsCount > 0 || this.currentSession.activeBalls > 0) {
            return;
        }

        // 2. çŠ¶æ€æ£€æŸ¥ï¼šé˜²æ­¢é‡å¤ç»“ç®—
        // å¦‚æœå½“å‰ session å·²ç»è¢«æ ‡è®°ä¸ºâ€œå·²ç»“ç®—â€æˆ–ä¸å­˜åœ¨ï¼Œåˆ™ç›´æ¥è¿”å›
        if (!this.currentSession || this.currentSession.isFinished) return;

        // 3. æ‰§è¡Œç»“ç®—
        this.currentSession.isFinished = true; // ç«‹å³ä¸Šé”

        const marbleDef = this.marbleQueue[this.activeMarbleIndex];
        // å…œåº•æ£€æŸ¥ï¼šå¦‚æœæ­¤æ—¶ marbleDef ä¸å­˜åœ¨ï¼ˆé˜²æ­¢æ•°ç»„è¶Šç•Œï¼‰ï¼Œç›´æ¥åœæ­¢
        if (!marbleDef) {
            this.currentSession = null;
            return;
        }
        // --- [æ–°å¢] è§¸ç™¼å€ç‡è½‰ç§»ç‰¹æ•ˆ ---
        // è¨ˆç®—ç•¶å‰å€ç‡ (1 + é¡å¤–)
        const totalMulticast = 1 + this.currentSession.multicast;
        // åªæœ‰å€ç‡å¤§æ–¼ 1 æ™‚æ‰æ’­æ”¾ç‰¹æ•ˆï¼Œæˆ–è€…ä½ æƒ³æ¯æ¬¡éƒ½æ’­ä¹Ÿå¯ä»¥
        if (totalMulticast > 0) {
            this.playMulticastTransferEffect(totalMulticast);
        }
        const recipe = this.compileCollectionToRecipe(marbleDef, this.currentSession.collected, this.currentSession.multicast > 0);
        recipe.finalHits = this.currentSession.totalHits;
        recipe.multicast = this.currentSession.multicast;
        this.ammoQueue.push(recipe);
        
        marbleDef.multicast = this.currentSession.multicast;
        marbleDef.finalHits = this.currentSession.totalHits;

        this.activeMarbleIndex++;
        this.updateGatheringQueueUI();
        
        // 4. çŠ¶æ€æµè½¬
        if (this.activeMarbleIndex >= this.marbleQueue.length) {
            // æ‰€æœ‰å¼¹ç éƒ½æ‰”å®Œäº†ï¼Œè¿›å…¥æˆ˜æ–—
            setTimeout(() => this.startCombatPhase(), 500);
        } else {
             // å‡†å¤‡ä¸‹ä¸€å›åˆï¼Œæ¸…ç©ºå½“å‰ sessionï¼Œå…è®¸ç©å®¶å†æ¬¡ç‚¹å‡»
             this.currentSession = null; 
        }
    }

    /**
     * @method drawLauncherOrbitals
     * @description ç»˜åˆ¶å‘å°„å™¨å‘¨å›´çš„å±æ€§è½¨é“ (æ–¹æ¡ˆ2ï¼šé€æ˜èƒ½é‡çƒç¯ç»•)
     */
    drawLauncherOrbitals(ctx, centerX, centerY, recipe) {
        if (!recipe) return;

        // 1. æå–ä¸¦åˆä½µå±¬æ€§ (Merge Stats)
        const stats = [];
        
        // å®šç¾©å±¬æ€§æ˜ å°„ï¼šéµå -> {é¡è‰², åœ–æ¨™, å„ªå…ˆç´š}
        const mapping = {
            damage:    { val: recipe.damage > 2 ? recipe.damage : 0, color: '#a855f7', icon: 'âš”ï¸' }, // åŸºç¤å‚·å®³å¤§æ–¼2æ‰é¡¯ç¤º
            bounce:    { val: recipe.bounce, color: '#4ade80', icon: 'â¤´ï¸' },
            pierce:    { val: recipe.pierce, color: '#f87171', icon: 'â†—ï¸' },
            scatter:   { val: recipe.scatter, color: '#facc15', icon: 'ğŸ”±' },
            cryo:      { val: recipe.cryo, color: '#06b6d4', icon: 'â„ï¸' },
            multicast: { val: recipe.multicast, color: '#fb923c', icon: '', isMulticast: true },
            pyro:      { val: recipe.pyro, color: '#f97316', icon: 'ğŸ”¥' },
            lightning: { val: recipe.lightning, color: '#c084fc', icon: 'âš¡' },
            laser:     { val: recipe.laser, color: '#0ea5e9', icon: 'ğŸ”¦' },
            explosive: { val: recipe.explosive ? 1 : 0, color: '#ef4444', icon: 'ğŸ§¨' }
        };

        // éæ­·é…æ–¹ï¼Œå°‡å¤§æ–¼0çš„å±¬æ€§åŠ å…¥åˆ—è¡¨
        Object.keys(mapping).forEach(key => {
            const item = mapping[key];
            if (item.val > 0) {
                stats.push(item);
            }
        });

        if (stats.length === 0) return;

        // 2. è¨ˆç®—è»Œé“åƒæ•¸
        const time = Date.now() / 1000;
        const radius = 55; // è»Œé“åŠå¾‘
        const stepAngle = (Math.PI * 2) / stats.length;
        
        ctx.save();
        ctx.translate(centerX, centerY);

        // 3. ç¹ªè£½è»Œé“ç·š (æ·¡æ·¡çš„å…‰åœˆ)
        ctx.beginPath();
        ctx.arc(0, 0, radius, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.lineWidth = 1;
        ctx.stroke();

        // 4. ç¹ªè£½æ¯å€‹å±¬æ€§çƒ
        stats.forEach((stat, index) => {
            // å‹•æ…‹è§’åº¦ï¼šåŸºç¤åˆ†ä½ˆ + è‡ªè½‰
            const angle = stepAngle * index + (time * 0.5); 
            const ox = Math.cos(angle) * radius;
            const oy = Math.sin(angle) * radius;

            // --- ç¹ªè£½èƒ½é‡çƒèƒŒæ™¯ ---
            ctx.shadowBlur = 10;
            ctx.shadowColor = stat.color;
            ctx.fillStyle = 'rgba(15, 23, 42, 0.8)'; // æ·±è‰²åŠé€æ˜åº•
            ctx.beginPath();
            // æ ¹æ“šæ•¸å€¼å¤§å°å¾®èª¿çƒé«”å¤§å° (åŸºç¤ 14px, æ¯å±¤ +1px, ä¸Šé™ 22px)
            const orbSize = Math.min(22, 14 + stat.val * 0.5);
            ctx.arc(ox, oy, orbSize, 0, Math.PI * 2);
            ctx.fill();

            // --- ç¹ªè£½é‚Šæ¡† (ä»£è¡¨èƒ½é‡é¡è‰²) ---
            ctx.strokeStyle = stat.color;
            ctx.lineWidth = 2;
            ctx.stroke();

            // --- ç¹ªè£½åœ–æ¨™èˆ‡æ•¸å€¼ ---
            ctx.shadowBlur = 0;
            ctx.fillStyle = '#ffffff';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // å¦‚æœæ•¸å€¼å¤§æ–¼1ï¼Œé¡¯ç¤º "åœ–æ¨™+æ•¸å­—"ï¼Œå¦å‰‡åªé¡¯ç¤ºåœ–æ¨™
            if (stat.isMulticast) {
                // [ä¿®æ”¹ç‚¹] Multicast å•ç‹¬ç»˜åˆ¶é€»è¾‘ï¼šæ˜¾ç¤º x2, x3...
                ctx.font = 'bold 12px monospace';
                ctx.fillStyle = stat.color; // ä½¿ç”¨æ©™è‰²é«˜äº®
                // åŸºç¡€å‘å°„æ•°æ˜¯1ï¼Œmulticastæ˜¯é¢å¤–å¢åŠ çš„ï¼Œæ‰€ä»¥æ˜¾ç¤º 1 + val
                // æˆ–è€…å¦‚æœä½ æƒ³æ˜¾ç¤ºå¢åŠ é‡ï¼Œå°±å†™ x{val}ã€‚é€šå¸¸ç†è§£æ˜¯æ€»å‘å°„æ•°ã€‚
                // å‡è®¾ recipe.multicast æ˜¯é¢å¤–æ¬¡æ•° (ä¾‹å¦‚ +2)ï¼Œåˆ™æ€»æ•°ä¸º 1+2=3ã€‚
                // è¿™é‡Œä¸ºäº†ç›´è§‚ï¼Œå¦‚æœ multicast=2ï¼Œæˆ‘ä»¬æ˜¾ç¤º x3
                const totalShots = 1 + stat.val;
                ctx.fillText(`x${totalShots}`, ox, oy);
            } else {
                // å…¶ä»–å±æ€§åŸæœ‰é€»è¾‘
                ctx.font = '10px sans-serif';
                if (stat.val > 1) {
                    ctx.fillText(stat.icon, ox, oy - 5);
                    ctx.font = 'bold 9px sans-serif';
                    ctx.fillStyle = stat.color; 
                    ctx.fillText(`${stat.val}`, ox, oy + 6);
                } else {
                    ctx.font = '14px sans-serif';
                    ctx.fillText(stat.icon, ox, oy);
                }
            }
        });

        // 5. é€£ç·šç‰¹æ•ˆ (å°‡æ‰€æœ‰çƒé€£å‘ä¸­å¿ƒï¼Œå¢å¼·"è£å¡«ä¸­"çš„æ„Ÿè¦º)
        ctx.globalCompositeOperation = 'screen';
        ctx.lineWidth = 1;
        stats.forEach((stat, index) => {
            const angle = stepAngle * index + (time * 0.5);
            const ox = Math.cos(angle) * radius;
            const oy = Math.sin(angle) * radius;
            
            const grad = ctx.createLinearGradient(0, 0, ox, oy);
            grad.addColorStop(0, 'rgba(255,255,255,0)');
            grad.addColorStop(1, stat.color); // æ¼¸è®Šåˆ°å±¬æ€§è‰²
            
            ctx.strokeStyle = grad;
            ctx.globalAlpha = 0.3;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(ox, oy);
            ctx.stroke();
        });

        ctx.restore();
    }
    // Gathering Phase Update
    /**
     * @method updateGathering
     * @description æ”¶é›†éšæ®µçš„éŠæˆ²é‚è¼¯æ›´æ–°ã€‚
     * @param {number} [timeScale=1] - **é‡è¦åƒæ•¸** æ™‚é–“ç¸®æ”¾å› å­ã€‚
     */
    updateGathering(timeScale = 1) {
        if (document.getElementById('phase-relic').style.display !== 'none') return;

        const tilt = this.boardTilt.current;


        const container = document.getElementById('game-container');
        if (container) {
            // 1. è®¾ç½®é€è§†è·ç¦»ï¼Œå€¼è¶Šå° 3D æ„Ÿè¶Šå¼º
            container.style.perspective = "1200px"; 
            
            // 2. æ ¹æ®å€¾æ–œå€¼æ—‹è½¬å®¹å™¨
            // rotateX å¯¹åº”ä¸Šä¸‹å€¾æ–œ (tilt.y)ï¼ŒrotateY å¯¹åº”å·¦å³å€¾æ–œ (tilt.x)
            // ä¹˜ä»¥ 5 æˆ– 8 å¢åŠ æ—‹è½¬è§’åº¦çš„ä½“æ„Ÿ
            const rotateX = tilt.y * -8; 
            const rotateY = tilt.x * 8;
            const translateZ = -20; // ç¨å¾®å‘åé€€ä¸€ç‚¹ï¼Œé˜²æ­¢è¾¹ç¼˜ç©¿æ¨¡

            container.style.transform = `rotateX(${rotateX}deg) rotateY(${rotateY}deg) translateZ(${translateZ}px)`;
            container.style.transition = "transform 0.1s ease-out"; // å¹³æ»‘åŠ¨ç”»
        }
        // æ¨¡æ‹Ÿæ¿å­è¾¹ç¼˜å—å…‰ä¸å‡
        const grad = this.ctx.createRadialGradient(
            this.width / 2 + (tilt.x * 100), // å…‰å¿ƒéšå€¾æ–œç§»åŠ¨
            this.height / 2 + (tilt.y * 100),
            this.width * 0.2,
            this.width / 2,
            this.height / 2,
            this.width * 0.8
        );
        grad.addColorStop(0, 'rgba(30, 41, 59, 0)');
        grad.addColorStop(1, `rgba(2, 6, 23, ${0.3 + Math.abs(tilt.x) * 0.2})`); // å€¾æ–œè¶Šå¤§è¾¹ç¼˜è¶Šæš—

        this.ctx.fillStyle = grad;
        this.ctx.fillRect(0, 0, this.width, this.height);

        // 2.  è®¡ç®—åŠ¨æ€å…‰æºä½ç½®
        // å‡è®¾å…‰æºåœ¨å±å¹•ä¸Šæ–¹å¾ˆè¿œçš„åœ°æ–¹ã€‚å½“æ¿å­å‘å·¦å€¾æ–œ (tilt.x < 0) æ—¶ï¼Œ
        // é˜´å½±åº”è¯¥å‘å·¦ç§»åŠ¨ï¼Œæˆ–è€…è¯´å…‰æºçœ‹èµ·æ¥åƒæ˜¯åœ¨å³è¾¹ã€‚
        // è¿™é‡Œçš„é€»è¾‘æ˜¯ï¼šæ¿å­åŠ¨ï¼Œå…‰ä¸åŠ¨ -> ç›¸å¯¹è¿åŠ¨
        const lightSourcePos = new Vec2(
            this.width / 2 - (tilt.x * 300), // Xè½´åç§»ï¼šå€¾æ–œè¶Šå¤§ï¼Œå…‰æºç›¸å¯¹ä½ç§»è¶Šå¤§
            -200 - (tilt.y * 100)            // Yè½´åç§»
        );
        const LIGHT_RADIUS = 150;
        const LIGHT_RADIUS_SQ = LIGHT_RADIUS * LIGHT_RADIUS;// é¢„è®¡ç®—å¹³æ–¹ï¼Œé¿å…å¼€æ ¹å·
        // --- ç»˜åˆ¶é˜´å½± (ä¼ å…¥åŠ¨æ€å…‰æº) ---
        // DropBalls å‘å‡ºçš„å…‰
        this.dropBalls.forEach(ball => {
            if (!ball.active) return;
            this.pegs.forEach(p => {
                 // è¿™é‡Œæ˜¯åŸæœ‰çš„å°çƒå…‰ç…§é˜´å½±
                p.drawShadow(this.ctx, ball.pos, LIGHT_RADIUS);
            });
        });

        //  å…¨å±€ç¯å¢ƒå…‰é˜´å½± (åŸºäºå€¾æ–œ)
        // è®©æ‰€æœ‰é’‰å­éƒ½æœ‰ä¸€ä¸ªåŸºäºæ¿å­å€¾æ–œçš„å¾®å¼±åŸºç¡€é˜´å½±ï¼Œå¢åŠ ç«‹ä½“æ„Ÿ
        this.pegs.forEach(p => {
            // æˆ‘ä»¬åˆ©ç”¨ drawShadow çš„é€»è¾‘ï¼Œåˆ¶é€ ä¸€ä¸ªä¼ªé€ çš„â€œå¤ªé˜³â€
            p.drawShadow(this.ctx, lightSourcePos, 9999); // åŠå¾„å¾ˆå¤§ï¼Œè¦†ç›–å…¨å±
        });
        const lightSources = [...this.dropBalls];

        // --- ä¼˜åŒ–å¼€å§‹ï¼šåªå¯¹èŒƒå›´å†…çš„é’‰å­ç”»é˜´å½± ---
        lightSources.forEach(ball => {
            if (!ball.active) return;
            
            // éå†æ‰€æœ‰é’‰å­
            for (let i = 0; i < this.pegs.length; i++) {
                const p = this.pegs[i];
                // ç®€å•çš„ AABB é¢„åˆ¤æˆ–è·ç¦»å¹³æ–¹åˆ¤æ–­
                const dx = ball.pos.x - p.pos.x;
                const dy = ball.pos.y - p.pos.y;
                
                // åªæœ‰è·ç¦»å°äº LIGHT_RADIUS æ—¶æ‰ç»˜åˆ¶é˜´å½±
                // Math.abs æ£€æŸ¥æ¯”ä¹˜æ³•å¿«ï¼Œå…ˆåšç²—ç•¥ç­›é€‰
                if (Math.abs(dx) < LIGHT_RADIUS && Math.abs(dy) < LIGHT_RADIUS) {
                    if ((dx*dx + dy*dy) < LIGHT_RADIUS_SQ) {
                        p.drawShadow(this.ctx, ball.pos, LIGHT_RADIUS);
                        p.calculateLight(ball.pos, LIGHT_RADIUS); // å…‰ç…§è®¡ç®—ä¹Ÿæ”¾è¿™é‡Œ
                    }
                }
            }
        });
        // ç¹ªè£½é‡˜å­
        const pegRadius = Math.min(8, this.width / 60);
        this.pegs.forEach(p => { p.update(); p.draw(this.ctx, pegRadius); p.resetLight();});

        
        lightSources.forEach(ball => {
            // ä¼˜åŒ–ï¼šåªæ£€æŸ¥å‚ç›´è·ç¦»æ¥è¿‘çš„è¡Œï¼Œæˆ–è€…ç›´æ¥éå†æ‰€æœ‰ (é’‰å­æ•°é‡ä¸å¤šï¼Œç›´æ¥éå†æ€§èƒ½æ²¡é—®é¢˜)
            this.pegs.forEach(p => {
                // ç®€å•çš„æ€§èƒ½ä¼˜åŒ–ï¼šå¦‚æœYè½´è·ç¦»å¤ªè¿œå°±ä¸ç”¨ç®—å¹³æ–¹æ ¹äº†
                if (Math.abs(ball.pos.y - p.pos.y) < LIGHT_RADIUS) {
                    p.calculateLight(ball.pos, LIGHT_RADIUS);
                }
            });
        });
        this.specialSlots = this.specialSlots.filter(s => !s.hit);
        // ç¹ªè£½ç‰¹æ®Šæ§½ä½
        this.specialSlots.forEach(s => s.draw(this.ctx));
        // --- æ›´æ–°å’Œç»˜åˆ¶å…‰æŸ± ---
        for (let i = this.collectionBeams.length - 1; i >= 0; i--) {
            const beam = this.collectionBeams[i];
            beam.update(timeScale);
            beam.draw(this.ctx);
            if (beam.life <= 0) this.collectionBeams.splice(i, 1);
        }
        // æ›´æ–°å’Œç¹ªè£½ä¸‹è½çš„å½ˆç 
        for (let i = this.dropBalls.length - 1; i >= 0; i--) {
            const ball = this.dropBalls[i];
            // **é‡è¦åƒæ•¸** result: 'finished' (è½å‡ºå±å¹•), {type: 'collected', ...}, {type: 'slot', ...}, {action: 'split', ...}
            const result = ball.update(this.pegs, this.specialSlots, this.width, this.height, this.timeScale, tilt);
                
            //  ç»˜åˆ¶æ—¶ä¹Ÿå¯ä»¥ä¼ å…¥ tilt åšçƒä½“é«˜å…‰åç§» (å¯é€‰)
            ball.draw(this.ctx, tilt);
            
            if (result) {
                // è™•ç†å½ˆç è½å‡ºå±å¹•
                if (result === 'finished') {
                    // 1. ç”Ÿæˆå…‰æŸ± (åœ¨çƒæ‰è½çš„Xè½´ä½ç½®ï¼Œå±å¹•åº•éƒ¨å‡èµ·)
                    this.collectionBeams.push(new CollectionBeam(ball.pos.x, this.height));
                    
                    // 2. è§¦å‘ UI å¡ç‰‡é«˜äº®
                    // è·å–å½“å‰æ­£åœ¨è¿›è¡Œçš„é…æ–¹å¡ç‰‡ DOM å…ƒç´ 
                    // æ³¨æ„ï¼šnth-child æ˜¯ä» 1 å¼€å§‹çš„ï¼ŒactiveMarbleIndex æ˜¯ä» 0 å¼€å§‹
                    const activeCardIdx = this.activeMarbleIndex + 1;
                    const activeCard = document.querySelector(`#gathering-hud-mount .recipe-card:nth-child(${activeCardIdx})`);
                    
                    if (activeCard) {
                        // å…ˆç§»é™¤å¯èƒ½å­˜åœ¨çš„ç±»ï¼ˆä»¥é˜²ä¸‡ä¸€ï¼‰ï¼Œå¼ºåˆ¶é‡ç»˜ï¼Œå†æ·»åŠ 
                        activeCard.classList.remove('locked-anim');
                        void activeCard.offsetWidth; // è§¦å‘ Reflow
                        activeCard.classList.add('locked-anim');
                    }

                    // 3. æ’­æ”¾ä¸€ä¸ªç¡®è®¤éŸ³æ•ˆ (æ¯”å¦‚ reload æˆ– magic)
                    audio.playCollect(); // æˆ–è€… audio.playTone(800, 'sine', 0.2)
                    // å½ˆç è½å‡ºå±å¹•
                    this.dropBalls.splice(i, 1);
                    this.currentSession.activeBalls--;
                    
                    // --- ï¼šä¸å†ç›´æ¥çµç®—ï¼Œè€Œæ˜¯å˜—è©¦çµç®— ---
                    // è™•ç†â€œèƒ½é‡çƒå…ˆè½åœ°ï¼Œå½ˆç å¾Œæ­»â€çš„æƒ…æ³
                    this.attemptCompleteGatheringTurn();

                } else if (result.type === 'collected') {
                    // å½ˆç æ”¶é›†åˆ°ææ–™
                    this.currentSession.collected.push(result.material);
                    // è¿™æ · UI (renderRecipeCard) æ‰èƒ½è¯»å–åˆ°å˜åŒ–
                    if (this.marbleQueue[this.activeMarbleIndex]) {
                        this.marbleQueue[this.activeMarbleIndex].collected.push(result.material);
                    }
                    this.createHitFeedback(ball.pos.x, ball.pos.y, ball.vel, result.material); // é€™è£¡ä¹Ÿè¨±è¦å‚³å…¥å±¬æ€§é¡å‹ä½œç‚ºé¡è‰²ä¾æ“š
                    audio.playCollect();
                    this.renderRecipeHUD();
                    
                } else if (result.type === 'slot') {
                    // å½ˆç æ“Šä¸­ç‰¹æ®Šæ§½ä½
                    if (result.slotType === 'recall') {
                        // å›æº¯æ§½ä½ï¼šå°‡å½ˆç å‚³é€å›é ‚éƒ¨
                        ball.pos.y = 50;
                        ball.vel = new Vec2(0, 2);
                        showToast("å›æº¯!");
                    } else if (result.slotType === 'multicast') {
                        // å¤šé‡ç™¼å°„æ§½ä½ï¼šå¢åŠ å¤šé‡ç™¼å°„æ¬¡æ•¸
                        if (!this.currentSession.multicastAdded.includes(i)) {
                            this.currentSession.multicast++;
                            this.currentSession.multicastAdded.push(i);
                            showToast("+é€£å°„!");
                        }
                    } else if (result.slotType === 'split' && ball.canTriggerSplitSlot) {
                        // åˆ†è£‚æ§½ä½ï¼šåˆ†è£‚å½ˆç 
                        ball.canTriggerSplitSlot = false;
                        const newBall = new DropBall(ball.pos.x, ball.pos.y, ball.def, this.currentSession);
                        newBall.vel = new Vec2(-ball.vel.x, ball.vel.y);
                        newBall.canTriggerSplitSlot = false;
                        this.dropBalls.push(newBall);
                        this.currentSession.activeBalls++;
                        showToast("åˆ†è£‚!");
                    } else if (result.slotType === 'relic') {
                        // èª¿ç”¨éºç‰©é¸æ“‡
                        this.showRelicSelection(); 
                        
                        // å°‡å½ˆç ç§»é™¤
                        this.dropBalls.splice(i, 1);
                        this.currentSession.activeBalls--;
                    }
                } else if (result.action === 'split') {
                    // è™•ç† DropBall å…§éƒ¨è§¸ç™¼çš„åˆ†è£‚
                    const newBall1 = new DropBall(result.pos.x - 10, result.pos.y, result.def, this.currentSession);
                    const newBall2 = new DropBall(result.pos.x + 10, result.pos.y, result.def, this.currentSession);
                    newBall1.vel = new Vec2(-Math.abs(result.vel.x) - 2, result.vel.y);
                    newBall2.vel = new Vec2(Math.abs(result.vel.x) + 2, result.vel.y);
                    newBall1.canTriggerSplitSlot = false;
                    newBall2.canTriggerSplitSlot = false;
                    this.dropBalls.push(newBall1, newBall2);
                    this.currentSession.activeBalls += 1; 
                    this.dropBalls.splice(i, 1);
                    showToast("åˆ†è£‚!");
                } else if (result.action === 'rainbow_split') {
                    // è™•ç†å½©è™¹å½ˆç åˆ†è£‚
                    const colors = ['bounce', 'pierce', 'scatter'];
                    if (this.marbleQueue[this.activeMarbleIndex]) {
                        colors.forEach(c => {
                            this.marbleQueue[this.activeMarbleIndex].collected.push(c);
                        });
                    }
                    colors.forEach((c, idx) => {
                        const shardDef = new MarbleDefinition('colored', c);
                        const shard = new DropBall(result.pos.x + (idx - 1) * 20, result.pos.y, shardDef, this.currentSession);
                        shard.vel = new Vec2((idx - 1) * 3, result.vel.y);
                        shard.isRainbowShard = true;
                        this.dropBalls.push(shard);

                        // --- [æ–°å¢ä¿®å¤]ï¼šåˆ†è£‚æ—¶ç›´æ¥å°†å¯¹åº”çš„ææ–™åŠ å…¥æ”¶é›†åˆ—è¡¨ ---
                        this.currentSession.collected.push(c);
                    });
                    
                    this.currentSession.activeBalls += 2; // -1 (æœ¬ä½“) + 3 (ç¢ç‰‡) = +2
                    this.dropBalls.splice(i, 1);
                    
                    // --- [æ–°å¢ä¿®å¤]ï¼šåˆ·æ–° UI ä»¥æ˜¾ç¤ºæ–°æ”¶é›†åˆ°çš„ææ–™ ---
                    this.renderRecipeHUD();
                    
                    showToast("å½©è™¹åˆ†è£‚!");
                }
            }
        } 
        
        // --- æ›´æ–°å’Œç¹ªè£½èƒ½é‡çƒ ---
        for (let i = this.energyOrbs.length - 1; i >= 0; i--) {
            const orb = this.energyOrbs[i];
            orb.update(timeScale);
            orb.draw(this.ctx);
            if (!orb.active) this.energyOrbs.splice(i, 1);
        }
        // ç¹ªè£½ç²’å­
        for (let i = this.particles.length - 1; i >= 0; i--) {
            const p = this.particles[i];
            p.update(this.timeScale);
            p.draw(this.ctx);
            if (p.life <= 0) this.particles.splice(i, 1);
        }
        // æ›´æ–°å’Œç¹ªè£½ Shockwaves
        for (let i = this.shockwaves.length - 1; i >= 0; i--) {
            let s = this.shockwaves[i];
            if (s) {
                s.update(timeScale);
                s.draw(this.ctx);
                if (s.alpha <= 0) this.shockwaves.splice(i, 1);
            }
        }
        // åœ¨ updateGathering çš„æœ«å°¾æ·»åŠ å¯¹ DOM çš„æ“ä½œ
        //const container = document.getElementById('game-container');
        const tx = this.boardTilt.current.x * -10; // è´Ÿå€¼äº§ç”Ÿè§†å·®
        const ty = this.boardTilt.current.y * -5;

        // è¿™é‡Œçš„ transform ä¼šè®©æ•´ä¸ª UI äº§ç”Ÿå¾®å¼±çš„æ‚¬æµ®æ„Ÿ
        container.style.perspective = "1000px";
        // ç”šè‡³å¯ä»¥å¢åŠ æ—‹è½¬æ„Ÿ (è°¨æ…ä½¿ç”¨ï¼Œå¯èƒ½ä¼šæ™•)
        container.style.transform = `rotateY(${tx * 0.2}deg) rotateX(${-ty * 0.2}deg)`;

    }
}
/**
 * è°ƒæ•´ Hex é¢œè‰²çš„äº®åº¦
 * @param {string} hex - é¢œè‰²å€¼ (ä¾‹å¦‚ "#ff0000" æˆ– "f00")
 * @param {number} factor - äº®åº¦ç³»æ•° (1.0 = åŸè‰², 0.5 = å˜æš—50%, 1.5 = å˜äº®50%)
 * @returns {string} è°ƒæ•´åçš„ Hex é¢œè‰²
 */
function adjustColorBrightness(hex, factor) {
    // 1. ç§»é™¤å¯èƒ½å­˜åœ¨çš„ '#'
    hex = hex.replace('#', '');

    // 2. å¤„ç† 3 ä½ç®€å†™ (ä¾‹å¦‚ "f00" -> "ff0000")
    if (hex.length === 3) {
        hex = hex.split('').map(char => char + char).join('');
    }

    // 3. éªŒè¯æ˜¯å¦ä¸ºæœ‰æ•ˆçš„ 6 ä½ Hex
    if (hex.length !== 6) {
        console.warn("Invalid hex color:", hex);
        return "#000000"; // è¿”å›é»‘è‰²ä½œä¸ºå›é€€
    }

    // 4. è§£æ RGB åˆ†é‡
    let r = parseInt(hex.substring(0, 2), 16);
    let g = parseInt(hex.substring(2, 4), 16);
    let b = parseInt(hex.substring(4, 6), 16);

    // 5. åº”ç”¨ç³»æ•°å¹¶é’³åˆ¶èŒƒå›´åœ¨ 0 ~ 255
    // Math.round: å››èˆäº”å…¥å–æ•´
    // Math.min(255, ...): ç¡®ä¿ä¸è¶…è¿‡ç™½è‰²
    // Math.max(0, ...): ç¡®ä¿ä¸ä½äºé»‘è‰²
    r = Math.min(255, Math.max(0, Math.round(r * factor)));
    g = Math.min(255, Math.max(0, Math.round(g * factor)));
    b = Math.min(255, Math.max(0, Math.round(b * factor)));

    // 6. è½¬æ¢å› Hex å­—ç¬¦ä¸²ï¼Œå¹¶ç¡®ä¿å•ä½æ•°æ—¶å‰é¢è¡¥ '0'
    const rr = r.toString(16).padStart(2, '0');
    const gg = g.toString(16).padStart(2, '0');
    const bb = b.toString(16).padStart(2, '0');

    return `#${rr}${gg}${bb}`;
}
/**
 * é¢œè‰²çº¿æ€§æ’å€¼å‡½æ•°
 * @param {string} a - èµ·å§‹é¢œè‰² (HEX, e.g. #ffffff)
 * @param {string} b - ç»“æŸé¢œè‰² (HEX)
 * @param {number} amount - æ’å€¼ç³»æ•° (0.0 ~ 1.0)
 */
function lerpColor(a, b, amount) {
    const ah = parseInt(a.replace(/#/g, ''), 16),
          ar = ah >> 16, ag = ah >> 8 & 0xff, ab = ah & 0xff,
          bh = parseInt(b.replace(/#/g, ''), 16),
          br = bh >> 16, bg = bh >> 8 & 0xff, bb = bh & 0xff,
          rr = ar + amount * (br - ar),
          rg = ag + amount * (bg - ag),
          rb = ab + amount * (bb - ab);
    return '#' + ((1 << 24) + (Math.round(rr) << 16) + (Math.round(rg) << 8) + Math.round(rb)).toString(16).slice(1);
}
/**
 * ç·šæ€§æ’å€¼å‡½æ•¸ (Linear Interpolation)
 * ç”¨æ–¼åœ¨å…©å€‹æ•¸å€¼ä¹‹é–“é€²è¡Œå¹³æ»‘éæ¸¡
 * @param {number} start - èµ·å§‹å€¼
 * @param {number} end - ç›®æ¨™å€¼
 * @param {number} t - æ’å€¼ä¿‚æ•¸ (0 ~ 1ï¼Œè¶Šå°è¶Šæ…¢)
 * @returns {number} è¨ˆç®—å¾Œçš„ç•¶å‰å€¼
 */
function lerp(start, end, t) {
    return start * (1 - t) + end * t;
}
const game = new Game();
</script>
</body>
</html>